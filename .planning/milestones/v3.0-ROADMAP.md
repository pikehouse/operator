# Milestone v3.0: Operator Laboratory

**Status:** SHIPPED 2026-01-28
**Phases:** 30-32
**Total Plans:** 7

## Overview

Give Claude autonomy and a well-equipped environment rather than constraining it to predefined actions. Safety via isolation (Docker container), not restrictions. Audit everything, approve nothing.

**Philosophy:** The difference between giving someone a menu of 10 dishes vs giving them a full kitchen. We want the kitchen.

## Phases

### Phase 30: Core Agent

**Goal**: Agent container with shell tool and audit logging.
**Depends on**: None (greenfield v3.0 milestone)
**Plans**: 1 plan

Plans:
- [x] 30-01-PLAN.md — Agent Dockerfile, shell() tool, SessionAuditor

**Details:**
- Agent container Dockerfile (Python 3.12, Docker CLI, curl, jq, standard Unix tools)
- `shell(command, reasoning)` — execute any command, log with reasoning
- Audit log format (JSON, per-session)

**Note:** Scope narrowed from original — no web_search or web_fetch tools. Claude uses curl directly.

**Success Criteria:**
1. Agent container builds and runs with Docker socket access
2. shell() tool logs to audit format before and after execution
3. shell() can execute arbitrary commands with 120s timeout
4. SessionAuditor saves complete conversation history to JSON

**Completed:** 2026-01-28

---

### Phase 31: Agent Loop

**Goal**: The ~200 line core loop that runs Claude.
**Depends on**: Phase 30
**Plans**: 2 plans

Plans:
- [x] 31-01-PLAN.md — Core agent loop with tool_runner, database polling, Haiku summarization
- [x] 31-02-PLAN.md — Tool call/result audit logging (gap closure)

**Details:**
- Database polling for tickets (1-second interval)
- Claude conversation loop with tool_runner
- Haiku summarization of reasoning and tool outputs
- Database audit logging (not JSON files)
- System prompt for SRE agent

**Success Criteria:**
1. Agent polls database for open tickets every 1 second
2. Claude receives ticket and can call shell tool
3. Tool results summarized by Haiku before logging
4. Complete audit trail stored in database
5. Core loop is < 200 lines (198 lines)

**Completed:** 2026-01-28

---

### Phase 32: Integration & Demo

**Goal**: End-to-end validation against real subjects.
**Depends on**: Phases 30, 31
**Plans**: 4 plans

Plans:
- [x] 32-01-PLAN.md — Docker Compose for agent container (joins TiKV network)
- [x] 32-02-PLAN.md — CLI audit commands (list sessions, show conversation)
- [x] 32-03-PLAN.md — TUI demo integration (stream agent_lab output)
- [x] 32-04-PLAN.md — End-to-end validation (fault injection test)

**Details:**
- Docker Compose with agent container alongside subjects
- Agent can reach Prometheus, subjects, internet
- TiKV failure scenario validated
- Audit log review tooling

**Success Criteria:**
1. Agent container runs alongside TiKV cluster in Docker Compose
2. Claude autonomously diagnoses TiKV failure (no predefined playbook)
3. Claude fixes issue using shell commands (docker restart, etc.)
4. Complete audit log shows reasoning chain
5. Environment recoverable via docker-compose down/up

**Completed:** 2026-01-28

---

## Milestone Summary

**Key Decisions:**
- shell() is a pure execution function with no internal logging (agent loop handles audit)
- Synchronous shell() for tool_runner compatibility (tool_runner requires sync tools)
- Haiku summarization before database logging for concise audit trail
- 1-second polling interval balances responsiveness and database load
- Database audit logging instead of JSON files for queryability
- Global state (_last_shell_result) for tool result capture since tool_runner doesn't yield results separately
- Agent container uses external network (tikv_default) to join TiKV network
- Docker socket mounted for sibling container access pattern
- Direct SQLite access for read-only CLI audit queries (simpler than abstraction layer)

**Issues Resolved:**
- Dual shell() functions (async in tools.py, sync in loop.py) — sync required for tool_runner
- Tool call/result logging gap identified by verifier and closed with plan 31-02
- Agent container Dockerfile needed operator-protocols dependency

**Issues Deferred:**
- SessionAuditor (Phase 30 JSON file logging) unused but kept for API stability
- PYTHONUNBUFFERED inconsistency (docker-compose env var vs Python -u flag)

**Technical Debt Incurred:**
- Global state for tool result capture (works for single-threaded, revisit if concurrency added)
- Dual shell() implementations (async/sync) — consider consolidation when tool_runner supports async

---

_For current project status, see .planning/ROADMAP.md_
