---
phase: 23-safety-enhancement
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/operator-core/src/operator_core/actions/secrets.py
  - packages/operator-core/src/operator_core/actions/audit.py
  - packages/operator-core/pyproject.toml
autonomous: true

must_haves:
  truths:
    - "Audit logs redact secrets matching API_KEY=, password=, token= patterns"
    - "Bearer tokens in event data are redacted"
    - "Secrets in nested dictionaries are redacted"
    - "Redaction happens before writing to database, not after"
    - "detect-secrets library installed and used"
  artifacts:
    - path: "packages/operator-core/src/operator_core/actions/secrets.py"
      provides: "SecretRedactor class"
      exports: ["SecretRedactor"]
      contains: "redact_dict"
    - path: "packages/operator-core/src/operator_core/actions/audit.py"
      provides: "ActionAuditor with secret redaction"
      contains: "SecretRedactor"
  key_links:
    - from: "audit.py"
      to: "secrets.py"
      via: "import and instantiation"
      pattern: "from.*secrets import SecretRedactor"
    - from: "audit.py log_event"
      to: "SecretRedactor.redact_dict"
      via: "redaction before database write"
      pattern: "redact.*event_data"
---

<objective>
Implement secret redaction for audit logs to prevent credential leakage.

Purpose: SAFE-06 requires that audit logs redact secrets before logging. Parameters containing API keys, passwords, or tokens must be sanitized to prevent credential exposure in audit trails.

Output: SecretRedactor class using detect-secrets library; ActionAuditor integration that redacts all event_data before database writes.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-safety-enhancement/23-RESEARCH.md
@packages/operator-core/src/operator_core/actions/audit.py
@packages/operator-core/pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add detect-secrets dependency</name>
  <files>packages/operator-core/pyproject.toml</files>
  <action>
Add detect-secrets to the dependencies in pyproject.toml:

```
"detect-secrets>=1.5.0",
```

Add it in the dependencies list alongside existing packages like pydantic, httpx, etc.

Then reinstall the package to get the new dependency:
`cd /Users/jrtipton/x/operator/packages/operator-core && pip install -e .`

Note: detect-secrets is the industry-standard library from Yelp with 28+ detection plugins. Do NOT hand-roll regex patterns - use the library.
  </action>
  <verify>
Run: `python -c "from detect_secrets import SecretsCollection; print('detect-secrets installed')"`
  </verify>
  <done>detect-secrets>=1.5.0 is installed and importable.</done>
</task>

<task type="auto">
  <name>Task 2: Create SecretRedactor class</name>
  <files>packages/operator-core/src/operator_core/actions/secrets.py</files>
  <action>
Create a new file secrets.py with SecretRedactor class:

```python
"""
Secret redaction for audit logging (SAFE-06).

This module provides SecretRedactor for sanitizing event data before
writing to audit logs. Uses detect-secrets library for reliable detection.

Per project patterns:
- Use detect-secrets for detection, not hand-rolled regex
- Redact conservatively (if in doubt, redact)
- Handle nested dictionaries recursively
"""

import re
from typing import Any

# Note: detect-secrets is optional at import time to avoid hard dependency
# in environments where it's not needed
try:
    from detect_secrets import SecretsCollection
    from detect_secrets.settings import default_settings
    DETECT_SECRETS_AVAILABLE = True
except ImportError:
    DETECT_SECRETS_AVAILABLE = False


class SecretRedactor:
    """
    Redact secrets from event data before audit logging.

    Uses detect-secrets library for primary detection, plus custom
    patterns for common environment variable formats.

    Example:
        redactor = SecretRedactor()
        safe_data = redactor.redact_dict({"api_key": "sk_live_xxx"})
        # safe_data = {"api_key": "[REDACTED]"}
    """

    # Common patterns for environment variable secrets
    ENV_VAR_PATTERNS = [
        re.compile(r'(API_KEY|TOKEN|PASSWORD|SECRET|CREDENTIAL)[=:]\s*[\'"]?([^\s\'"]+)', re.IGNORECASE),
        re.compile(r'(apiKey|token|password|secret|credential)[\'"]?\s*[=:]\s*[\'"]?([^\s\'"}\]]+)', re.IGNORECASE),
        re.compile(r'Bearer\s+[A-Za-z0-9\-._~+/]+=*', re.IGNORECASE),
    ]

    # Keys that should always be redacted
    SENSITIVE_KEYS = {
        'password', 'passwd', 'pwd',
        'secret', 'secrets',
        'token', 'tokens', 'auth_token', 'access_token', 'refresh_token',
        'api_key', 'apikey', 'api_secret',
        'credential', 'credentials',
        'private_key', 'privatekey',
        'bearer',
    }

    def __init__(self) -> None:
        """Initialize the secret redactor."""
        if DETECT_SECRETS_AVAILABLE:
            self._secrets_collection = SecretsCollection()
        else:
            self._secrets_collection = None

    def redact_dict(self, data: dict[str, Any]) -> dict[str, Any]:
        """
        Recursively redact secrets from dictionary.

        Args:
            data: Dictionary that may contain secrets

        Returns:
            New dict with secrets replaced by '[REDACTED]'
        """
        if not data:
            return data

        redacted: dict[str, Any] = {}
        for key, value in data.items():
            redacted[key] = self._redact_value(key, value)
        return redacted

    def _redact_value(self, key: str, value: Any) -> Any:
        """Redact a single value, handling nested structures."""
        # Check if key name indicates sensitive data
        if key.lower() in self.SENSITIVE_KEYS:
            return '[REDACTED]'

        if isinstance(value, dict):
            return self.redact_dict(value)
        elif isinstance(value, list):
            return [self._redact_value('', item) for item in value]
        elif isinstance(value, str):
            return self._redact_string(value)
        else:
            return value

    def _redact_string(self, text: str) -> str:
        """
        Redact secrets from string using patterns and detect-secrets.

        Args:
            text: String that may contain secrets

        Returns:
            String with secrets replaced by '[REDACTED]'
        """
        if not text:
            return text

        # Check with detect-secrets if available
        if self._secrets_collection is not None:
            try:
                with default_settings():
                    # Check if text looks like it contains a secret
                    self._secrets_collection.scan_line(text)
                    if self._secrets_collection:
                        self._secrets_collection.data.clear()  # Reset for next check
                        return '[REDACTED]'
            except Exception:
                # If detect-secrets fails, fall through to regex patterns
                pass

        # Apply custom patterns for env var formats
        redacted = text
        for pattern in self.ENV_VAR_PATTERNS:
            if pattern.search(redacted):
                # Replace the value portion while keeping the key
                redacted = pattern.sub(
                    lambda m: f"{m.group(1)}=[REDACTED]" if '=' in m.group(0) else '[REDACTED]',
                    redacted
                )

        return redacted


# Singleton for convenience
_default_redactor: SecretRedactor | None = None


def get_redactor() -> SecretRedactor:
    """Get the default SecretRedactor instance."""
    global _default_redactor
    if _default_redactor is None:
        _default_redactor = SecretRedactor()
    return _default_redactor
```
  </action>
  <verify>
Run: `cd /Users/jrtipton/x/operator/packages/operator-core && python -c "
from operator_core.actions.secrets import SecretRedactor

r = SecretRedactor()

# Test sensitive key detection
result = r.redact_dict({'password': 'secret123', 'name': 'john'})
assert result['password'] == '[REDACTED]'
assert result['name'] == 'john'
print('Key-based redaction: PASS')

# Test env var pattern
result = r.redact_dict({'config': 'API_KEY=sk_live_xxx123'})
assert 'sk_live' not in result['config']
print('Env var pattern: PASS')

# Test nested dict
result = r.redact_dict({'auth': {'token': 'abc123'}})
assert result['auth']['token'] == '[REDACTED]'
print('Nested dict: PASS')

print('All tests PASS')
"`
  </verify>
  <done>SecretRedactor class detects and redacts secrets in dictionaries using both key-based and pattern-based detection.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate SecretRedactor with ActionAuditor</name>
  <files>packages/operator-core/src/operator_core/actions/audit.py</files>
  <action>
Modify ActionAuditor to use SecretRedactor:

1. Add import at top: `from operator_core.actions.secrets import SecretRedactor`

2. In __init__, create redactor instance:
   `self._redactor = SecretRedactor()`

3. In log_event() method, redact event_data BEFORE writing to database:
   ```python
   async def log_event(self, event: AuditEvent) -> None:
       # Redact secrets from event_data before logging (SAFE-06)
       redacted_event_data = None
       if event.event_data:
           redacted_event_data = self._redactor.redact_dict(event.event_data)

       event_data_json = json.dumps(redacted_event_data) if redacted_event_data else None
       # ... rest of method
   ```

CRITICAL: Redaction MUST happen before json.dumps() and database write. If you redact after writing, secrets are already in the database.

Also update log_proposal_created() since it includes parameters in event_data:
```python
async def log_proposal_created(self, proposal: ActionProposal) -> None:
    # Parameters may contain secrets - they get redacted in log_event
    await self.log_event(AuditEvent(
        # ... existing code unchanged, redaction happens in log_event
    ))
```
  </action>
  <verify>
Run: `cd /Users/jrtipton/x/operator/packages/operator-core && python -c "
import asyncio
from pathlib import Path
import tempfile
from operator_core.actions.audit import ActionAuditor, AuditEvent
from datetime import datetime

async def test():
    with tempfile.TemporaryDirectory() as tmp:
        db_path = Path(tmp) / 'test.db'
        auditor = ActionAuditor(db_path)

        # Log event with secrets
        await auditor.log_event(AuditEvent(
            proposal_id=1,
            event_type='test',
            event_data={
                'password': 'secret123',
                'api_key': 'sk_live_xxx',
                'name': 'test'
            },
            actor='test'
        ))

        # Retrieve and verify secrets are redacted
        events = await auditor.get_events(proposal_id=1)
        assert len(events) == 1
        event = events[0]

        # Password should be redacted (key-based)
        assert event.event_data['password'] == '[REDACTED]'
        # API key should be redacted (key-based)
        assert event.event_data['api_key'] == '[REDACTED]'
        # Name should NOT be redacted
        assert event.event_data['name'] == 'test'

        print('Secrets redacted in audit log: PASS')

asyncio.run(test())
"`
  </verify>
  <done>ActionAuditor redacts secrets from event_data before writing to database; retrieved events show redacted values.</done>
</task>

</tasks>

<verification>
1. detect-secrets library is installed
2. SecretRedactor detects secrets by key name (password, token, etc.)
3. SecretRedactor detects secrets by pattern (API_KEY=xxx, Bearer xxx)
4. ActionAuditor uses SecretRedactor before database writes
5. Existing tests still pass
</verification>

<success_criteria>
- Audit logs show [REDACTED] instead of actual secret values
- Redaction works for nested dictionaries
- Both key-based and pattern-based detection work
- No secrets visible in action_audit_log table
</success_criteria>

<output>
After completion, create `.planning/phases/23-safety-enhancement/23-02-SUMMARY.md`
</output>
