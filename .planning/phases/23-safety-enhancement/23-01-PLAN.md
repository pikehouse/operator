---
phase: 23-safety-enhancement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/operator-core/src/operator_core/actions/types.py
  - packages/operator-core/src/operator_core/db/schema.py
  - packages/operator-core/src/operator_core/db/actions.py
  - packages/operator-core/src/operator_core/actions/authorization.py
autonomous: true

must_haves:
  truths:
    - "ActionProposal has requester_id field tracking who initiated the request"
    - "ActionProposal has agent_id field tracking which agent executes"
    - "ActionProposal has requester_type field distinguishing user vs system vs agent"
    - "Database schema includes columns for identity fields"
    - "Existing proposals without identity fields don't break on migration"
    - "Dual authorization check verifies both requester permission and agent capability"
  artifacts:
    - path: "packages/operator-core/src/operator_core/actions/types.py"
      provides: "ActionProposal with identity fields"
      contains: "requester_id"
    - path: "packages/operator-core/src/operator_core/db/schema.py"
      provides: "Schema with identity columns"
      contains: "requester_id"
    - path: "packages/operator-core/src/operator_core/db/actions.py"
      provides: "Database operations for identity fields"
      contains: "requester_id"
    - path: "packages/operator-core/src/operator_core/actions/authorization.py"
      provides: "Dual authorization checker"
      exports: ["check_dual_authorization"]
      contains: "_check_dual_authorization"
  key_links:
    - from: "types.py"
      to: "actions.py"
      via: "ActionProposal model used in _row_to_proposal"
      pattern: "requester_id=row"
    - from: "authorization.py"
      to: "executor.py"
      via: "authorization check before execution"
      pattern: "check_dual_authorization"
---

<objective>
Add identity tracking fields to ActionProposal and implement dual authorization check for SAFE-04.

Purpose: SAFE-03 and SAFE-04 require tracking both the requester (who asked for the action) and the agent (which AI component is executing). This enables audit trails that answer "who requested this?" and "which agent did it?" Additionally, SAFE-04 requires verifying both requester permission AND agent capability before execution.

Output: Enhanced ActionProposal with requester_id, agent_id, requester_type fields; updated schema and database operations; dual authorization checker function.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-safety-enhancement/23-RESEARCH.md
@packages/operator-core/src/operator_core/actions/types.py
@packages/operator-core/src/operator_core/db/schema.py
@packages/operator-core/src/operator_core/db/actions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add identity fields to ActionProposal</name>
  <files>packages/operator-core/src/operator_core/actions/types.py</files>
  <action>
Add three new fields to ActionProposal class:

1. requester_id: str = Field(default="unknown", description="Identity of requester (user email, system name, or 'agent:autonomous')")
2. requester_type: str = Field(default="agent", description="Type of requester: 'user', 'system', or 'agent'")
3. agent_id: str | None = Field(default=None, description="Identity of agent executing action (if delegated)")

Place these fields after the existing proposed_by field for logical grouping. Update the class docstring to document the dual identity concept.

Keep proposed_by for backwards compatibility - it remains "agent" or "user" to indicate WHO created the proposal, while requester_id/agent_id track authorization chain.

Rationale from research: This follows OAuth delegation patterns where requester_id is like resource owner and agent_id is like client acting on their behalf.
  </action>
  <verify>
Run: `cd /Users/jrtipton/x/operator/packages/operator-core && python -c "from operator_core.actions.types import ActionProposal; p = ActionProposal(action_name='test', reason='test'); print(f'requester_id={p.requester_id}, agent_id={p.agent_id}, requester_type={p.requester_type}')"` should print defaults.
  </verify>
  <done>ActionProposal has requester_id, agent_id, and requester_type fields with sensible defaults that don't break existing code.</done>
</task>

<task type="auto">
  <name>Task 2: Update schema and database operations</name>
  <files>
packages/operator-core/src/operator_core/db/schema.py
packages/operator-core/src/operator_core/db/actions.py
  </files>
  <action>
In schema.py ACTIONS_SCHEMA_SQL, add columns to action_proposals table definition:
- requester_id TEXT NOT NULL DEFAULT 'unknown'
- requester_type TEXT NOT NULL DEFAULT 'agent'
- agent_id TEXT

In actions.py:
1. Add migration ALTER TABLE statements in _ensure_schema() following existing pattern (try/except for each column)
2. Update _row_to_proposal() to read new fields from row
3. Update create_proposal() INSERT to include new fields
4. Update any other methods that need to handle these fields

Follow existing migration pattern - use individual try/except blocks per column so existing databases migrate cleanly.
  </action>
  <verify>
Run: `cd /Users/jrtipton/x/operator/packages/operator-core && python -c "
import asyncio
from pathlib import Path
import tempfile
from operator_core.db.actions import ActionDB
from operator_core.actions.types import ActionProposal

async def test():
    with tempfile.TemporaryDirectory() as tmp:
        db_path = Path(tmp) / 'test.db'
        async with ActionDB(db_path) as db:
            proposal = ActionProposal(
                action_name='test',
                reason='test',
                requester_id='user@example.com',
                requester_type='user',
                agent_id='agent-123'
            )
            created = await db.create_proposal(proposal)
            fetched = await db.get_proposal(created.id)
            print(f'requester_id={fetched.requester_id}, agent_id={fetched.agent_id}')
            assert fetched.requester_id == 'user@example.com'
            assert fetched.agent_id == 'agent-123'
            print('PASS')

asyncio.run(test())
"`
  </verify>
  <done>Database stores and retrieves identity fields correctly; existing databases migrate without error.</done>
</task>

<task type="auto">
  <name>Task 3: Implement dual authorization checker (SAFE-04)</name>
  <files>packages/operator-core/src/operator_core/actions/authorization.py</files>
  <action>
Create new file authorization.py with dual authorization check function:

```python
"""
Dual authorization checking for SAFE-04.

This module provides authorization verification that checks BOTH:
1. Requester permission - does the requester have rights to request this action?
2. Agent capability - is this agent allowed to execute this action type?

This implements the OAuth-style delegation model where a requester (resource owner)
delegates to an agent (client) which must have appropriate capability grants.
"""

from typing import Any, Protocol
from operator_core.actions.types import ActionProposal


class AuthorizationError(Exception):
    """Raised when authorization check fails."""
    def __init__(self, proposal_id: int, reason: str, requester_id: str | None = None, agent_id: str | None = None):
        self.proposal_id = proposal_id
        self.reason = reason
        self.requester_id = requester_id
        self.agent_id = agent_id
        super().__init__(f"Authorization failed for proposal {proposal_id}: {reason}")


class PermissionChecker(Protocol):
    """Protocol for checking requester permissions."""
    def has_permission(self, requester_id: str, action_name: str) -> bool:
        """Check if requester can request this action."""
        ...


class CapabilityChecker(Protocol):
    """Protocol for checking agent capabilities."""
    def has_capability(self, agent_id: str, action_name: str) -> bool:
        """Check if agent can execute this action."""
        ...


class DefaultPermissionChecker:
    """Default implementation that allows all requesters."""
    def has_permission(self, requester_id: str, action_name: str) -> bool:
        # Default: all requesters can request any action
        # Override in production with actual permission checks
        return True


class DefaultCapabilityChecker:
    """Default implementation that allows all agents."""
    def has_capability(self, agent_id: str, action_name: str) -> bool:
        # Default: all agents can execute any action
        # Override in production with actual capability grants
        return True


def check_dual_authorization(
    proposal: ActionProposal,
    permission_checker: PermissionChecker | None = None,
    capability_checker: CapabilityChecker | None = None,
) -> None:
    """
    Verify both requester permission and agent capability (SAFE-04).

    This function implements the dual authorization model:
    1. Check requester_id has permission for the action_name
    2. Check agent_id has capability for the action_name

    Args:
        proposal: The ActionProposal to authorize
        permission_checker: Checker for requester permissions (default allows all)
        capability_checker: Checker for agent capabilities (default allows all)

    Raises:
        AuthorizationError: If either check fails
    """
    if permission_checker is None:
        permission_checker = DefaultPermissionChecker()
    if capability_checker is None:
        capability_checker = DefaultCapabilityChecker()

    # Check 1: Requester permission
    if not permission_checker.has_permission(proposal.requester_id, proposal.action_name):
        raise AuthorizationError(
            proposal_id=proposal.id,
            reason=f"Requester '{proposal.requester_id}' lacks permission for action '{proposal.action_name}'",
            requester_id=proposal.requester_id,
            agent_id=proposal.agent_id,
        )

    # Check 2: Agent capability (if agent is specified)
    if proposal.agent_id is not None:
        if not capability_checker.has_capability(proposal.agent_id, proposal.action_name):
            raise AuthorizationError(
                proposal_id=proposal.id,
                reason=f"Agent '{proposal.agent_id}' lacks capability for action '{proposal.action_name}'",
                requester_id=proposal.requester_id,
                agent_id=proposal.agent_id,
            )


def _check_dual_authorization(
    requester_id: str,
    agent_id: str | None,
    action_name: str,
    permission_checker: PermissionChecker | None = None,
    capability_checker: CapabilityChecker | None = None,
) -> bool:
    """
    Internal helper to check dual authorization without a full proposal.

    Args:
        requester_id: Identity of the requester
        agent_id: Identity of the agent (if delegated)
        action_name: Name of the action to authorize
        permission_checker: Checker for requester permissions
        capability_checker: Checker for agent capabilities

    Returns:
        True if authorized, False otherwise
    """
    if permission_checker is None:
        permission_checker = DefaultPermissionChecker()
    if capability_checker is None:
        capability_checker = DefaultCapabilityChecker()

    # Check requester permission
    if not permission_checker.has_permission(requester_id, action_name):
        return False

    # Check agent capability if agent specified
    if agent_id is not None:
        if not capability_checker.has_capability(agent_id, action_name):
            return False

    return True
```
  </action>
  <verify>
Run: `cd /Users/jrtipton/x/operator/packages/operator-core && python -c "
from operator_core.actions.authorization import (
    check_dual_authorization, _check_dual_authorization,
    AuthorizationError, DefaultPermissionChecker, DefaultCapabilityChecker
)
from operator_core.actions.types import ActionProposal

# Test default checkers allow all
proposal = ActionProposal(
    action_name='test',
    reason='test',
    requester_id='user@example.com',
    agent_id='agent-123'
)
check_dual_authorization(proposal)  # Should not raise
print('Default checkers allow: PASS')

# Test internal helper
result = _check_dual_authorization('user@example.com', 'agent-123', 'test')
assert result == True
print('Internal helper works: PASS')

# Test custom checker that denies
class DenyAllPermissions:
    def has_permission(self, requester_id, action_name):
        return False

try:
    check_dual_authorization(proposal, permission_checker=DenyAllPermissions())
    assert False, 'Should have raised'
except AuthorizationError as e:
    assert 'lacks permission' in str(e)
    print('Custom deny checker works: PASS')

print('All authorization tests PASS')
"`
  </verify>
  <done>Dual authorization checker implemented with check_dual_authorization() and _check_dual_authorization() functions; verifies both requester permission and agent capability.</done>
</task>

<task type="auto">
  <name>Task 4: Run existing tests to verify no regressions</name>
  <files></files>
  <action>
Run the full test suite for operator-core to ensure identity field additions don't break existing functionality.

If any tests fail due to the new required fields, update them to provide appropriate test values.

Focus on:
- Action proposal creation tests
- Database migration tests
- Any tests that serialize/deserialize ActionProposal
  </action>
  <verify>
Run: `cd /Users/jrtipton/x/operator/packages/operator-core && python -m pytest tests/ -v --tb=short 2>&1 | tail -20`
All tests should pass.
  </verify>
  <done>All existing tests pass with identity field additions.</done>
</task>

</tasks>

<verification>
1. ActionProposal can be instantiated with identity fields
2. Database round-trip preserves identity fields
3. Existing proposals (with NULL identity fields) load correctly with defaults
4. check_dual_authorization verifies both requester and agent
5. AuthorizationError raised when either check fails
6. Full test suite passes
</verification>

<success_criteria>
- requester_id, agent_id, requester_type fields exist on ActionProposal
- Database schema includes these columns
- Migrations don't break existing databases
- check_dual_authorization and _check_dual_authorization functions work correctly
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/23-safety-enhancement/23-01-SUMMARY.md`
</output>
