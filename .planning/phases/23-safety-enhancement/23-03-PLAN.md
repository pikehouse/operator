---
phase: 23-safety-enhancement
plan: 03
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - packages/operator-core/src/operator_core/actions/types.py
  - packages/operator-core/src/operator_core/actions/executor.py
  - packages/operator-core/src/operator_core/db/schema.py
  - packages/operator-core/src/operator_core/db/actions.py
  - packages/operator-core/src/operator_core/actions/audit.py
autonomous: true

must_haves:
  truths:
    - "Approval tokens expire after 60 seconds"
    - "Execution re-verifies proposal state before proceeding (TOCTOU defense)"
    - "Concurrent execution attempts fail if proposal state changed"
    - "Audit logs show both requester_id and agent_id for all actions"
    - "Approval token mismatch blocks execution"
  artifacts:
    - path: "packages/operator-core/src/operator_core/actions/types.py"
      provides: "ActionProposal with approval_token and version fields"
      contains: "approval_token"
    - path: "packages/operator-core/src/operator_core/actions/executor.py"
      provides: "TOCTOU-resistant execute_proposal"
      contains: "_execution_lock"
    - path: "packages/operator-core/src/operator_core/db/actions.py"
      provides: "Optimistic locking operations"
      contains: "expected_version"
  key_links:
    - from: "executor.py execute_proposal"
      to: "asyncio.Lock"
      via: "async with self._execution_lock"
      pattern: "_execution_lock"
    - from: "executor.py"
      to: "db update with version"
      via: "optimistic locking check"
      pattern: "expected_version"
    - from: "audit.py"
      to: "dual identity logging"
      via: "requester_id and agent_id in event_data"
      pattern: "requester_id.*agent_id"
---

<objective>
Implement TOCTOU-resistant approval workflow with token expiration and dual identity audit logging.

Purpose: SAFE-01 (TOCTOU defense), SAFE-02 (token expiry), SAFE-04 (dual authorization), SAFE-05 (audit with both identities). This prevents race conditions where system state changes between approval and execution.

Output: Approval tokens with 60s expiry; asyncio.Lock-protected execution with double-check pattern; optimistic locking on database updates; enhanced audit logging with dual identity.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-safety-enhancement/23-RESEARCH.md
@.planning/phases/23-safety-enhancement/23-01-SUMMARY.md
@packages/operator-core/src/operator_core/actions/types.py
@packages/operator-core/src/operator_core/actions/executor.py
@packages/operator-core/src/operator_core/db/actions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add approval_token and version fields to ActionProposal</name>
  <files>
packages/operator-core/src/operator_core/actions/types.py
packages/operator-core/src/operator_core/db/schema.py
packages/operator-core/src/operator_core/db/actions.py
  </files>
  <action>
In types.py, add to ActionProposal:

```python
# TOCTOU defense fields (SAFE-01, SAFE-02)
approval_token: str | None = Field(
    default=None,
    description="One-time cryptographic token for approval verification"
)
version: int = Field(
    default=1,
    description="Optimistic lock version, incremented on every update"
)
```

In schema.py ACTIONS_SCHEMA_SQL, add columns:
- approval_token TEXT
- version INTEGER DEFAULT 1

In actions.py:
1. Add migration ALTER TABLE statements in _ensure_schema() for approval_token and version columns
2. Update _row_to_proposal() to read approval_token and version from row
3. Update create_proposal() INSERT to include approval_token and version
4. Add new method update_proposal_with_version() that checks version in WHERE clause:
   ```python
   async def update_proposal_status_with_version(
       self,
       proposal_id: int,
       status: ActionStatus,
       expected_version: int,
   ) -> bool:
       """
       Update proposal status with optimistic lock check.

       Returns True if update succeeded, False if version mismatch.
       """
       # UPDATE ... SET status=?, version=version+1 WHERE id=? AND version=?
       # Check cursor.rowcount > 0 to verify update happened
   ```

5. Update approve_proposal() to generate approval_token using secrets.token_urlsafe(32):
   ```python
   import secrets

   async def approve_proposal(self, proposal_id: int, approved_by: str = "user") -> str:
       """
       Mark proposal as approved and generate approval token.
       Returns the approval token.
       """
       token = secrets.token_urlsafe(32)
       # UPDATE to set approved_at, approved_by, approval_token
       return token
   ```
  </action>
  <verify>
Run: `cd /Users/jrtipton/x/operator/packages/operator-core && python -c "
import asyncio
from pathlib import Path
import tempfile
from operator_core.db.actions import ActionDB
from operator_core.actions.types import ActionProposal, ActionStatus

async def test():
    with tempfile.TemporaryDirectory() as tmp:
        db_path = Path(tmp) / 'test.db'
        async with ActionDB(db_path) as db:
            # Create proposal
            proposal = ActionProposal(action_name='test', reason='test')
            created = await db.create_proposal(proposal)
            print(f'Initial version: {created.version}')
            assert created.version == 1

            # Validate to get to validated status
            await db.update_proposal_status(created.id, ActionStatus.VALIDATED)

            # Approve and get token
            token = await db.approve_proposal(created.id, 'user')
            print(f'Token generated: {len(token)} chars')
            assert len(token) > 20  # secrets.token_urlsafe(32) is ~43 chars

            # Verify token is stored
            fetched = await db.get_proposal(created.id)
            assert fetched.approval_token == token
            print('Token stored correctly: PASS')

asyncio.run(test())
"`
  </verify>
  <done>ActionProposal has approval_token and version fields; approve_proposal generates cryptographic token.</done>
</task>

<task type="auto">
  <name>Task 2: Implement TOCTOU-resistant execute_proposal</name>
  <files>packages/operator-core/src/operator_core/actions/executor.py</files>
  <action>
Modify ActionExecutor to implement TOCTOU-resistant execution:

1. Add asyncio.Lock in __init__:
   ```python
   import asyncio

   def __init__(self, ...):
       # ... existing code ...
       self._execution_lock = asyncio.Lock()
   ```

2. Add token expiration check helper:
   ```python
   from datetime import datetime, timezone, timedelta

   def _is_approval_expired(self, approved_at: datetime, expiration_seconds: int = 60) -> bool:
       """Check if approval token has expired (SAFE-02)."""
       now = datetime.now(timezone.utc)
       if approved_at.tzinfo is None:
           approved_at = approved_at.replace(tzinfo=timezone.utc)
       age = (now - approved_at).total_seconds()
       return age > expiration_seconds
   ```

3. Add new exceptions at module level:
   ```python
   class ApprovalExpiredError(Exception):
       """Raised when approval token has expired."""
       def __init__(self, proposal_id: int, age_seconds: float):
           self.proposal_id = proposal_id
           self.age_seconds = age_seconds
           super().__init__(f"Approval for proposal {proposal_id} expired ({age_seconds:.1f}s > 60s)")

   class StateChangedError(Exception):
       """Raised when system state changed between approval and execution."""
       def __init__(self, proposal_id: int, reason: str):
           self.proposal_id = proposal_id
           self.reason = reason
           super().__init__(f"State changed for proposal {proposal_id}: {reason}")

   class InvalidTokenError(Exception):
       """Raised when approval token doesn't match."""
       def __init__(self, proposal_id: int):
           self.proposal_id = proposal_id
           super().__init__(f"Invalid approval token for proposal {proposal_id}")
   ```

4. Rewrite execute_proposal with double-check pattern:
   ```python
   async def execute_proposal(
       self,
       proposal_id: int,
       subject: "Subject",
       approval_token: str | None = None,  # Required if approval mode is on
   ) -> ActionRecord:
       """
       Execute a validated proposal with TOCTOU defense (SAFE-01).

       The double-check pattern:
       1. Fast path check (no lock)
       2. Acquire lock
       3. Re-verify state (TOCTOU defense)
       4. Check token expiration (SAFE-02)
       5. Verify token matches
       6. Update status with optimistic lock
       7. Execute action
       """
       self._safety.check_can_execute()

       from operator_core.db.actions import ActionDB

       # Fast path check (no lock)
       async with ActionDB(self.db_path) as db:
           proposal = await db.get_proposal(proposal_id)

       if proposal is None:
           raise ValueError(f"Proposal {proposal_id} not found")

       # Approval check for approval mode
       if self._requires_approval(proposal):
           if not proposal.is_approved:
               raise ApprovalRequiredError(proposal.id, proposal.action_name)
           if approval_token is None:
               raise InvalidTokenError(proposal_id)

       # Acquire lock for TOCTOU-resistant execution
       async with self._execution_lock:
           async with ActionDB(self.db_path) as db:
               # CRITICAL: Re-fetch after acquiring lock (TOCTOU defense)
               proposal = await db.get_proposal(proposal_id)

               if proposal is None:
                   raise ValueError(f"Proposal {proposal_id} not found")

               # 1. Verify still approved (state could have changed)
               if self._requires_approval(proposal):
                   if not proposal.is_approved:
                       await self._auditor.log_event(AuditEvent(
                           proposal_id=proposal_id,
                           event_type="toctou_blocked",
                           event_data={"reason": "approval_revoked"},
                           actor="system",
                       ))
                       raise StateChangedError(proposal_id, "approval_revoked")

                   # 2. Check token expiration (SAFE-02)
                   if self._is_approval_expired(proposal.approved_at):
                       await self._auditor.log_event(AuditEvent(
                           proposal_id=proposal_id,
                           event_type="toctou_blocked",
                           event_data={"reason": "token_expired"},
                           actor="system",
                       ))
                       raise ApprovalExpiredError(proposal_id, (datetime.now(timezone.utc) - proposal.approved_at.replace(tzinfo=timezone.utc)).total_seconds())

                   # 3. Verify token matches
                   if proposal.approval_token != approval_token:
                       await self._auditor.log_event(AuditEvent(
                           proposal_id=proposal_id,
                           event_type="toctou_blocked",
                           event_data={"reason": "token_mismatch"},
                           actor="system",
                       ))
                       raise InvalidTokenError(proposal_id)

               # 4. Verify proposal is in VALIDATED state
               if proposal.status != ActionStatus.VALIDATED:
                   raise ValueError(f"Proposal {proposal_id} is {proposal.status.value}, expected 'validated'")

               # 5. Update status with optimistic lock check
               success = await db.update_proposal_status_with_version(
                   proposal_id,
                   ActionStatus.EXECUTING,
                   expected_version=proposal.version,
               )
               if not success:
                   await self._auditor.log_event(AuditEvent(
                       proposal_id=proposal_id,
                       event_type="toctou_blocked",
                       event_data={"reason": "concurrent_modification"},
                       actor="system",
                   ))
                   raise StateChangedError(proposal_id, "concurrent_modification")

               # Log execution started with dual identity (SAFE-05)
               await self._auditor.log_execution_started(
                   proposal_id,
                   requester_id=proposal.requester_id,
                   agent_id=proposal.agent_id,
               )

               # ... rest of execution logic stays the same ...
   ```

NOTE: Import AuditEvent at top of file: `from operator_core.actions.audit import ActionAuditor, AuditEvent`
  </action>
  <verify>
Run: `cd /Users/jrtipton/x/operator/packages/operator-core && python -c "
import asyncio
from operator_core.actions.executor import ActionExecutor, ApprovalExpiredError, InvalidTokenError

# Verify new exceptions exist
print('ApprovalExpiredError:', ApprovalExpiredError)
print('InvalidTokenError:', InvalidTokenError)

# Verify executor has _execution_lock
from pathlib import Path
import tempfile
from operator_core.actions.registry import ActionRegistry
from operator_core.actions.safety import SafetyController
from operator_core.actions.audit import ActionAuditor

with tempfile.TemporaryDirectory() as tmp:
    db_path = Path(tmp) / 'test.db'
    auditor = ActionAuditor(db_path)
    safety = SafetyController(db_path, auditor)
    registry = ActionRegistry()
    executor = ActionExecutor(db_path, registry, safety, auditor)

    assert hasattr(executor, '_execution_lock')
    print('Executor has _execution_lock: PASS')
"`
  </verify>
  <done>ActionExecutor uses asyncio.Lock for TOCTOU-resistant execution; token expiration and version checks implemented.</done>
</task>

<task type="auto">
  <name>Task 3: Update audit logging with dual identity</name>
  <files>packages/operator-core/src/operator_core/actions/audit.py</files>
  <action>
Update ActionAuditor.log_execution_started() to accept and log dual identity:

```python
async def log_execution_started(
    self,
    proposal_id: int,
    requester_id: str | None = None,
    agent_id: str | None = None,
) -> None:
    """
    Log that execution has started for a proposal (SAFE-05).

    Args:
        proposal_id: The proposal being executed
        requester_id: Identity of who requested this action
        agent_id: Identity of agent executing the action
    """
    event_data = {}
    if requester_id:
        event_data["requester_id"] = requester_id
    if agent_id:
        event_data["agent_id"] = agent_id

    await self.log_event(AuditEvent(
        proposal_id=proposal_id,
        event_type="executing",
        event_data=event_data if event_data else None,
        actor="system",
        timestamp=datetime.now(),
    ))
```

Also update log_execution_completed() to optionally include identity:
```python
async def log_execution_completed(
    self,
    proposal_id: int,
    success: bool,
    error: str | None = None,
    duration_ms: int | None = None,
    result: dict[str, Any] | None = None,
    requester_id: str | None = None,
    agent_id: str | None = None,
) -> None:
    # ... include requester_id and agent_id in event_data if provided
```

This ensures audit logs contain the full authorization chain for compliance.
  </action>
  <verify>
Run: `cd /Users/jrtipton/x/operator/packages/operator-core && python -c "
import asyncio
from pathlib import Path
import tempfile
from operator_core.actions.audit import ActionAuditor

async def test():
    with tempfile.TemporaryDirectory() as tmp:
        db_path = Path(tmp) / 'test.db'
        auditor = ActionAuditor(db_path)

        # Log with dual identity
        await auditor.log_execution_started(
            proposal_id=1,
            requester_id='user@example.com',
            agent_id='agent-123'
        )

        # Retrieve and verify
        events = await auditor.get_events(proposal_id=1)
        assert len(events) == 1
        event = events[0]
        assert event.event_data['requester_id'] == 'user@example.com'
        assert event.event_data['agent_id'] == 'agent-123'
        print('Dual identity in audit logs: PASS')

asyncio.run(test())
"`
  </verify>
  <done>Audit logs include both requester_id and agent_id for execution events.</done>
</task>

</tasks>

<verification>
1. Approval tokens are generated using secrets.token_urlsafe(32)
2. Token expiration check blocks execution after 60 seconds
3. Lock prevents concurrent execution of same proposal
4. Optimistic locking detects concurrent modifications
5. Audit logs show both requester_id and agent_id
6. TOCTOU-blocked events logged with reason
</verification>

<success_criteria>
- Approval older than 60s raises ApprovalExpiredError
- Token mismatch raises InvalidTokenError
- Concurrent modification raises StateChangedError
- Audit logs contain full identity chain
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/23-safety-enhancement/23-03-SUMMARY.md`
</output>
