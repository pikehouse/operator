---
phase: 21-agent-agentic-loop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/operator-core/src/operator_core/agent/runner.py
autonomous: true

must_haves:
  truths:
    - "Agent validates proposals after proposing"
    - "Agent executes proposals immediately after validation (when executor provided)"
    - "Agent waits 5s after action execution before verification"
    - "Agent queries subject.observe() for verification metrics"
    - "Agent logs verification result (success/failure)"
  artifacts:
    - path: "packages/operator-core/src/operator_core/agent/runner.py"
      provides: "Agentic execution with verification"
      contains: "_verify_action_result"
  key_links:
    - from: "AgentRunner._propose_actions_from_diagnosis"
      to: "executor.validate_proposal"
      via: "validate after propose"
      pattern: "await self\\.executor\\.validate_proposal"
    - from: "AgentRunner._propose_actions_from_diagnosis"
      to: "executor.execute_proposal"
      via: "execute after validate"
      pattern: "await self\\.executor\\.execute_proposal"
    - from: "AgentRunner._verify_action_result"
      to: "subject.observe"
      via: "verification metrics"
      pattern: "await self\\.subject\\.observe\\(\\)"
---

<objective>
Extend AgentRunner to complete the agentic loop: after diagnosis proposes actions, immediately validate, execute, wait, and verify.

Purpose: Close the "propose but don't execute" gap in AgentRunner. Currently actions are proposed but never executed immediately in autonomous mode.

Output: AgentRunner that validates, executes, waits 5s, queries metrics, and logs verification result.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-agent-agentic-loop/21-RESEARCH.md

@packages/operator-core/src/operator_core/agent/runner.py
@packages/operator-core/src/operator_core/actions/executor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add immediate execution after proposal in AgentRunner</name>
  <files>packages/operator-core/src/operator_core/agent/runner.py</files>
  <action>
Modify `_propose_actions_from_diagnosis` method to validate and execute proposals immediately after proposing.

Current behavior: Proposes action, logs it, returns (action never executed).
New behavior: Propose -> Validate -> Execute -> Verify (if executor provided).

Implementation:
1. After `await self.executor.propose_action(rec, ticket_id=ticket_id)`:
   - Add `await self.executor.validate_proposal(proposal.id)`
   - Log "Validated: {proposal.id}"
   - Add `record = await self.executor.execute_proposal(proposal.id, self.subject)`
   - Log success/failure of execution
   - If success, call `await self._verify_action_result(proposal.id, ticket_id)`

2. Keep existing error handling (ObserveOnlyError, ValidationError).

3. Import asyncio at top if not already imported.

Pattern from research:
```python
# After propose_action succeeds:
await self.executor.validate_proposal(proposal.id)
print(f"Validated: {proposal.id}")

record = await self.executor.execute_proposal(proposal.id, self.subject)
if record.success:
    print(f"✓ Executed: {proposal.action_name}")
    await self._verify_action_result(proposal.id, ticket_id)
else:
    print(f"✗ Execution failed: {record.error_message}")
```

Do NOT:
- Execute before validation (must validate first per research pitfall)
- Remove existing ObserveOnlyError handling (still needed)
- Change scheduled action or retry handling (those are separate flows)
  </action>
  <verify>
Read runner.py and confirm:
- `validate_proposal` called after `propose_action`
- `execute_proposal` called after validate
- Execution result checked for success/failure
- `_verify_action_result` called on success
  </verify>
  <done>
AgentRunner validates and executes proposals immediately after diagnosis (AGENT-01).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add verification method with 5s delay</name>
  <files>packages/operator-core/src/operator_core/agent/runner.py</files>
  <action>
Add `_verify_action_result` method to AgentRunner that verifies action resolved the issue.

Implementation:
1. Add new async method `_verify_action_result(self, proposal_id: int, ticket_id: int) -> None`

2. Method body (per AGENT-02, AGENT-03, AGENT-04):
   a. Wait 5 seconds: `await asyncio.sleep(5.0)`
   b. Query subject metrics: `observation = await self.subject.observe()`
   c. Log verification started
   d. Simplified verification check (for demo - checks if metrics look healthy)
   e. Log result: success ("issue resolved") or failure ("issue persists")

Pattern from research:
```python
async def _verify_action_result(
    self,
    proposal_id: int,
    ticket_id: int,
) -> None:
    """
    Verify action resolved the issue.

    Per AGENT-02/03/04: Wait 5s, query metrics, log result.
    """
    print(f"Waiting 5s for action effects to propagate...")
    await asyncio.sleep(5.0)

    # Query subject metrics (AGENT-03)
    observation = await self.subject.observe()

    # Simplified verification - check if observation indicates healthy state
    # For demo: just log that verification ran; full invariant check is future work
    cluster_health = observation.get("cluster_metrics", observation)

    # Log verification result (AGENT-04)
    print("")
    print(f"━━━ Verification for Action {proposal_id} ━━━")
    print(f"Ticket: {ticket_id}")
    print(f"Metrics observed: {len(observation)} keys")

    # For v2.2 demo: assume success if we got metrics without error
    # Full invariant re-check is out of scope per REQUIREMENTS.md
    print(f"✓ VERIFICATION COMPLETE: Action {proposal_id} executed")
    print(f"  (Full invariant re-check is future work)")
    print("")
```

3. Ensure asyncio is imported at top of file.

4. Add counter `self._actions_verified = 0` in `__init__` for stats tracking.

Do NOT:
- Implement complex invariant re-check (out of scope per requirements)
- Use subject-specific methods (use observe() for all subjects)
- Make verification delay configurable (fixed 5s per AGENT-02)
  </action>
  <verify>
Read runner.py and confirm:
- `_verify_action_result` method exists
- Method calls `asyncio.sleep(5.0)`
- Method calls `self.subject.observe()`
- Method logs verification result
  </verify>
  <done>
Agent waits 5s, queries metrics, and logs verification result (AGENT-02, AGENT-03, AGENT-04).
  </done>
</task>

</tasks>

<verification>
1. Read runner.py and verify:
   - `_propose_actions_from_diagnosis` validates then executes proposals
   - `_verify_action_result` method exists with 5s delay
   - Verification queries `subject.observe()` and logs result

2. Run existing tests to ensure no regressions:
   ```bash
   cd /Users/jrtipton/x/operator && python -m pytest packages/operator-core/tests/agent/ -v
   ```
</verification>

<success_criteria>
- AgentRunner._propose_actions_from_diagnosis calls validate_proposal then execute_proposal
- AgentRunner._verify_action_result waits 5s, calls observe(), logs result
- Existing agent tests pass
- Requirements covered: AGENT-01, AGENT-02, AGENT-03, AGENT-04
</success_criteria>

<output>
After completion, create `.planning/phases/21-agent-agentic-loop/21-01-SUMMARY.md`
</output>
