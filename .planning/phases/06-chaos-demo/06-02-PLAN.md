---
phase: 06-chaos-demo
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - packages/operator-core/src/operator_core/cli/demo.py
  - packages/operator-core/src/operator_core/cli/main.py
autonomous: false

must_haves:
  truths:
    - "User can run `operator demo chaos` to start the demo"
    - "Demo runs full cycle from healthy cluster through diagnosis"
    - "User sees detection countdown and AI reasoning output"
    - "Cluster is restored to healthy state after demo"
  artifacts:
    - path: "packages/operator-core/src/operator_core/cli/demo.py"
      provides: "Demo CLI subcommands"
      exports: ["demo_app"]
      contains: "def chaos"
    - path: "packages/operator-core/src/operator_core/cli/main.py"
      provides: "Main CLI with demo subcommand"
      contains: "demo_app"
  key_links:
    - from: "cli/demo.py"
      to: "operator_core.demo.ChaosDemo"
      via: "instantiation and run"
      pattern: "ChaosDemo"
    - from: "cli/main.py"
      to: "cli/demo.py"
      via: "add_typer"
      pattern: "demo_app"
---

<objective>
Create CLI integration for the chaos demo and verify the complete end-to-end experience.

Purpose: Users need a single command (`operator demo chaos`) to run the showcase demo. This plan wires up the CLI and includes a human verification checkpoint to confirm the demo works.

Output: Working CLI command and verified demo experience.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-chaos-demo/06-CONTEXT.md
@.planning/phases/06-chaos-demo/06-RESEARCH.md
@.planning/phases/06-chaos-demo/06-01-SUMMARY.md
@packages/operator-core/src/operator_core/cli/main.py
@packages/operator-core/src/operator_core/cli/deploy.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create demo CLI subcommand</name>
  <files>
    packages/operator-core/src/operator_core/cli/demo.py
    packages/operator-core/src/operator_core/cli/main.py
  </files>
  <action>
Create the demo CLI module following existing patterns from deploy.py and tickets.py.

**File: cli/demo.py**
```python
"""Demo CLI commands for showcasing operator capabilities.

This module provides demo commands that run polished showcase experiences:
- chaos: End-to-end chaos demo (node kill -> detect -> diagnose)

Per CONTEXT.md decisions:
- Single command invocation runs the whole cycle
- Press-enter prompts at key moments for pacing
- Colored terminal output with Rich
"""

import asyncio
from pathlib import Path

import typer
from rich.console import Console

from operator_core.demo.chaos import ChaosDemo

demo_app = typer.Typer(help="Demo commands for showcasing operator capabilities")


@demo_app.command("chaos")
def chaos(
    timeout: float = typer.Option(
        30.0, "--timeout", "-t", help="Detection timeout in seconds"
    ),
    subject: str = typer.Option(
        "tikv", "--subject", "-s", help="Subject to demo (default: tikv)"
    ),
) -> None:
    """Run end-to-end chaos demo: kill node -> detect -> diagnose.

    This demo showcases the full operator pipeline:
    1. Ensures cluster is healthy (starts if needed)
    2. Starts YCSB load for realistic traffic
    3. Kills a random TiKV store
    4. Waits for detection (with live countdown)
    5. Runs AI diagnosis
    6. Displays structured reasoning
    7. Cleans up (restarts killed container)

    Press Enter at each stage to continue.
    """
    console = Console()

    # Find compose file
    base_path = Path.cwd()
    compose_file = base_path / "subjects" / subject / "docker-compose.yaml"

    if not compose_file.exists():
        console.print(f"[red]Compose file not found: {compose_file}[/red]")
        console.print(
            f"[yellow]Run from project root or ensure subjects/{subject}/docker-compose.yaml exists[/yellow]"
        )
        raise typer.Exit(1)

    console.print()
    console.rule("[bold magenta]Operator Chaos Demo[/bold magenta]")
    console.print()
    console.print("This demo will:")
    console.print("  1. Ensure cluster is healthy")
    console.print("  2. Start YCSB load generation")
    console.print("  3. Kill a random TiKV store")
    console.print("  4. Wait for detection")
    console.print("  5. Run AI diagnosis")
    console.print("  6. Display reasoning")
    console.print("  7. Restore cluster")
    console.print()

    demo = ChaosDemo(
        console=console,
        compose_file=compose_file,
        subject=subject,
        detection_timeout=timeout,
    )

    async def _run() -> None:
        await demo.run()

    try:
        asyncio.run(_run())
    except KeyboardInterrupt:
        console.print("\n[yellow]Demo interrupted[/yellow]")
        raise typer.Exit(1)

    console.print()
    console.rule("[bold green]Demo Complete[/bold green]")
    console.print()
```

**File: cli/main.py - Add demo_app import and registration**

Add import at top:
```python
from operator_core.cli.demo import demo_app
```

Add to the command group registrations (after the existing add_typer calls):
```python
app.add_typer(demo_app, name="demo")
```
  </action>
  <verify>
1. `uv sync` succeeds
2. `operator --help` shows "demo" subcommand
3. `operator demo --help` shows "chaos" command
4. `operator demo chaos --help` shows timeout and subject options
  </verify>
  <done>
CLI command `operator demo chaos` is registered and shows proper help text.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete chaos demo: CLI command that runs end-to-end demonstration of AI diagnosis on injected fault.
  </what-built>
  <how-to-verify>
Run the full chaos demo and verify each stage works correctly.

**Prerequisites:**
- ANTHROPIC_API_KEY environment variable set
- Docker running
- At project root directory (/Users/jrtipton/x/operator)

**Steps:**

1. Start fresh cluster (optional - demo auto-starts):
```bash
cd /Users/jrtipton/x/operator
operator deploy up
```

2. Run the chaos demo:
```bash
operator demo chaos
```

3. At each prompt, press Enter to continue and verify:
   - [ ] Stage 1: Cluster health check passes (shows healthy status)
   - [ ] Stage 2: YCSB load starts (shows brief stats or confirmation)
   - [ ] Stage 3: Random TiKV killed (shows which container)
   - [ ] Stage 4: Detection countdown runs (shows "Waiting for detection... 5s...")
   - [ ] Stage 5: Detection succeeds within 30s (shows "Detected!")
   - [ ] Stage 6: AI diagnosis displays in Rich Panel with:
     - Observation summary
     - Root cause identification
     - Evidence
     - Suggested actions
   - [ ] Stage 7: Cleanup restarts killed container

4. Verify cluster recovery:
```bash
operator deploy status
```
All containers should be running and healthy.

**Expected outcome:** Demo runs smoothly with clear stage transitions, the AI correctly identifies the killed store as root cause, and the cluster is restored to healthy state.

**If timeout occurs:** Demo should warn but continue (not fail). If detection takes >30s, increase timeout with `--timeout 60`.
  </how-to-verify>
  <resume-signal>Type "approved" if demo works correctly, or describe any issues observed.</resume-signal>
</task>

</tasks>

<verification>
- [ ] `operator demo chaos` command exists
- [ ] Demo runs from project root directory
- [ ] All 7 stages complete successfully
- [ ] AI diagnosis shows structured reasoning
- [ ] Cluster is healthy after demo completes
- [ ] CHAOS-01 requirement (node kill) is satisfied
</verification>

<success_criteria>
1. CLI command `operator demo chaos` is functional
2. Demo completes full cycle: healthy -> fault -> detect -> diagnose -> restore
3. AI diagnosis correctly identifies killed store as root cause
4. Cluster returns to healthy state after demo
5. Detection occurs within 30 seconds of fault injection
</success_criteria>

<output>
After completion, create `.planning/phases/06-chaos-demo/06-02-SUMMARY.md`
</output>
