---
phase: 06-chaos-demo
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/operator-core/src/operator_core/demo/__init__.py
  - packages/operator-core/src/operator_core/demo/chaos.py
autonomous: true

must_haves:
  truths:
    - "ChaosDemo can orchestrate full demo lifecycle"
    - "Demo stages are visually distinct with Rich formatting"
    - "Random TiKV store is selected and killed"
    - "Detection countdown shows live progress"
    - "AI diagnosis is invoked and displayed"
  artifacts:
    - path: "packages/operator-core/src/operator_core/demo/__init__.py"
      provides: "Demo module exports"
      exports: ["ChaosDemo"]
    - path: "packages/operator-core/src/operator_core/demo/chaos.py"
      provides: "Chaos demo orchestration"
      min_lines: 150
      contains: "class ChaosDemo"
  key_links:
    - from: "demo/chaos.py"
      to: "operator_core.deploy.LocalDeployment"
      via: "compose file operations"
      pattern: "LocalDeployment"
    - from: "demo/chaos.py"
      to: "operator_core.db.tickets.TicketDB"
      via: "ticket queries"
      pattern: "TicketDB"
    - from: "demo/chaos.py"
      to: "rich.console.Console"
      via: "terminal output"
      pattern: "Console"
---

<objective>
Create the ChaosDemo orchestrator class that sequences the end-to-end chaos demonstration.

Purpose: This class is the core of Phase 6 - it ties together all existing components (LocalDeployment, TicketDB, TiKVSubject, AgentRunner) into a cohesive demo experience with polished Rich terminal output.

Output: A working ChaosDemo class that can be invoked to run the full demo cycle.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-chaos-demo/06-CONTEXT.md
@.planning/phases/06-chaos-demo/06-RESEARCH.md
@packages/operator-core/src/operator_core/deploy.py
@packages/operator-core/src/operator_core/cli/tickets.py
@packages/operator-core/src/operator_core/agent/runner.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create demo module with ChaosDemo class</name>
  <files>
    packages/operator-core/src/operator_core/demo/__init__.py
    packages/operator-core/src/operator_core/demo/chaos.py
  </files>
  <action>
Create the demo module with ChaosDemo orchestrator class.

**File: demo/__init__.py**
- Export ChaosDemo from chaos module

**File: demo/chaos.py**
Create a dataclass ChaosDemo with the following structure per RESEARCH.md:

```python
@dataclass
class ChaosDemo:
    """Orchestrates the chaos demo lifecycle."""

    console: Console
    compose_file: Path
    subject: str = "tikv"
    detection_timeout: float = 30.0
    db_path: Path = field(default_factory=lambda: Path.home() / ".operator" / "tickets.db")

    # Internal state
    _docker: DockerClient = field(init=False)
    _killed_container: str | None = field(init=False, default=None)

    def __post_init__(self):
        self._docker = DockerClient(compose_files=[self.compose_file])
```

**Methods to implement:**

1. `async def run(self) -> None:` - Main entry point that sequences all stages:
   - _ensure_cluster_healthy()
   - _prompt() for YCSB load
   - _start_ycsb_load()
   - _prompt() for fault injection
   - _inject_fault() - returns store container name
   - _wait_for_detection()
   - _prompt() for AI diagnosis
   - _run_diagnosis()
   - _display_diagnosis()
   - finally: _cleanup()

2. `async def _ensure_cluster_healthy(self) -> None:` - Check cluster is up, start if not, wait for healthy

3. `def _prompt(self, message: str) -> None:` - Use console.input() for press-enter prompts with yellow styling

4. `async def _start_ycsb_load(self) -> None:` - Start YCSB with load profile, brief display of stats

5. `async def _inject_fault(self) -> str:` - Random TiKV selection per RESEARCH.md:
   - Use docker.compose.ps() to get running TiKV containers
   - Filter for containers starting with "tikv" that are running
   - random.choice() to select one
   - docker.kill() with SIGKILL
   - Return the container name

6. `async def _wait_for_detection(self, killed_container: str) -> bool:` - Live countdown per RESEARCH.md Pattern 2:
   - Use Rich Live display
   - Poll every 2s for ticket creation
   - Show elapsed time: "Waiting for detection... 5s..."
   - Return True if detected, False if timeout
   - Map container name to store_id by parsing container name (tikv0 -> store address)

7. `async def _run_diagnosis(self) -> str | None:` - One-shot diagnosis:
   - Get open tickets from TicketDB
   - Find ticket for killed store
   - Create TiKVSubject with httpx clients
   - Use AgentRunner._diagnose_ticket() pattern (or invoke Claude directly)
   - Return diagnosis markdown

8. `def _display_diagnosis(self, diagnosis_md: str) -> None:` - Rich Panel with Markdown per RESEARCH.md:
   - Use Panel with Markdown content
   - Green border, "AI Diagnosis" title

9. `async def _cleanup(self) -> None:` - Restart killed container:
   - If _killed_container is set, restart it
   - Show cleanup status

10. `def _stage_banner(self, title: str, style: str = "bold blue") -> None:` - Stage separators per RESEARCH.md Pattern 3

**Key patterns from RESEARCH.md:**
- Use try/finally for cleanup
- Use console.rule() for stage banners
- Use Rich Live for detection countdown
- SIGKILL via docker.kill() (not docker.stop())
  </action>
  <verify>
1. `uv sync` succeeds
2. `python -c "from operator_core.demo import ChaosDemo; print('OK')"` succeeds
3. ChaosDemo class has all required methods (run, _inject_fault, _wait_for_detection, etc.)
  </verify>
  <done>
ChaosDemo class exists with complete demo lifecycle methods, Rich output formatting, and proper cleanup handling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement detection and diagnosis wiring</name>
  <files>
    packages/operator-core/src/operator_core/demo/chaos.py
  </files>
  <action>
Complete the detection and diagnosis integration in ChaosDemo.

**Detection Logic (_wait_for_detection):**

The challenge is mapping container name (tikv0) to store_id. Per RESEARCH.md Open Question 2, use store address which contains container hostname.

```python
async def _get_store_id_for_container(self, container_name: str) -> str | None:
    """Map container name to PD store ID by matching hostname in address."""
    # container_name is like "tikv0", store address is like "tikv0:20160"
    async with httpx.AsyncClient(base_url="http://localhost:2379") as http:
        pd = PDClient(http=http)
        stores = await pd.get_stores()
        for store in stores:
            if store.address.startswith(f"{container_name}:"):
                return store.id
    return None
```

In _wait_for_detection:
```python
store_id = await self._get_store_id_for_container(killed_container)
if store_id is None:
    self.console.print(f"[red]Could not map {killed_container} to store ID[/red]")
    return False

with Live(Text(""), console=self.console, refresh_per_second=1) as live:
    start = asyncio.get_event_loop().time()
    while True:
        elapsed = asyncio.get_event_loop().time() - start
        live.update(Text(f"Waiting for detection... {elapsed:.0f}s", style="cyan"))

        # Check for ticket
        async with TicketDB(self.db_path) as db:
            tickets = await db.list_tickets(status=TicketStatus.OPEN)
            has_ticket = any(
                t.store_id == store_id and t.invariant_name == "store_down"
                for t in tickets
            )

        if has_ticket:
            live.update(Text("Detected!", style="bold green"))
            return True

        if elapsed >= self.detection_timeout:
            live.update(Text(f"Timeout ({self.detection_timeout}s)", style="yellow"))
            return False

        await asyncio.sleep(2.0)
```

**Diagnosis Logic (_run_diagnosis):**

Per RESEARCH.md Pitfall 5, don't run full AgentRunner loop - do one-shot diagnosis:

```python
async def _run_diagnosis(self) -> str | None:
    """Run one-shot AI diagnosis on the detected ticket."""
    async with TicketDB(self.db_path) as db:
        tickets = await db.list_tickets(status=TicketStatus.OPEN)
        if not tickets:
            return None

        ticket = tickets[0]  # Get first open ticket

        # Create subject
        async with httpx.AsyncClient(base_url="http://localhost:2379") as pd_http:
            async with httpx.AsyncClient(base_url="http://localhost:9090") as prom_http:
                from operator_tikv.pd_client import PDClient
                from operator_tikv.prom_client import PrometheusClient
                from operator_tikv.subject import TiKVSubject
                from operator_core.agent.context import ContextGatherer
                from operator_core.agent.prompt import SYSTEM_PROMPT, build_diagnosis_prompt
                from operator_core.agent.diagnosis import DiagnosisOutput, format_diagnosis_markdown
                from anthropic import AsyncAnthropic

                subject = TiKVSubject(
                    pd=PDClient(http=pd_http),
                    prom=PrometheusClient(http=prom_http),
                )

                # Gather context and build prompt
                gatherer = ContextGatherer(subject, db)
                context = await gatherer.gather(ticket)
                prompt = build_diagnosis_prompt(context)

                # Invoke Claude
                client = AsyncAnthropic()
                response = await client.beta.messages.parse(
                    model="claude-sonnet-4-5",
                    max_tokens=4096,
                    betas=["structured-outputs-2025-11-13"],
                    system=SYSTEM_PROMPT,
                    messages=[{"role": "user", "content": prompt}],
                    output_format=DiagnosisOutput,
                )

                diagnosis_md = format_diagnosis_markdown(response.parsed_output)

                # Update ticket with diagnosis
                await db.update_diagnosis(ticket.id, diagnosis_md)

                return diagnosis_md
```

**Import requirements at top of chaos.py:**
```python
import asyncio
import random
from dataclasses import dataclass, field
from pathlib import Path

import httpx
from python_on_whales import DockerClient
from rich.console import Console
from rich.live import Live
from rich.markdown import Markdown
from rich.panel import Panel
from rich.text import Text

from operator_core.db.tickets import TicketDB
from operator_core.monitor.types import TicketStatus
```
  </action>
  <verify>
1. `python -c "from operator_core.demo.chaos import ChaosDemo; print(ChaosDemo.__dict__.keys())"` shows all methods
2. Method signatures are complete (no NotImplementedError or pass stubs)
  </verify>
  <done>
ChaosDemo has complete detection loop with container-to-store mapping, and one-shot diagnosis invocation with Claude API.
  </done>
</task>

</tasks>

<verification>
- [ ] demo/__init__.py exports ChaosDemo
- [ ] ChaosDemo.run() sequences all demo stages
- [ ] _inject_fault() uses random.choice() on TiKV containers
- [ ] _wait_for_detection() uses Rich Live display with countdown
- [ ] _run_diagnosis() invokes Claude with structured output
- [ ] _display_diagnosis() uses Rich Panel with Markdown
- [ ] _cleanup() restarts killed container
- [ ] All async methods use proper async patterns (no blocking calls)
</verification>

<success_criteria>
1. ChaosDemo class is importable and complete
2. All methods implemented without stubs
3. Rich formatting used consistently
4. Detection maps container name to store ID correctly
5. Claude API integration follows existing AgentRunner patterns
</success_criteria>

<output>
After completion, create `.planning/phases/06-chaos-demo/06-01-SUMMARY.md`
</output>
