---
phase: 08-subprocess-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/operator-core/src/operator_core/tui/subprocess.py
  - packages/operator-core/src/operator_core/tui/__init__.py
autonomous: true

must_haves:
  truths:
    - "SubprocessManager can spawn a Python subprocess"
    - "Subprocess stdout is captured into OutputBuffer"
    - "SubprocessManager can terminate subprocess gracefully"
  artifacts:
    - path: "packages/operator-core/src/operator_core/tui/subprocess.py"
      provides: "SubprocessManager class with spawn, read_output, terminate methods"
      min_lines: 80
      exports: ["ManagedProcess", "SubprocessManager"]
    - path: "packages/operator-core/src/operator_core/tui/__init__.py"
      provides: "Public exports for subprocess module"
      contains: "SubprocessManager"
  key_links:
    - from: "tui/subprocess.py"
      to: "tui/buffer.py"
      via: "import OutputBuffer"
      pattern: "from operator_core\\.tui\\.buffer import OutputBuffer"
    - from: "SubprocessManager.spawn"
      to: "asyncio.create_subprocess_exec"
      via: "subprocess creation"
      pattern: "asyncio\\.create_subprocess_exec"
---

<objective>
Create SubprocessManager class for spawning, capturing output from, and terminating daemon subprocesses.

Purpose: Provides the subprocess infrastructure needed for running monitor and agent daemons with live output capture, following the patterns established in 08-RESEARCH.md.

Output:
- `tui/subprocess.py` with ManagedProcess dataclass and SubprocessManager class
- Updated `tui/__init__.py` with new exports
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-subprocess-management/08-RESEARCH.md

# Existing code to integrate with
@packages/operator-core/src/operator_core/tui/buffer.py
@packages/operator-core/src/operator_core/tui/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SubprocessManager class</name>
  <files>
    packages/operator-core/src/operator_core/tui/subprocess.py
    packages/operator-core/src/operator_core/tui/__init__.py
  </files>
  <action>
Create `tui/subprocess.py` with the following components per 08-RESEARCH.md patterns:

1. **ManagedProcess dataclass:**
   - `process: asyncio.subprocess.Process`
   - `buffer: OutputBuffer`
   - `name: str`

2. **SubprocessManager class:**
   - `__init__()`: Initialize `_processes: dict[str, ManagedProcess]` and `_shutdown: asyncio.Event()`

   - `async spawn(name: str, command: list[str], buffer_size: int = 50) -> ManagedProcess`:
     - Set env with `PYTHONUNBUFFERED=1` (Pattern 1 from research)
     - Use `sys.executable` + `-m operator_core.cli.main` + command args
     - `stdout=asyncio.subprocess.PIPE`
     - `stderr=asyncio.subprocess.STDOUT` (merge stderr)
     - `start_new_session=True` (orphan prevention)
     - Create OutputBuffer, wrap in ManagedProcess, store in _processes dict

   - `async read_output(managed: ManagedProcess) -> None`:
     - Loop while not shutdown and process alive
     - Use `asyncio.wait_for(proc.stdout.readline(), timeout=0.1)` (Pattern 2)
     - On line received: `buffer.append(line.decode("utf-8", errors="replace"))`
     - Catch TimeoutError (continue), CancelledError (break cleanly)

   - `async terminate(name: str, timeout: float = 5.0) -> None`:
     - Check if already exited, return if so
     - Call `proc.terminate()` (SIGTERM)
     - `asyncio.wait_for(proc.wait(), timeout=timeout)` (Pattern 3)
     - On timeout: `proc.kill()` then `await proc.wait()` (SIGKILL)
     - Remove from _processes dict

   - `async terminate_all(timeout: float = 5.0) -> None`:
     - Set shutdown event
     - Iterate over all processes and terminate each

   - `get_buffer(name: str) -> OutputBuffer | None`:
     - Return buffer for named process, or None if not found

   - `@property shutdown -> asyncio.Event`:
     - Return shutdown event for external coordination

3. **Update `tui/__init__.py`:**
   - Add: `from operator_core.tui.subprocess import ManagedProcess, SubprocessManager`
   - Add to `__all__`: `"ManagedProcess"`, `"SubprocessManager"`

**Critical implementation notes (from research pitfalls):**
- PYTHONUNBUFFERED=1 is essential (Pitfall 1)
- readline timeout must be short (0.1s) for responsive shutdown (Pitfall 2)
- Always await proc.wait() after terminate/kill (Pitfall 3 - zombie prevention)
- start_new_session=True for clean process groups (Pitfall 4)
- Handle CancelledError in read_output for TaskGroup compatibility (Pitfall 5)
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator/packages/operator-core
# Verify file exists and has correct structure
python -c "
from operator_core.tui.subprocess import ManagedProcess, SubprocessManager
import inspect
# Check ManagedProcess is a dataclass with expected fields
assert hasattr(ManagedProcess, 'process'), 'ManagedProcess missing process field'
assert hasattr(ManagedProcess, 'buffer'), 'ManagedProcess missing buffer field'
assert hasattr(ManagedProcess, 'name'), 'ManagedProcess missing name field'
# Check SubprocessManager has required methods
sm = SubprocessManager()
assert hasattr(sm, 'spawn'), 'SubprocessManager missing spawn'
assert hasattr(sm, 'read_output'), 'SubprocessManager missing read_output'
assert hasattr(sm, 'terminate'), 'SubprocessManager missing terminate'
assert hasattr(sm, 'terminate_all'), 'SubprocessManager missing terminate_all'
assert hasattr(sm, 'get_buffer'), 'SubprocessManager missing get_buffer'
assert hasattr(sm, 'shutdown'), 'SubprocessManager missing shutdown property'
print('SubprocessManager structure verified')
"
```
  </verify>
  <done>
- subprocess.py exists with ManagedProcess dataclass and SubprocessManager class
- All 6 methods implemented (spawn, read_output, terminate, terminate_all, get_buffer, shutdown)
- __init__.py exports ManagedProcess and SubprocessManager
- Python import verification passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify subprocess spawn and output capture</name>
  <files>packages/operator-core/src/operator_core/tui/subprocess.py</files>
  <action>
Create a quick integration test that verifies SubprocessManager can spawn a simple subprocess and capture its output. This validates the core functionality before TUIController integration.

Run the following test script:

```python
import asyncio
from operator_core.tui.subprocess import SubprocessManager

async def test_spawn_and_capture():
    """Test that SubprocessManager can spawn and capture output."""
    mgr = SubprocessManager()

    # Spawn a simple echo command via Python
    # Using a one-liner that prints and exits
    proc = await mgr.spawn(
        "test",
        ["-c", "import time; print('line1'); time.sleep(0.1); print('line2')"],
        buffer_size=10,
    )

    # Start reading (will run until process exits or shutdown)
    read_task = asyncio.create_task(mgr.read_output(proc))

    # Wait for process to complete (it's a one-shot command)
    await asyncio.sleep(0.5)

    # Trigger shutdown and wait for reader to finish
    mgr.shutdown.set()
    await read_task

    # Verify output captured
    buffer = mgr.get_buffer("test")
    lines = buffer.get_lines()
    assert "line1" in lines, f"Expected 'line1' in {lines}"
    assert "line2" in lines, f"Expected 'line2' in {lines}"

    print("SUCCESS: Subprocess spawn and output capture working")

asyncio.run(test_spawn_and_capture())
```

If the test fails, diagnose and fix the issue in subprocess.py.
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator/packages/operator-core
python -c "
import asyncio
from operator_core.tui.subprocess import SubprocessManager

async def test():
    mgr = SubprocessManager()
    proc = await mgr.spawn('test', ['-c', \"import time; print('hello'); time.sleep(0.1); print('world')\"], buffer_size=10)
    read_task = asyncio.create_task(mgr.read_output(proc))
    await asyncio.sleep(0.5)
    mgr.shutdown.set()
    await read_task
    buf = mgr.get_buffer('test')
    lines = buf.get_lines()
    assert 'hello' in lines and 'world' in lines, f'Output capture failed: {lines}'
    print('Output capture verified')

asyncio.run(test())
"
```
  </verify>
  <done>
- SubprocessManager successfully spawns subprocess
- Output lines captured into OutputBuffer
- Shutdown cleanly terminates reader task
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. File exists: `packages/operator-core/src/operator_core/tui/subprocess.py`
2. Import works: `from operator_core.tui import SubprocessManager, ManagedProcess`
3. Spawn test passes: Can spawn subprocess and capture its output
4. Type hints present: All methods have proper type annotations
</verification>

<success_criteria>
- SubprocessManager class exists with all 6 methods
- ManagedProcess dataclass wraps process + buffer + name
- Output capture verified via integration test
- No orphan processes after test (verify with `ps aux | grep python`)
- Ready for TUIController integration in plan 08-02
</success_criteria>

<output>
After completion, create `.planning/phases/08-subprocess-management/08-01-SUMMARY.md`
</output>
