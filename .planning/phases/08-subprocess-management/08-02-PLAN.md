---
phase: 08-subprocess-management
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - packages/operator-core/src/operator_core/tui/controller.py
autonomous: false

must_haves:
  truths:
    - "Monitor daemon runs as subprocess (not one-shot call)"
    - "Agent daemon runs as subprocess (not one-shot call)"
    - "Subprocess stdout streams to TUI panels in real-time"
    - "Ctrl+C terminates all subprocesses cleanly (no orphans)"
    - "No zombie processes remain after TUI exit"
  artifacts:
    - path: "packages/operator-core/src/operator_core/tui/controller.py"
      provides: "TUIController with subprocess integration"
      min_lines: 120
      contains: "SubprocessManager"
  key_links:
    - from: "tui/controller.py"
      to: "tui/subprocess.py"
      via: "import and instantiate SubprocessManager"
      pattern: "from operator_core\\.tui\\.subprocess import"
    - from: "TUIController.run"
      to: "SubprocessManager.spawn"
      via: "spawn monitor and agent daemons"
      pattern: "spawn\\(['\"]monitor['\"]"
    - from: "TUIController._refresh_panels"
      to: "SubprocessManager.get_buffer"
      via: "read output for panel updates"
      pattern: "get_buffer\\(['\"]monitor['\"]\\)"
---

<objective>
Integrate SubprocessManager into TUIController to spawn monitor and agent daemons with live output streaming to TUI panels.

Purpose: Completes SUB-01, SUB-02, SUB-03 requirements by running real daemons as subprocesses and displaying their output in the TUI.

Output:
- Modified `tui/controller.py` with subprocess spawning and reader tasks
- Working TUI that displays real daemon output
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-subprocess-management/08-RESEARCH.md
@.planning/phases/08-subprocess-management/08-01-SUMMARY.md

# Files to modify
@packages/operator-core/src/operator_core/tui/controller.py

# Integration points
@packages/operator-core/src/operator_core/tui/subprocess.py
@packages/operator-core/src/operator_core/tui/layout.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate SubprocessManager into TUIController</name>
  <files>packages/operator-core/src/operator_core/tui/controller.py</files>
  <action>
Modify TUIController to spawn and manage daemon subprocesses per 08-RESEARCH.md Pattern 4.

**Changes to make:**

1. **Add imports:**
```python
from operator_core.tui.subprocess import SubprocessManager
```

2. **Update __init__:**
```python
def __init__(self, console: Console | None = None) -> None:
    self.console = console if console is not None else Console()
    self._shutdown = asyncio.Event()
    self._layout = create_layout()
    self._subprocess_mgr: SubprocessManager | None = None  # NEW
```

3. **Update run() method** following CRITICAL ORDER from research:

```python
async def run(self) -> None:
    loop = asyncio.get_running_loop()

    # 1. Register signal handlers FIRST (existing code - keep)
    for sig in (signal.SIGINT, signal.SIGTERM):
        loop.add_signal_handler(
            sig,
            functools.partial(self._handle_signal, sig),
        )

    # 2. Spawn subprocesses AFTER signal handlers, BEFORE Live (NEW)
    self._subprocess_mgr = SubprocessManager()
    monitor_proc = await self._subprocess_mgr.spawn(
        "monitor",
        ["monitor", "run", "-i", "5"],  # 5-second interval for demo
        buffer_size=50,
    )
    agent_proc = await self._subprocess_mgr.spawn(
        "agent",
        ["agent", "start", "-i", "5"],  # 5-second interval for demo
        buffer_size=50,
    )

    # 3. Initialize panels (existing - keep)
    self._init_panels()

    # 4. Enter Live context with TaskGroup for reader tasks (MODIFIED)
    with Live(
        self._layout,
        console=self.console,
        refresh_per_second=4,
        screen=False,
    ) as live:
        try:
            async with asyncio.TaskGroup() as tg:
                # Reader tasks for subprocess output
                tg.create_task(self._subprocess_mgr.read_output(monitor_proc))
                tg.create_task(self._subprocess_mgr.read_output(agent_proc))
                # Update loop
                tg.create_task(self._update_loop(live))
        except* Exception:
            pass  # TaskGroup handles cancellation

    # 5. Clean shutdown - terminate subprocesses (NEW)
    await self._subprocess_mgr.terminate_all()
    self.console.print("[green]TUI shutdown complete[/green]")
```

4. **Replace the while loop with _update_loop method:**
```python
async def _update_loop(self, live: Live) -> None:
    """Update loop that refreshes panels until shutdown."""
    while not self._shutdown.is_set():
        self._refresh_panels()
        live.refresh()
        try:
            await asyncio.wait_for(self._shutdown.wait(), timeout=0.25)
        except asyncio.TimeoutError:
            pass
```

5. **Update _handle_signal to also trigger subprocess shutdown:**
```python
def _handle_signal(self, sig: signal.Signals) -> None:
    self._shutdown.set()
    # Also signal subprocess manager to stop readers
    if self._subprocess_mgr is not None:
        self._subprocess_mgr.shutdown.set()
```

6. **Implement _refresh_panels to read from buffers:**
```python
def _refresh_panels(self) -> None:
    """Refresh panel contents from subprocess output buffers."""
    if self._subprocess_mgr is None:
        return

    # Update monitor panel
    monitor_buf = self._subprocess_mgr.get_buffer("monitor")
    if monitor_buf:
        self._layout["main"]["monitor"].update(
            make_panel(monitor_buf.get_text(n=20), "Monitor", "blue")
        )

    # Update agent panel
    agent_buf = self._subprocess_mgr.get_buffer("agent")
    if agent_buf:
        self._layout["main"]["agent"].update(
            make_panel(agent_buf.get_text(n=20), "Agent", "green")
        )
```

**Critical notes:**
- TaskGroup automatically cancels sibling tasks when one exits or raises
- except* Exception catches ExceptionGroup from TaskGroup
- Subprocess spawn MUST be after signal handlers but BEFORE Live context (Pitfall 6)
- Both subprocess manager and controller shutdown events must be set for clean exit
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator/packages/operator-core
# Verify syntax and imports
python -c "
from operator_core.tui.controller import TUIController
import inspect
src = inspect.getsource(TUIController)
# Verify key integrations
assert 'SubprocessManager' in src, 'Missing SubprocessManager integration'
assert '_subprocess_mgr' in src, 'Missing subprocess manager attribute'
assert 'spawn' in src, 'Missing spawn calls'
assert 'read_output' in src, 'Missing read_output calls'
assert 'terminate_all' in src, 'Missing terminate_all call'
assert 'TaskGroup' in src, 'Missing TaskGroup usage'
print('TUIController integration verified')
"
```
  </verify>
  <done>
- TUIController imports and instantiates SubprocessManager
- run() spawns monitor and agent subprocesses in correct order
- Reader tasks run in TaskGroup alongside update loop
- _refresh_panels reads from output buffers
- Signal handler triggers both shutdown events
- terminate_all() called on clean exit
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify TUI with live subprocess output</name>
  <what-built>
Complete TUI with real daemon subprocess output streaming:
- Monitor and agent run as actual subprocesses
- Their stdout streams to TUI panels in real-time
- Ctrl+C cleanly terminates everything
  </what-built>
  <how-to-verify>
**Prerequisites:**
1. Ensure Docker is running and TiDB Playground is up:
   ```bash
   docker ps | grep tidb  # Should see tidb containers
   ```
   If not running: `cd /Users/jrtipton/x/operator && just start`

2. Run the TUI demo:
   ```bash
   cd /Users/jrtipton/x/operator/packages/operator-core
   python -c "
import asyncio
from operator_core.tui import TUIController

async def main():
    controller = TUIController()
    await controller.run()

asyncio.run(main())
"
   ```

**Expected behavior:**

1. **TUI displays 5 panels:**
   - Cluster Status (top, cyan border)
   - Monitor (middle-left, blue border)
   - Agent (middle-right, green border)
   - Workload (bottom-left, yellow border)
   - Narration (bottom-right, magenta border)

2. **Monitor panel shows live output:**
   - Should see monitor log messages appearing
   - New lines appear as monitor runs its check loop
   - Look for lines like "Starting health check..." or similar

3. **Agent panel shows live output:**
   - Should see agent log messages appearing
   - New lines appear as agent runs its poll loop
   - Look for lines like "Agent polling..." or similar

4. **Real-time streaming (no buffering):**
   - Output should appear within 1-2 seconds of daemon producing it
   - NOT all at once when you exit

5. **Clean shutdown on Ctrl+C:**
   - Press Ctrl+C
   - TUI should exit cleanly
   - Should see "TUI shutdown complete" message
   - Terminal should NOT be corrupted

6. **No orphan processes:**
   ```bash
   ps aux | grep -E "(monitor|agent)" | grep -v grep
   ```
   Should show NO operator processes after TUI exits

7. **No zombie processes:**
   ```bash
   ps aux | grep defunct | grep -v grep
   ```
   Should show NO defunct processes
  </how-to-verify>
  <resume-signal>Type "approved" if all checks pass, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
Phase 8 requirements verification:

- [ ] **SUB-01:** Monitor and agent run as real subprocesses (verified by seeing their output)
- [ ] **SUB-02:** Stdout streams to panels in real-time (no buffering delay visible)
- [ ] **SUB-03:** Ctrl+C terminates cleanly (no orphans, no zombies, terminal restored)

From roadmap success criteria:
- [ ] Monitor daemon runs as subprocess (not one-shot call)
- [ ] Agent daemon runs as subprocess (not one-shot call)
- [ ] Subprocess stdout streams to TUI panels in real-time (no buffering delay)
- [ ] Ctrl+C terminates all subprocesses cleanly (no orphans)
- [ ] No zombie processes remain after TUI exit
</verification>

<success_criteria>
- TUI displays with all 5 panels
- Monitor panel shows real-time daemon output
- Agent panel shows real-time daemon output
- Ctrl+C exits cleanly with "TUI shutdown complete" message
- No orphan processes after exit
- No zombie processes after exit
- Terminal not corrupted after exit
</success_criteria>

<output>
After completion, create `.planning/phases/08-subprocess-management/08-02-SUMMARY.md`
</output>
