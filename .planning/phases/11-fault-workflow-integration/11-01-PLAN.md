---
phase: 11-fault-workflow-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/operator-core/src/operator_core/tui/workload.py
  - packages/operator-core/src/operator_core/tui/__init__.py
  - packages/operator-core/src/operator_core/tui/controller.py
  - packages/operator-core/src/operator_core/tui/layout.py
  - packages/operator-core/pyproject.toml
autonomous: true

must_haves:
  truths:
    - "Workload panel displays sparkline visualization of throughput"
    - "Sparkline turns red when throughput degrades below threshold"
    - "Sparkline stays green when throughput is normal"
    - "Panel shows current ops/sec numeric value"
  artifacts:
    - path: "packages/operator-core/src/operator_core/tui/workload.py"
      provides: "WorkloadTracker class with sparkline generation"
      exports: ["WorkloadTracker"]
      min_lines: 80
    - path: "packages/operator-core/src/operator_core/tui/controller.py"
      provides: "YCSB subprocess integration and workload panel updates"
      contains: "workload_tracker"
  key_links:
    - from: "controller.py"
      to: "workload.py"
      via: "WorkloadTracker import and parse_line calls"
      pattern: "WorkloadTracker|parse_line"
    - from: "controller.py"
      to: "SubprocessManager"
      via: "YCSB subprocess spawning"
      pattern: 'spawn.*ycsb'
---

<objective>
Create WorkloadTracker module and integrate YCSB subprocess for live workload visualization.

Purpose: Enable real-time throughput visualization in the workload panel with degradation detection, fulfilling requirement TUI-03.

Output: Working workload panel with sparkline visualization that responds to YCSB throughput data.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-fault-workflow-integration/11-RESEARCH.md
@.planning/phases/10-demo-flow-control/10-01-SUMMARY.md
@packages/operator-core/src/operator_core/tui/controller.py
@packages/operator-core/src/operator_core/tui/buffer.py
@packages/operator-core/src/operator_core/tui/subprocess.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WorkloadTracker module with sparkline generation</name>
  <files>
    packages/operator-core/src/operator_core/tui/workload.py
    packages/operator-core/src/operator_core/tui/__init__.py
    packages/operator-core/pyproject.toml
  </files>
  <action>
1. Add `sparklines>=0.4.2` to pyproject.toml dependencies

2. Create workload.py with WorkloadTracker class per RESEARCH.md Pattern 1:
   - YCSB_PATTERN regex: `r'(\d+\.?\d*)\s+current ops/sec'`
   - Constructor: `__init__(self, window_size: int = 30, degradation_threshold: float = 0.5)`
   - `_values: deque[float]` with maxlen=window_size
   - `_baseline: float | None` for degradation detection
   - `parse_line(line: str) -> float | None` - extract ops/sec from YCSB output
   - `update(ops_per_sec: float)` - add value, establish baseline from first 5 samples
   - `is_degraded() -> bool` - check if current < baseline * threshold
   - `get_sparkline() -> str` - generate Unicode sparkline using sparklines library
   - `format_panel() -> str` - Rich markup with sparkline, current ops, status
   - Handle edge cases: empty values, zero values (use max(0.1, value) floor)

3. Export WorkloadTracker from __init__.py

Key implementation details:
- Baseline is average of first 5 samples (warm-up period)
- Sparkline uses list(sparklines(values))[0] to get single line
- Color green when normal, red when degraded
- Return "[dim]Waiting for workload data...[/dim]" when no values
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator/packages/operator-core && python -c "
from operator_core.tui.workload import WorkloadTracker
t = WorkloadTracker()
# Test parsing
ops = t.parse_line('2026-01-25 10:30:15:123 5 sec: 50000 operations; 10000.00 current ops/sec')
assert ops == 10000.0, f'Expected 10000.0, got {ops}'
# Test update and baseline
for i in range(6):
    t.update(1000.0 + i)
assert t._baseline is not None, 'Baseline should be established'
# Test sparkline generation
spark = t.get_sparkline()
assert len(spark) > 0, 'Sparkline should not be empty'
# Test degradation detection
t.update(100.0)  # Below threshold
assert t.is_degraded(), 'Should detect degradation'
print('WorkloadTracker tests passed')
"
```
  </verify>
  <done>
WorkloadTracker class parses YCSB output, generates sparklines, detects degradation. All methods work correctly with test data.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add make_workload_panel helper to layout.py</name>
  <files>
    packages/operator-core/src/operator_core/tui/layout.py
  </files>
  <action>
Add make_workload_panel function to layout.py for degradation-aware styling:

```python
def make_workload_panel(content: str, is_degraded: bool = False) -> Panel:
    """
    Create workload panel with degradation-aware border color.

    Args:
        content: Rich markup content from WorkloadTracker.format_panel()
        is_degraded: True if throughput is degraded (changes border to red)

    Returns:
        Panel with appropriate border styling
    """
    border_style = "red" if is_degraded else "yellow"
    return Panel(
        content,
        title="[bold]Workload[/bold]",
        border_style=border_style,
        padding=(0, 1),
    )
```

Update __init__.py to export make_workload_panel if needed.
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator/packages/operator-core && python -c "
from operator_core.tui.layout import make_workload_panel
# Test normal state
panel = make_workload_panel('test content', is_degraded=False)
assert panel.border_style == 'yellow', f'Expected yellow, got {panel.border_style}'
# Test degraded state
panel = make_workload_panel('test content', is_degraded=True)
assert panel.border_style == 'red', f'Expected red, got {panel.border_style}'
print('make_workload_panel tests passed')
"
```
  </verify>
  <done>
make_workload_panel creates panels with yellow border normally, red border when degraded.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate YCSB subprocess and WorkloadTracker into TUIController</name>
  <files>
    packages/operator-core/src/operator_core/tui/controller.py
  </files>
  <action>
Modify TUIController to spawn YCSB and update workload panel:

1. Add import at top:
   ```python
   from operator_core.tui.workload import WorkloadTracker
   from operator_core.tui.layout import make_workload_panel
   ```

2. Add to __init__:
   ```python
   self._workload_tracker: WorkloadTracker | None = None
   ```

3. In run(), after spawning monitor and agent, spawn YCSB:
   ```python
   # Spawn YCSB for workload generation
   ycsb_proc = await self._subprocess_mgr.spawn(
       "ycsb",
       ["-m", "ycsb.client"],  # This runs the YCSB load generator
       buffer_size=50,
   )
   ```

   Note: YCSB may need different command. Check if there's an existing YCSB runner script.
   If YCSB is run via Docker, spawn a shell command that tails the output.

   Actually, per chaos.py, YCSB is started via docker compose. The TUI should NOT spawn YCSB - it should read output from a running YCSB container.

   REVISED APPROACH: Don't spawn YCSB as subprocess. Instead:
   - In run(), create WorkloadTracker instance
   - Use simulated workload data initially OR read from docker logs if YCSB already running
   - For demo purposes, the fault chapter will actually trigger workload changes

   For Phase 11 Plan 1, just:
   - Create WorkloadTracker instance in run()
   - In _refresh_panels(), update workload panel with tracker output
   - Workload panel shows "Waiting for workload data..." until Plan 2 connects it

4. Create WorkloadTracker in run():
   ```python
   # Create workload tracker
   self._workload_tracker = WorkloadTracker()
   ```

5. Update _refresh_panels() to update workload panel:
   ```python
   # Update workload panel
   if self._workload_tracker is not None:
       content = self._workload_tracker.format_panel()
       self._layout["main"]["workload"].update(
           make_workload_panel(content, self._workload_tracker.is_degraded())
       )
   ```

6. Add method for external workload updates (used by fault workflow in Plan 2):
   ```python
   def update_workload(self, ops_per_sec: float) -> None:
       """
       Update workload tracker with new throughput value.

       Called by fault workflow to inject workload data.

       Args:
           ops_per_sec: Current throughput value
       """
       if self._workload_tracker is not None:
           self._workload_tracker.update(ops_per_sec)
   ```
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator/packages/operator-core && python -c "
from operator_core.tui.controller import TUIController
from rich.console import Console
c = TUIController(console=Console(force_terminal=True))
# Check workload tracker is created when accessed
# Can't fully test run() without async, but check initialization works
print('TUIController imports and initializes correctly')
"
```
  </verify>
  <done>
TUIController creates WorkloadTracker, updates workload panel in refresh cycle, provides update_workload() method for external throughput injection.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. WorkloadTracker module exists and is importable:
   ```bash
   python -c "from operator_core.tui.workload import WorkloadTracker; print('OK')"
   ```

2. Dependencies installed:
   ```bash
   cd /Users/jrtipton/x/operator/packages/operator-core && pip install -e . && pip show sparklines
   ```

3. TUIController has workload integration:
   ```bash
   grep -n "workload_tracker" packages/operator-core/src/operator_core/tui/controller.py
   ```
</verification>

<success_criteria>
- WorkloadTracker class exists with parse_line, update, is_degraded, get_sparkline, format_panel methods
- sparklines library installed as dependency
- TUIController creates WorkloadTracker and updates workload panel in refresh cycle
- Workload panel shows degradation-aware styling (red border when degraded)
- update_workload() method available for external throughput injection
</success_criteria>

<output>
After completion, create `.planning/phases/11-fault-workflow-integration/11-01-SUMMARY.md`
</output>
