---
phase: 11-fault-workflow-integration
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - packages/operator-core/src/operator_core/tui/chapters.py
  - packages/operator-core/src/operator_core/tui/controller.py
  - packages/operator-core/src/operator_core/tui/fault.py
autonomous: true

must_haves:
  truths:
    - "Key press triggers countdown before fault injection"
    - "Countdown displays '3... 2... 1...' in narration panel"
    - "Node kill occurs after countdown completes"
    - "Recovery chapter restarts killed node"
    - "Workload panel shows degradation during fault (red)"
    - "Workload panel returns to green after recovery"
  artifacts:
    - path: "packages/operator-core/src/operator_core/tui/fault.py"
      provides: "Fault injection and recovery orchestration"
      exports: ["FaultWorkflow"]
      min_lines: 80
    - path: "packages/operator-core/src/operator_core/tui/chapters.py"
      provides: "Extended Chapter with on_enter callback"
      contains: "on_enter"
  key_links:
    - from: "controller.py"
      to: "fault.py"
      via: "FaultWorkflow integration"
      pattern: "FaultWorkflow|_inject_fault"
    - from: "chapters.py"
      to: "controller.py"
      via: "Chapter on_enter callbacks executed in _handle_key"
      pattern: "on_enter"
---

<objective>
Integrate fault injection workflow with countdown display and recovery into the TUI demo.

Purpose: Complete the end-to-end demo by connecting fault injection, countdown visualization, and recovery to the chapter system, fulfilling requirements DEMO-03 and DEMO-04.

Output: Working demo flow where key press triggers countdown, kills node, shows degradation, then recovers.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-fault-workflow-integration/11-RESEARCH.md
@.planning/phases/11-fault-workflow-integration/11-01-PLAN.md (for WorkloadTracker context)
@packages/operator-core/src/operator_core/tui/controller.py
@packages/operator-core/src/operator_core/tui/chapters.py
@packages/operator-core/src/operator_core/demo/chaos.py (reference for fault injection patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FaultWorkflow module for fault injection and recovery</name>
  <files>
    packages/operator-core/src/operator_core/tui/fault.py
    packages/operator-core/src/operator_core/tui/__init__.py
  </files>
  <action>
Create fault.py module with FaultWorkflow class adapted from chaos.py:

```python
"""
Fault injection and recovery workflow for TUI demo.

Provides countdown display, node kill, and recovery functionality
integrated with TUIController.

Per RESEARCH.md Pattern 4: Fault Injection Integration
- Adapted from chaos.py patterns
- Uses python-on-whales for Docker operations
- Stores killed container name for recovery
"""

import asyncio
import random
from dataclasses import dataclass, field
from pathlib import Path
from typing import Callable, Awaitable

from python_on_whales import DockerClient


@dataclass
class FaultWorkflow:
    """
    Manages fault injection and recovery lifecycle.

    Provides methods for:
    - Countdown display before fault
    - Node kill (random TiKV container)
    - Node recovery (restart killed container)

    Attributes:
        compose_file: Path to docker-compose.yaml
        on_narration_update: Callback to update narration panel
        on_workload_update: Callback to inject workload values
    """

    compose_file: Path
    on_narration_update: Callable[[str], None]
    on_workload_update: Callable[[float], None]
    shutdown_event: asyncio.Event

    _docker: DockerClient = field(init=False)
    _killed_container: str | None = field(init=False, default=None)
    _baseline_ops: float = field(init=False, default=10000.0)

    def __post_init__(self) -> None:
        """Initialize Docker client."""
        self._docker = DockerClient(compose_files=[self.compose_file])

    async def run_countdown(self, seconds: int = 3) -> bool:
        """
        Display countdown before fault injection.

        Per RESEARCH.md Pattern 2: Countdown Display with Rich Update.
        Uses asyncio.sleep with shutdown check between ticks.

        Args:
            seconds: Countdown duration (default 3)

        Returns:
            True if countdown completed, False if interrupted
        """
        for i in range(seconds, 0, -1):
            text = f"[bold yellow]Injecting fault in {i}...[/bold yellow]"
            self.on_narration_update(text)
            try:
                await asyncio.wait_for(self.shutdown_event.wait(), timeout=1.0)
                return False  # Interrupted
            except asyncio.TimeoutError:
                continue  # Normal tick

        self.on_narration_update("[bold red]FAULT INJECTED![/bold red]")
        await asyncio.sleep(0.5)
        return True

    async def inject_fault(self) -> str | None:
        """
        Kill a random TiKV container.

        Per chaos.py pattern: Uses SIGKILL for immediate termination.

        Returns:
            Name of killed container, or None if no targets
        """
        containers = self._docker.compose.ps()
        tikv_containers = [
            c
            for c in containers
            if "tikv" in c.name.lower() and c.state.running
        ]

        if not tikv_containers:
            self.on_narration_update("[red]No running TiKV containers found![/red]")
            return None

        target = random.choice(tikv_containers)
        container_name = target.name

        self._docker.kill(container_name)
        self._killed_container = container_name

        return container_name

    async def simulate_degradation(self) -> None:
        """
        Simulate workload degradation after fault.

        Injects decreasing ops/sec values to show degradation in workload panel.
        """
        # Simulate degradation: ops drop from baseline to ~20%
        for i in range(5):
            if self.shutdown_event.is_set():
                return
            degraded_ops = self._baseline_ops * (0.8 - i * 0.15)
            self.on_workload_update(max(100.0, degraded_ops))
            await asyncio.sleep(1.0)

    async def recover(self) -> bool:
        """
        Restart the killed container.

        Returns:
            True if recovery successful, False if nothing to recover
        """
        if not self._killed_container:
            return False

        # Extract service name from container name
        # Container names may have project prefix: "operator-tikv-tikv0-1" -> "tikv0"
        service_name = self._killed_container
        for part in self._killed_container.split("-"):
            if part.startswith("tikv") and len(part) > 4:
                service_name = part
                break

        self._docker.compose.start(services=[service_name])
        self._killed_container = None

        return True

    async def simulate_recovery(self) -> None:
        """
        Simulate workload recovery after node restart.

        Injects increasing ops/sec values to show recovery in workload panel.
        """
        # Simulate recovery: ops climb back to baseline
        for i in range(5):
            if self.shutdown_event.is_set():
                return
            recovering_ops = self._baseline_ops * (0.3 + i * 0.15)
            self.on_workload_update(min(self._baseline_ops, recovering_ops))
            await asyncio.sleep(1.0)

    def establish_baseline(self, ops: float) -> None:
        """Set baseline ops/sec for degradation simulation."""
        self._baseline_ops = ops
```

Export FaultWorkflow from __init__.py.
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator/packages/operator-core && python -c "
from operator_core.tui.fault import FaultWorkflow
import asyncio
from pathlib import Path
# Can't fully test without Docker, but verify import and instantiation pattern
print('FaultWorkflow imports correctly')
"
```
  </verify>
  <done>
FaultWorkflow class provides countdown, inject_fault, recover, and simulation methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend Chapter dataclass with on_enter callback</name>
  <files>
    packages/operator-core/src/operator_core/tui/chapters.py
  </files>
  <action>
Modify Chapter dataclass to support action callbacks:

1. Add callback type and fields to Chapter:
   ```python
   from typing import Callable, Awaitable

   @dataclass(frozen=True)
   class Chapter:
       """
       Immutable chapter definition with optional action callback.

       Each chapter represents a stage in the demo with narration
       explaining what is happening and what to watch for.

       Attributes:
           title: Chapter title displayed in panel
           narration: Explanatory text for the chapter
           key_hint: Keyboard hints shown at bottom
           on_enter: Optional async callback run when entering chapter
           auto_advance: If True, auto-advance after on_enter completes
           blocks_advance: If True, don't allow manual advance (action in progress)
       """

       title: str
       narration: str
       key_hint: str = "[dim]SPACE/ENTER: next | Q: quit[/dim]"
       on_enter: Callable[[], Awaitable[None]] | None = None
       auto_advance: bool = False
       blocks_advance: bool = False
   ```

2. Update DEMO_CHAPTERS to mark fault injection chapter:
   - Stage 3 (Fault Injection) should have on_enter callback (set by controller)
   - The callback itself is set dynamically by TUIController

3. Add helper to create chapters with callbacks:
   ```python
   def create_fault_chapter(on_enter: Callable[[], Awaitable[None]]) -> Chapter:
       """Create fault injection chapter with countdown callback."""
       return Chapter(
           title="Stage 3: Fault Injection",
           narration=(
               "Countdown started...\n\n"
               "Watch the CLUSTER panel - one node will turn DOWN.\n"
               "The monitor will detect this invariant violation."
           ),
           on_enter=on_enter,
           blocks_advance=True,  # Don't allow advance during countdown
       )

   def create_recovery_chapter(on_enter: Callable[[], Awaitable[None]]) -> Chapter:
       """Create recovery chapter with restart callback."""
       return Chapter(
           title="Stage 6: Recovery",
           narration=(
               "Restarting the killed node...\n\n"
               "Watch the CLUSTER panel return to all green.\n"
               "Workload should recover to normal levels."
           ),
           on_enter=on_enter,
           auto_advance=True,  # Auto-advance after recovery
       )
   ```

4. Note: Keep existing DEMO_CHAPTERS as template. TUIController will replace
   chapters 3 and add chapter 6 with callbacks at runtime.
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator/packages/operator-core && python -c "
from operator_core.tui.chapters import Chapter, create_fault_chapter
import asyncio

async def test_callback():
    print('callback executed')

chapter = create_fault_chapter(test_callback)
assert chapter.on_enter is not None, 'on_enter should be set'
assert chapter.blocks_advance == True, 'Should block advance during countdown'
print('Chapter callback extension tests passed')
"
```
  </verify>
  <done>
Chapter dataclass extended with on_enter, auto_advance, and blocks_advance fields. Helper functions for fault and recovery chapters created.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate FaultWorkflow into TUIController</name>
  <files>
    packages/operator-core/src/operator_core/tui/controller.py
  </files>
  <action>
Modify TUIController to orchestrate fault workflow:

1. Add imports:
   ```python
   from pathlib import Path
   from operator_core.tui.fault import FaultWorkflow
   from operator_core.tui.chapters import create_fault_chapter, create_recovery_chapter
   ```

2. Add to __init__:
   ```python
   self._fault_workflow: FaultWorkflow | None = None
   self._fault_task: asyncio.Task | None = None
   self._compose_file: Path = Path("subjects/tikv/docker-compose.yaml")
   ```

3. Add constructor parameter for compose file:
   ```python
   def __init__(
       self,
       console: Console | None = None,
       compose_file: Path | None = None,
   ) -> None:
       # ... existing init ...
       self._compose_file = compose_file or Path("subjects/tikv/docker-compose.yaml")
   ```

4. In run(), after creating demo_state, set up fault workflow:
   ```python
   # Create fault workflow
   self._fault_workflow = FaultWorkflow(
       compose_file=self._compose_file,
       on_narration_update=self._update_narration_text,
       on_workload_update=self.update_workload,
       shutdown_event=self._shutdown,
   )

   # Replace fault injection chapter with callback version
   self._demo_state.chapters[3] = create_fault_chapter(
       on_enter=self._run_fault_sequence
   )

   # Add recovery chapter before "Demo Complete" (insert at index 6)
   # Actually, current DEMO_CHAPTERS has 7 chapters (indices 0-6)
   # Insert recovery at index 6, pushing "Demo Complete" to 7
   recovery_chapter = create_recovery_chapter(
       on_enter=self._run_recovery_sequence
   )
   self._demo_state.chapters.insert(6, recovery_chapter)
   ```

5. Add method to update narration text directly:
   ```python
   def _update_narration_text(self, text: str) -> None:
       """Update narration panel with raw text (for countdown)."""
       self._layout["main"]["narration"].update(
           make_panel(text, "Chapter", "magenta")
       )
   ```

6. Add async methods for fault and recovery sequences:
   ```python
   async def _run_fault_sequence(self) -> None:
       """
       Run fault injection sequence: countdown -> kill -> degradation.

       Called when entering the fault injection chapter.
       """
       if self._fault_workflow is None:
           return

       # Run countdown
       completed = await self._fault_workflow.run_countdown(3)
       if not completed:
           return  # Interrupted

       # Inject fault
       container = await self._fault_workflow.inject_fault()
       if container:
           self._update_narration_text(
               f"[bold red]Killed: {container}[/bold red]\n\n"
               "Watch the monitor for detection..."
           )

       # Simulate workload degradation
       await self._fault_workflow.simulate_degradation()

   async def _run_recovery_sequence(self) -> None:
       """
       Run recovery sequence: restart node -> restore workload.

       Called when entering the recovery chapter.
       """
       if self._fault_workflow is None:
           return

       self._update_narration_text("[yellow]Restarting killed node...[/yellow]")

       # Recover node
       success = await self._fault_workflow.recover()
       if success:
           self._update_narration_text(
               "[green]Node restarted![/green]\n\n"
               "Watching workload recovery..."
           )

       # Simulate workload recovery
       await self._fault_workflow.simulate_recovery()
   ```

7. Modify _handle_key to execute on_enter callbacks:
   ```python
   def _handle_key(self, key: str) -> None:
       """Handle keypress for demo flow control."""
       if self._demo_state is None:
           return

       # Check for advance keys
       if key in (" ", "\r", "\n", "\x1b[C"):
           current = self._demo_state.get_current()

           # Don't advance if current chapter blocks it
           if current.blocks_advance and self._fault_task is not None:
               return  # Action in progress

           # Advance to next chapter
           if self._demo_state.advance():
               self._update_narration()

               # Check if new chapter has on_enter callback
               new_chapter = self._demo_state.get_current()
               if new_chapter.on_enter is not None:
                   # Schedule the callback as a task
                   self._fault_task = asyncio.create_task(
                       self._execute_chapter_callback(new_chapter)
                   )

       # ... rest of quit handling unchanged ...
   ```

8. Add helper for executing chapter callbacks:
   ```python
   async def _execute_chapter_callback(self, chapter: Chapter) -> None:
       """Execute chapter's on_enter callback."""
       if chapter.on_enter is not None:
           try:
               await chapter.on_enter()
           finally:
               self._fault_task = None

           # Auto-advance if configured
           if chapter.auto_advance and self._demo_state is not None:
               self._demo_state.advance()
               self._update_narration()
   ```

9. Seed initial workload values in run() for baseline:
   ```python
   # Seed workload tracker with baseline values
   if self._workload_tracker is not None:
       for _ in range(6):
           self._workload_tracker.update(10000.0)
       if self._fault_workflow is not None:
           self._fault_workflow.establish_baseline(10000.0)
   ```
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator/packages/operator-core && python -c "
from operator_core.tui.controller import TUIController
from rich.console import Console
from pathlib import Path

# Check controller can be created with compose_file
c = TUIController(
    console=Console(force_terminal=True),
    compose_file=Path('subjects/tikv/docker-compose.yaml'),
)
print('TUIController with fault workflow configuration OK')
"
```
  </verify>
  <done>
TUIController integrates FaultWorkflow, executes chapter callbacks, handles countdown and recovery sequences.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. FaultWorkflow module exists:
   ```bash
   python -c "from operator_core.tui.fault import FaultWorkflow; print('OK')"
   ```

2. Chapter has on_enter callback support:
   ```bash
   python -c "from operator_core.tui.chapters import Chapter; c = Chapter('t', 'n', on_enter=lambda: None); print('OK')"
   ```

3. TUIController integrates fault workflow:
   ```bash
   grep -n "fault_workflow\|FaultWorkflow" packages/operator-core/src/operator_core/tui/controller.py
   ```

4. Full module structure:
   ```bash
   ls -la packages/operator-core/src/operator_core/tui/*.py
   ```
</verification>

<success_criteria>
- FaultWorkflow class provides countdown, inject_fault, recover, and simulation methods
- Chapter dataclass supports on_enter callback, auto_advance, and blocks_advance flags
- TUIController creates FaultWorkflow and injects callbacks into chapters
- Key press on fault chapter triggers countdown sequence
- Countdown displays "3... 2... 1..." in narration panel
- Node kill occurs after countdown
- Recovery chapter restarts node
- Workload panel shows degradation (red) during fault
- Workload panel returns to normal (green) after recovery
</success_criteria>

<output>
After completion, create `.planning/phases/11-fault-workflow-integration/11-02-SUMMARY.md`
</output>
