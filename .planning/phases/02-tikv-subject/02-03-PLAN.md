---
phase: 02-tikv-subject
plan: 03
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - packages/operator-tikv/src/operator_tikv/prom_client.py
  - packages/operator-tikv/tests/test_prom_client.py
  - packages/operator-tikv/src/operator_tikv/__init__.py
autonomous: true

must_haves:
  truths:
    - "PrometheusClient.get_store_metrics() returns StoreMetrics with QPS, latency, disk, CPU"
    - "PrometheusClient handles string-to-float conversion for metric values"
    - "PrometheusClient raises on HTTP errors and query failures"
    - "PrometheusClient queries use correct TiKV metric names from RESEARCH.md"
  artifacts:
    - path: "packages/operator-tikv/src/operator_tikv/prom_client.py"
      provides: "PrometheusClient with metric query methods"
      contains: "async def get_store_metrics"
      min_lines: 80
    - path: "packages/operator-tikv/tests/test_prom_client.py"
      provides: "Tests for Prometheus client"
      contains: "def test_"
      min_lines: 50
  key_links:
    - from: "packages/operator-tikv/src/operator_tikv/prom_client.py"
      to: "httpx.AsyncClient"
      via: "injected http client"
      pattern: "http: httpx\\.AsyncClient"
    - from: "packages/operator-tikv/src/operator_tikv/prom_client.py"
      to: "operator_core.types.StoreMetrics"
      via: "returns core metrics type"
      pattern: "from operator_core\\.types import.*StoreMetrics"
---

<objective>
Implement the Prometheus metrics client using TDD for TIKV-02 requirement.

Purpose: Prometheus client provides performance metrics - QPS, latency, disk usage, CPU. These metrics feed invariant checks and AI diagnosis.

Output: Tested PrometheusClient that queries TiKV metrics and returns StoreMetrics.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-tikv-subject/02-CONTEXT.md
@.planning/phases/02-tikv-subject/02-RESEARCH.md

# Core types to return
@packages/operator-core/src/operator_core/types.py
</context>

<feature>
  <name>Prometheus Metrics Client</name>
  <files>
    packages/operator-tikv/src/operator_tikv/prom_client.py
    packages/operator-tikv/tests/test_prom_client.py
  </files>
  <behavior>
PrometheusClient receives an injected httpx.AsyncClient (with base_url set to Prometheus server).

Methods:
- `instant_query(query: str) -> list[dict]`: Execute PromQL query, return raw results
- `get_metric_value(query: str) -> float | None`: Get single value from query
- `get_store_metrics(store_address: str) -> StoreMetrics`: Aggregate metrics for a store

Metrics to query (from RESEARCH.md):
- QPS: `sum(rate(tikv_storage_command_total{instance=~"address.*"}[1m]))`
- P99 latency: `histogram_quantile(0.99, rate(tikv_grpc_msg_duration_seconds_bucket{instance=~"address.*"}[1m]))`
- Disk used: `tikv_store_size_bytes{type="used", instance=~"address.*"}`
- Disk capacity: `tikv_store_size_bytes{type="capacity", instance=~"address.*"}`
- CPU: `rate(process_cpu_seconds_total{instance=~"address.*"}[1m]) * 100`

Per CONTEXT.md decisions:
- Track P95 and P99 latency percentiles (start with P99 in StoreMetrics)
- Fixed thresholds, not baseline-relative
- Fail loudly on HTTP errors

Per RESEARCH.md Pitfall 2:
- Prometheus returns values as strings ["timestamp", "string_value"]
- Must convert to float explicitly

Test cases:
- instant_query with success response -> returns result list
- instant_query with error status -> raises ValueError
- instant_query with HTTP error -> raises httpx.HTTPStatusError
- get_metric_value with single result -> returns float
- get_metric_value with empty result -> returns None
- get_store_metrics aggregates all metrics correctly
  </behavior>
  <implementation>
Use @dataclass pattern:

```python
from dataclasses import dataclass
from typing import Any
import httpx
from operator_core.types import StoreMetrics, StoreId
from operator_tikv.types import PrometheusQueryResponse

@dataclass
class PrometheusClient:
    """Prometheus API client with injected httpx client."""

    http: httpx.AsyncClient

    async def instant_query(self, query: str) -> list[dict[str, Any]]:
        """Execute instant query at current time."""
        response = await self.http.get("/api/v1/query", params={"query": query})
        response.raise_for_status()
        data = PrometheusQueryResponse(**response.json())
        if data.status != "success":
            raise ValueError(f"Prometheus query failed: {data.status}")
        return data.data.get("result", [])

    async def get_metric_value(self, query: str) -> float | None:
        """Get single numeric value from instant query."""
        results = await self.instant_query(query)
        if not results:
            return None
        # PITFALL: Value is string, must convert
        return float(results[0]["value"][1])

    async def get_store_metrics(self, store_id: StoreId, store_address: str) -> StoreMetrics:
        """Get aggregated metrics for a store."""
        # Use regex matching for instance label flexibility (per RESEARCH.md)
        addr_pattern = store_address.replace(":", ".*")  # tikv:20160 -> tikv.*20160

        qps = await self.get_metric_value(
            f'sum(rate(tikv_storage_command_total{{instance=~"{addr_pattern}"}}[1m]))'
        ) or 0.0

        latency_seconds = await self.get_metric_value(
            f'histogram_quantile(0.99, rate(tikv_grpc_msg_duration_seconds_bucket{{instance=~"{addr_pattern}"}}[1m]))'
        ) or 0.0

        disk_used = await self.get_metric_value(
            f'tikv_store_size_bytes{{type="used", instance=~"{addr_pattern}"}}'
        ) or 0

        disk_capacity = await self.get_metric_value(
            f'tikv_store_size_bytes{{type="capacity", instance=~"{addr_pattern}"}}'
        ) or 1  # Avoid division by zero

        cpu_rate = await self.get_metric_value(
            f'rate(process_cpu_seconds_total{{instance=~"{addr_pattern}"}}[1m])'
        ) or 0.0

        return StoreMetrics(
            store_id=store_id,
            qps=qps,
            latency_p99_ms=latency_seconds * 1000,  # Convert to ms
            disk_used_bytes=int(disk_used),
            disk_total_bytes=int(disk_capacity),
            cpu_percent=cpu_rate * 100,
            raft_lag=0  # Raft-specific metrics deferred per CONTEXT.md
        )
```

For tests, mock the HTTP responses with sample Prometheus JSON.
  </implementation>
</feature>

<verification>
TDD cycle verification:
1. RED: Tests written and failing (no implementation)
2. GREEN: Minimal implementation makes tests pass
3. REFACTOR: Clean up if needed, tests still pass

Final verification:
```bash
cd /Users/jrtipton/x/operator
uv run pytest packages/operator-tikv/tests/test_prom_client.py -v
```
</verification>

<success_criteria>
- All test cases pass
- PrometheusClient converts string values to floats (Pitfall 2)
- PrometheusClient uses correct TiKV metric names
- PrometheusClient returns StoreMetrics with all fields populated
- PrometheusClient raises on errors (no silent failures)
- Client exported from package __init__.py
</success_criteria>

<output>
After completion, create `.planning/phases/02-tikv-subject/02-03-SUMMARY.md`
</output>
