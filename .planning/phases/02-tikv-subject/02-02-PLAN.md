---
phase: 02-tikv-subject
plan: 02
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - packages/operator-tikv/src/operator_tikv/pd_client.py
  - packages/operator-tikv/tests/test_pd_client.py
  - packages/operator-tikv/src/operator_tikv/__init__.py
autonomous: true

must_haves:
  truths:
    - "PDClient.get_stores() returns list[Store] from PD API response"
    - "PDClient.get_regions() returns list[Region] from PD API response"
    - "PDClient.get_region(id) returns single Region"
    - "PDClient raises on HTTP errors (fail loudly per CONTEXT.md)"
  artifacts:
    - path: "packages/operator-tikv/src/operator_tikv/pd_client.py"
      provides: "PDClient dataclass with async methods"
      contains: "async def get_stores"
      min_lines: 50
    - path: "packages/operator-tikv/tests/test_pd_client.py"
      provides: "Tests for PD client methods"
      contains: "def test_"
      min_lines: 40
  key_links:
    - from: "packages/operator-tikv/src/operator_tikv/pd_client.py"
      to: "httpx.AsyncClient"
      via: "injected http client"
      pattern: "http: httpx\\.AsyncClient"
    - from: "packages/operator-tikv/src/operator_tikv/pd_client.py"
      to: "operator_core.types"
      via: "returns core types"
      pattern: "from operator_core\\.types import"
---

<objective>
Implement the PD API client using TDD for TIKV-01 requirement.

Purpose: PD client provides cluster state observation - stores, regions, topology. This is the foundation for the TiKV Subject's observation methods.

Output: Tested PDClient that converts PD API responses to operator-core types.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-tikv-subject/02-CONTEXT.md
@.planning/phases/02-tikv-subject/02-RESEARCH.md

# Types from Plan 01 (will exist after Plan 01 executes)
# @packages/operator-tikv/src/operator_tikv/types.py

# Core types to return
@packages/operator-core/src/operator_core/types.py
</context>

<feature>
  <name>PD API Client</name>
  <files>
    packages/operator-tikv/src/operator_tikv/pd_client.py
    packages/operator-tikv/tests/test_pd_client.py
  </files>
  <behavior>
PDClient receives an injected httpx.AsyncClient (with base_url set to PD server).

Methods:
- `get_stores() -> list[Store]`: GET /pd/api/v1/stores, parse response, return core Store types
- `get_regions() -> list[Region]`: GET /pd/api/v1/regions, parse response, return core Region types
- `get_region(region_id: int) -> Region`: GET /pd/api/v1/region/id/{id}, parse response, return Region

Behavior per CONTEXT.md:
- Fail loudly on HTTP errors (raise_for_status)
- Fail loudly on unexpected data (Pydantic validation errors propagate)
- Convert PD store IDs (int) to StoreId (str) per RESEARCH.md Pitfall 3

Test cases:
- get_stores with mock response -> returns list[Store] with correct fields
- get_stores with empty stores -> returns empty list
- get_stores with HTTP error -> raises httpx.HTTPStatusError
- get_regions with mock response -> returns list[Region] with leader and peers
- get_region with mock response -> returns single Region
  </behavior>
  <implementation>
Use @dataclass pattern from RESEARCH.md Pattern 1:

```python
from dataclasses import dataclass
import httpx
from operator_core.types import Store, Region, StoreId, RegionId
from operator_tikv.types import PDStoresResponse, PDRegionResponse, PDRegionsResponse

@dataclass
class PDClient:
    """PD API client with injected httpx client."""

    http: httpx.AsyncClient

    async def get_stores(self) -> list[Store]:
        response = await self.http.get("/pd/api/v1/stores")
        response.raise_for_status()
        data = PDStoresResponse(**response.json())
        return [
            Store(
                id=str(item.store.id),  # Convert int to str per pitfall
                address=item.store.address,
                state=item.store.state_name
            )
            for item in data.stores
        ]

    async def get_regions(self) -> list[Region]:
        response = await self.http.get("/pd/api/v1/regions")
        response.raise_for_status()
        data = PDRegionsResponse(**response.json())
        return [self._region_from_pd(r) for r in data.regions]

    async def get_region(self, region_id: RegionId) -> Region:
        response = await self.http.get(f"/pd/api/v1/region/id/{region_id}")
        response.raise_for_status()
        data = PDRegionResponse(**response.json())
        return self._region_from_pd(data)

    def _region_from_pd(self, pd_region: PDRegionResponse) -> Region:
        leader_id = str(pd_region.leader.store_id) if pd_region.leader else ""
        peer_ids = [str(p.store_id) for p in pd_region.peers]
        return Region(
            id=pd_region.id,
            leader_store_id=leader_id,
            peer_store_ids=peer_ids
        )
```

For tests, use pytest with httpx MockTransport or respx library for mocking HTTP responses.
  </implementation>
</feature>

<verification>
TDD cycle verification:
1. RED: Tests written and failing (no implementation)
2. GREEN: Minimal implementation makes tests pass
3. REFACTOR: Clean up if needed, tests still pass

Final verification:
```bash
cd /Users/jrtipton/x/operator
uv run pytest packages/operator-tikv/tests/test_pd_client.py -v
```
</verification>

<success_criteria>
- All test cases pass
- PDClient converts PD API int IDs to string StoreIds
- PDClient raises on HTTP errors (no silent failures)
- PDClient uses Pydantic types for response parsing
- Client is exported from package __init__.py
</success_criteria>

<output>
After completion, create `.planning/phases/02-tikv-subject/02-02-SUMMARY.md`
</output>
