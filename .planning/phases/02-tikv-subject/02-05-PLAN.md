---
phase: 02-tikv-subject
plan: 05
type: execute
wave: 3
depends_on: ["02-02", "02-03", "02-04"]
files_modified:
  - packages/operator-tikv/src/operator_tikv/invariants.py
  - packages/operator-tikv/src/operator_tikv/subject.py
  - packages/operator-tikv/src/operator_tikv/__init__.py
  - packages/operator-tikv/tests/test_invariants.py
autonomous: true

must_haves:
  truths:
    - "TiKV invariants detect store down, high latency, low disk space"
    - "Invariants have configurable grace periods per CONTEXT.md"
    - "TiKVSubject implements the Subject Protocol from operator-core"
    - "TiKVSubject observation methods use PDClient and PrometheusClient"
  artifacts:
    - path: "packages/operator-tikv/src/operator_tikv/invariants.py"
      provides: "Invariant definitions for TiKV health checks"
      contains: "class TiKVInvariants"
      min_lines: 80
    - path: "packages/operator-tikv/src/operator_tikv/subject.py"
      provides: "TiKVSubject implementing Subject Protocol"
      contains: "class TiKVSubject"
      min_lines: 100
    - path: "packages/operator-tikv/tests/test_invariants.py"
      provides: "Tests for invariant evaluation"
      contains: "def test_"
      min_lines: 40
  key_links:
    - from: "packages/operator-tikv/src/operator_tikv/subject.py"
      to: "operator_core.subject.Subject"
      via: "Protocol implementation"
      pattern: "class TiKVSubject"
    - from: "packages/operator-tikv/src/operator_tikv/subject.py"
      to: "packages/operator-tikv/src/operator_tikv/pd_client.py"
      via: "composition"
      pattern: "pd_client: PDClient"
    - from: "packages/operator-tikv/src/operator_tikv/invariants.py"
      to: "packages/operator-tikv/src/operator_tikv/pd_client.py"
      via: "invariant checks query clients"
      pattern: "PDClient|PrometheusClient"
---

<objective>
Implement TiKV invariants and TiKVSubject that wires everything together.

Purpose: This is the integration plan that completes the TiKV Subject - invariants define health checks (TIKV-03), and TiKVSubject implements the Subject Protocol using all the clients built in prior plans.

Output: Complete TiKV Subject implementation with health invariants.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-tikv-subject/02-CONTEXT.md
@.planning/phases/02-tikv-subject/02-RESEARCH.md

# Core interfaces to implement
@packages/operator-core/src/operator_core/subject.py
@packages/operator-core/src/operator_core/types.py
@packages/operator-core/src/operator_core/config.py

# Will reference SUMMARYs from Wave 2 plans for client APIs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TiKV invariants module</name>
  <files>
    packages/operator-tikv/src/operator_tikv/invariants.py
    packages/operator-tikv/tests/test_invariants.py
  </files>
  <action>
Create invariant definitions for TIKV-03 requirement per CONTEXT.md decisions:

1. Create `packages/operator-tikv/src/operator_tikv/invariants.py`:

**Invariant dataclass** (from RESEARCH.md Pattern 4):
```python
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Callable, Awaitable

@dataclass
class InvariantViolation:
    """A detected invariant violation."""
    invariant_name: str
    message: str
    first_seen: datetime
    last_seen: datetime
    store_id: str | None = None
    severity: str = "warning"  # "critical", "warning", "info"

@dataclass
class Invariant:
    """An invariant check with grace period support."""
    name: str
    check: Callable[[], Awaitable[str | None]]  # Returns violation message or None
    grace_period: timedelta = field(default_factory=lambda: timedelta(seconds=0))
    severity: str = "warning"

    # Track active violations for grace period logic
    _active_violations: dict[str, datetime] = field(default_factory=dict, repr=False)

    async def evaluate(self) -> InvariantViolation | None:
        """Check invariant, respecting grace period."""
        # Implementation from RESEARCH.md Pattern 4
```

**TiKVInvariants class** - creates invariant checks using clients:
```python
@dataclass
class TiKVInvariants:
    """Factory for TiKV-specific invariant checks."""

    pd_client: PDClient
    prom_client: PrometheusClient

    # Thresholds per CONTEXT.md (fixed, not baseline-relative)
    latency_threshold_ms: float = 100.0  # P99 latency
    disk_threshold_percent: float = 70.0  # Conservative
    cpu_threshold_percent: float = 70.0

    def create_store_down_invariant(self) -> Invariant:
        """Invariant: All stores should be Up."""
        async def check() -> str | None:
            stores = await self.pd_client.get_stores()
            down_stores = [s for s in stores if s.state != "Up"]
            if down_stores:
                ids = ", ".join(s.id for s in down_stores)
                return f"Stores down: {ids}"
            return None

        return Invariant(
            name="store_health",
            check=check,
            grace_period=timedelta(seconds=0),  # Immediate for node down
            severity="critical"
        )

    def create_latency_invariant(self, store_id: str, store_address: str) -> Invariant:
        """Invariant: Store latency should be below threshold."""
        async def check() -> str | None:
            metrics = await self.prom_client.get_store_metrics(store_id, store_address)
            if metrics.latency_p99_ms > self.latency_threshold_ms:
                return f"Store {store_id} P99 latency {metrics.latency_p99_ms:.1f}ms > {self.latency_threshold_ms}ms"
            return None

        return Invariant(
            name=f"latency_{store_id}",
            check=check,
            grace_period=timedelta(seconds=60),  # Sustained violation needed
            severity="warning"
        )

    def create_disk_invariant(self, store_id: str, store_address: str) -> Invariant:
        """Invariant: Store disk usage should be below threshold."""
        async def check() -> str | None:
            metrics = await self.prom_client.get_store_metrics(store_id, store_address)
            if metrics.disk_total_bytes == 0:
                return None
            used_percent = (metrics.disk_used_bytes / metrics.disk_total_bytes) * 100
            if used_percent > self.disk_threshold_percent:
                return f"Store {store_id} disk {used_percent:.1f}% > {self.disk_threshold_percent}%"
            return None

        return Invariant(
            name=f"disk_{store_id}",
            check=check,
            grace_period=timedelta(seconds=300),  # Disk issues need time to develop
            severity="warning"
        )

    def get_all_invariants(self, stores: list[Store]) -> list[Invariant]:
        """Create all invariants for current cluster state."""
        invariants = [self.create_store_down_invariant()]
        for store in stores:
            if store.state == "Up":
                invariants.append(self.create_latency_invariant(store.id, store.address))
                invariants.append(self.create_disk_invariant(store.id, store.address))
        return invariants
```

2. Create `packages/operator-tikv/tests/test_invariants.py`:
- Test Invariant grace period logic
- Test InvariantViolation creation
- Test TiKVInvariants.create_store_down_invariant with mocked PDClient
- Test threshold comparisons
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator
uv run pytest packages/operator-tikv/tests/test_invariants.py -v
```
  </verify>
  <done>TiKV invariants detect store down, high latency, low disk with configurable grace periods and severities</done>
</task>

<task type="auto">
  <name>Task 2: Create TiKVSubject implementation</name>
  <files>
    packages/operator-tikv/src/operator_tikv/subject.py
    packages/operator-tikv/src/operator_tikv/__init__.py
  </files>
  <action>
Create the TiKVSubject class that implements the Subject Protocol:

1. Create `packages/operator-tikv/src/operator_tikv/subject.py`:

```python
"""TiKV Subject implementation."""
from dataclasses import dataclass
import httpx
from python_on_whales import DockerClient
from datetime import timedelta

from operator_core.types import Store, Region, StoreMetrics, ClusterMetrics, StoreId, RegionId
from operator_core.config import SubjectConfig, Action, Observation, SLO

from operator_tikv.pd_client import PDClient
from operator_tikv.prom_client import PrometheusClient
from operator_tikv.log_parser import extract_leadership_changes, LeadershipChange
from operator_tikv.invariants import TiKVInvariants, Invariant, InvariantViolation

@dataclass
class TiKVSubject:
    """
    TiKV Subject implementation.

    Implements the Subject Protocol for TiKV clusters. Receives injected
    HTTP clients for PD and Prometheus, and a Docker client for log access.

    This class satisfies the Subject Protocol through structural subtyping -
    it implements all required methods without explicit inheritance.
    """

    pd_client: PDClient
    prom_client: PrometheusClient
    docker: DockerClient | None = None  # Optional for log access
    tikv_container_prefix: str = "tikv"  # Container naming convention

    # -------------------------------------------------------------------------
    # Observations - Read-only queries (implements Subject Protocol)
    # -------------------------------------------------------------------------

    async def get_stores(self) -> list[Store]:
        """Get all stores in the cluster."""
        return await self.pd_client.get_stores()

    async def get_hot_write_regions(self) -> list[Region]:
        """Get regions with high write traffic."""
        # For Phase 2, return all regions - hot region detection deferred
        return await self.pd_client.get_regions()

    async def get_store_metrics(self, store_id: StoreId) -> StoreMetrics:
        """Get performance metrics for a specific store."""
        stores = await self.pd_client.get_stores()
        store = next((s for s in stores if s.id == store_id), None)
        if store is None:
            raise ValueError(f"Store {store_id} not found")
        return await self.prom_client.get_store_metrics(store_id, store.address)

    async def get_cluster_metrics(self) -> ClusterMetrics:
        """Get cluster-wide aggregated metrics."""
        stores = await self.pd_client.get_stores()
        regions = await self.pd_client.get_regions()

        # Count leaders per store
        leader_count: dict[StoreId, int] = {s.id: 0 for s in stores}
        for region in regions:
            if region.leader_store_id in leader_count:
                leader_count[region.leader_store_id] += 1

        return ClusterMetrics(
            store_count=len(stores),
            region_count=len(regions),
            leader_count=leader_count
        )

    # -------------------------------------------------------------------------
    # Actions - Operations that modify system state (implements Subject Protocol)
    # -------------------------------------------------------------------------

    async def transfer_leader(self, region_id: RegionId, to_store_id: StoreId) -> None:
        """Transfer region leadership to another store."""
        # PD API: POST /pd/api/v1/operators with transfer-leader
        # For Phase 2, log intent - actual PD operator API in later phase
        raise NotImplementedError("Leader transfer action deferred to Phase 5")

    async def split_region(self, region_id: RegionId) -> None:
        """Split a region into two smaller regions."""
        raise NotImplementedError("Region split action deferred to Phase 5")

    async def set_leader_schedule_limit(self, n: int) -> None:
        """Set the maximum number of leader transfers per scheduling cycle."""
        raise NotImplementedError("Schedule limit action deferred to Phase 5")

    async def set_replica_schedule_limit(self, n: int) -> None:
        """Set the maximum number of replica moves per scheduling cycle."""
        raise NotImplementedError("Schedule limit action deferred to Phase 5")

    async def drain_store(self, store_id: StoreId) -> None:
        """Evacuate all regions from a store."""
        raise NotImplementedError("Drain store action deferred to Phase 5")

    async def set_low_space_threshold(self, percent: float) -> None:
        """Set the low disk space threshold percentage."""
        raise NotImplementedError("Config action deferred to Phase 5")

    async def set_region_schedule_limit(self, n: int) -> None:
        """Set the maximum number of region moves per scheduling cycle."""
        raise NotImplementedError("Config action deferred to Phase 5")

    # -------------------------------------------------------------------------
    # TiKV-specific methods (not part of Subject Protocol)
    # -------------------------------------------------------------------------

    def get_invariants(self, stores: list[Store] | None = None) -> TiKVInvariants:
        """Get invariants factory for this subject."""
        return TiKVInvariants(
            pd_client=self.pd_client,
            prom_client=self.prom_client
        )

    def get_recent_leadership_changes(self, container_name: str, minutes: int = 30) -> list[LeadershipChange]:
        """Get recent leadership change events from container logs."""
        if self.docker is None:
            return []

        from datetime import datetime, timedelta
        since = datetime.now() - timedelta(minutes=minutes)

        try:
            logs = self.docker.container.logs(container_name, since=since, timestamps=True)
            lines = logs.split('\n') if logs else []
            return extract_leadership_changes(lines)
        except Exception:
            # Log access failures are non-fatal per CONTEXT.md
            return []

    @staticmethod
    def get_config() -> SubjectConfig:
        """Get TiKV subject configuration for capability discovery."""
        return SubjectConfig(
            name="tikv",
            actions=[
                Action("transfer_leader", ["region_id", "to_store_id"],
                       description="Move region leadership to another store"),
                Action("split_region", ["region_id"],
                       description="Split a hot region into two"),
                Action("drain_store", ["store_id"],
                       description="Evacuate all regions from a store"),
            ],
            observations=[
                Observation("get_stores", "list[Store]",
                           description="List all TiKV nodes"),
                Observation("get_hot_write_regions", "list[Region]",
                           description="Find regions with high write traffic"),
                Observation("get_store_metrics", "StoreMetrics",
                           description="Get metrics for a specific store"),
                Observation("get_cluster_metrics", "ClusterMetrics",
                           description="Get cluster-wide metrics"),
            ],
            slos=[
                SLO("write_latency_p99", target=100, unit="ms", grace_period_s=60,
                    description="99th percentile write latency threshold"),
                SLO("disk_usage", target=70, unit="percent", grace_period_s=300,
                    description="Disk usage threshold per store"),
                SLO("store_health", target=0, unit="count", grace_period_s=0,
                    description="Number of down stores (should be 0)"),
            ],
        )
```

2. Update `packages/operator-tikv/src/operator_tikv/__init__.py`:
Export all public types and classes:
- TiKVSubject
- PDClient, PrometheusClient
- TiKVInvariants, Invariant, InvariantViolation
- LogEntry, LeadershipChange, parse_log_line, extract_leadership_changes
- All Pydantic response types

3. Verify TiKVSubject satisfies Subject Protocol via isinstance check:
```python
from operator_core.subject import Subject
from operator_tikv import TiKVSubject
# TiKVSubject should pass isinstance check due to @runtime_checkable
```
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator
uv run python -c "
from operator_core.subject import Subject
from operator_tikv import TiKVSubject, PDClient, PrometheusClient
import httpx

# Verify Protocol satisfaction (structural subtyping)
# Note: Can't do isinstance without instance, but type checker validates
print('TiKVSubject imports successfully')
print('Config:', TiKVSubject.get_config().name)
print('Observations:', [o.name for o in TiKVSubject.get_config().observations])
print('All exports verified')
"
```
  </verify>
  <done>TiKVSubject implements Subject Protocol with observations, invariants, and log access; actions raise NotImplementedError (deferred to Phase 5)</done>
</task>

<task type="auto">
  <name>Task 3: Add pytest configuration and run full test suite</name>
  <files>
    packages/operator-tikv/pyproject.toml
  </files>
  <action>
1. Update `packages/operator-tikv/pyproject.toml` to add pytest as dev dependency:

```toml
[project.optional-dependencies]
dev = [
    "pytest>=8.0.0",
    "pytest-asyncio>=0.23.0",
]
```

2. Create `packages/operator-tikv/tests/__init__.py` (empty file for test package)

3. Create `packages/operator-tikv/tests/conftest.py` with pytest-asyncio mode:
```python
import pytest

pytest_plugins = ["pytest_asyncio"]

# Configure pytest-asyncio to use auto mode
def pytest_configure(config):
    config.addinivalue_line("markers", "asyncio: mark test as async")
```

4. Run the complete test suite for operator-tikv:
```bash
uv sync
uv run pytest packages/operator-tikv/tests/ -v
```

Ensure all tests from Plans 02, 03, 04 and Task 1 pass.
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator
uv sync
uv run pytest packages/operator-tikv/tests/ -v --tb=short
```
All tests should pass.
  </verify>
  <done>Complete test suite passes for operator-tikv package</done>
</task>

</tasks>

<verification>
After all tasks:
1. `uv run pytest packages/operator-tikv/tests/ -v` - all tests pass
2. `uv run python -c "from operator_tikv import TiKVSubject"` - imports work
3. TiKVSubject.get_config() returns valid SubjectConfig
4. Invariants can be created and evaluated (with mocked clients in tests)
</verification>

<success_criteria>
- TiKVSubject implements all Subject Protocol observation methods
- TiKVSubject action methods raise NotImplementedError (Phase 5 work)
- TiKVInvariants creates invariants for store health, latency, disk
- Invariants have configurable grace periods and severities
- All tests pass
- Package exports all public types
</success_criteria>

<output>
After completion, create `.planning/phases/02-tikv-subject/02-05-SUMMARY.md`
</output>
