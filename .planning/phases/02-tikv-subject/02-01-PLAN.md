---
phase: 02-tikv-subject
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/operator-tikv/pyproject.toml
  - packages/operator-tikv/src/operator_tikv/__init__.py
  - packages/operator-tikv/src/operator_tikv/types.py
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - "operator-tikv package is importable via uv run python -c 'import operator_tikv'"
    - "TiKV response types exist for PD API and Prometheus responses"
    - "Package depends on operator-core and inherits its httpx/pydantic dependencies"
  artifacts:
    - path: "packages/operator-tikv/pyproject.toml"
      provides: "Package configuration with operator-core dependency"
      contains: "operator-core"
    - path: "packages/operator-tikv/src/operator_tikv/__init__.py"
      provides: "Package entry point with exports"
    - path: "packages/operator-tikv/src/operator_tikv/types.py"
      provides: "PDStoreResponse, PDRegionResponse, PrometheusQueryResponse types"
      min_lines: 50
  key_links:
    - from: "packages/operator-tikv/pyproject.toml"
      to: "packages/operator-core"
      via: "workspace dependency"
      pattern: "operator-core"
    - from: "pyproject.toml"
      to: "packages/operator-tikv"
      via: "workspace members glob"
      pattern: "packages/\\*"
---

<objective>
Create the operator-tikv package structure with TiKV-specific Pydantic response types.

Purpose: Foundation for TiKV subject implementation - establishes the package and types that clients will use to parse API responses.

Output: Working operator-tikv package with types for PD API and Prometheus response parsing.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-tikv-subject/02-CONTEXT.md
@.planning/phases/02-tikv-subject/02-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md

# Existing types to reference
@packages/operator-core/src/operator_core/types.py
@packages/operator-core/pyproject.toml
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create operator-tikv package structure</name>
  <files>
    packages/operator-tikv/pyproject.toml
    packages/operator-tikv/src/operator_tikv/__init__.py
  </files>
  <action>
Create the operator-tikv package following the same structure as operator-core:

1. Create `packages/operator-tikv/pyproject.toml`:
   - name: "operator-tikv"
   - version: "0.1.0"
   - description: "TiKV subject implementation for the AI-powered operator"
   - requires-python: ">=3.11"
   - dependencies: ["operator-core"] (workspace dependency provides httpx, pydantic)
   - build-system: hatchling (same as operator-core)
   - [tool.hatch.build.targets.wheel] packages = ["src/operator_tikv"]

2. Create `packages/operator-tikv/src/operator_tikv/__init__.py`:
   - Empty initially, will add exports as modules are created
   - Add module docstring explaining this is the TiKV subject package

3. Update root `pyproject.toml`:
   - Add "operator-tikv" to dependencies list
   - Add operator-tikv workspace source: `operator-tikv = { workspace = true }`

The workspace glob `packages/*` already includes operator-tikv, so no uv.workspace change needed.

Run `uv sync` after to verify workspace recognizes the new package.
  </action>
  <verify>
```bash
uv sync
uv run python -c "import operator_tikv; print('operator-tikv package imports successfully')"
```
  </verify>
  <done>operator-tikv package exists and is importable from the workspace</done>
</task>

<task type="auto">
  <name>Task 2: Create TiKV response types</name>
  <files>
    packages/operator-tikv/src/operator_tikv/types.py
    packages/operator-tikv/src/operator_tikv/__init__.py
  </files>
  <action>
Create Pydantic models for parsing PD API and Prometheus responses per RESEARCH.md pitfalls:

1. Create `packages/operator-tikv/src/operator_tikv/types.py`:

**PD API Response Types** (based on RESEARCH.md code examples):

```python
# PD returns nested structures - need to handle carefully
# Store response: {"stores": [{"store": {...}, "status": {...}}]}

class PDStoreInfo(BaseModel):
    """Inner store info from PD API."""
    id: int
    address: str
    state_name: str  # "Up", "Down", "Offline", "Tombstone"
    version: str = ""

class PDStoreStatus(BaseModel):
    """Store status metrics from PD API."""
    capacity: str = ""  # e.g., "100GiB"
    available: str = ""
    leader_count: int = 0
    region_count: int = 0

class PDStoreItem(BaseModel):
    """Single store entry from PD /stores endpoint."""
    store: PDStoreInfo
    status: PDStoreStatus | None = None

class PDStoresResponse(BaseModel):
    """Response from GET /pd/api/v1/stores."""
    count: int
    stores: list[PDStoreItem]

class PDRegionPeer(BaseModel):
    """Region peer info."""
    id: int
    store_id: int

class PDRegionLeader(BaseModel):
    """Region leader info."""
    id: int
    store_id: int

class PDRegionResponse(BaseModel):
    """Response from GET /pd/api/v1/region/id/{id}."""
    id: int
    leader: PDRegionLeader | None = None
    peers: list[PDRegionPeer] = []

class PDRegionsResponse(BaseModel):
    """Response from GET /pd/api/v1/regions."""
    count: int
    regions: list[PDRegionResponse]
```

**Prometheus Response Types** (note: values are strings per RESEARCH.md Pitfall 2):

```python
class PrometheusMetric(BaseModel):
    """Metric labels from Prometheus result."""
    model_config = ConfigDict(extra="allow")  # Allow arbitrary labels
    __name__: str = Field(default="", alias="__name__")
    instance: str = ""
    job: str = ""

class PrometheusVectorResult(BaseModel):
    """Single result from instant vector query."""
    metric: dict[str, str]  # Labels as dict for flexibility
    value: tuple[float, str]  # [timestamp, "string_value"]

class PrometheusQueryResponse(BaseModel):
    """Response from GET /api/v1/query."""
    status: str  # "success" or "error"
    data: dict  # Contains "resultType" and "result"

    def get_results(self) -> list[PrometheusVectorResult]:
        """Extract results, handling the nested structure."""
        if self.status != "success":
            return []
        result_list = self.data.get("result", [])
        return [PrometheusVectorResult(**r) for r in result_list]

    def get_single_value(self) -> float | None:
        """Get single numeric value from query result."""
        results = self.get_results()
        if not results:
            return None
        # PITFALL: Prometheus returns string values, must convert
        return float(results[0].value[1])
```

2. Export types from `__init__.py`:
   - All PD* types
   - All Prometheus* types

Use `from pydantic import BaseModel, ConfigDict, Field` for models.
  </action>
  <verify>
```bash
uv run python -c "
from operator_tikv.types import (
    PDStoresResponse, PDStoreItem, PDStoreInfo, PDStoreStatus,
    PDRegionResponse, PDRegionsResponse, PDRegionPeer, PDRegionLeader,
    PrometheusQueryResponse, PrometheusVectorResult
)
print('All types import successfully')

# Quick validation test
import json
stores_json = {'count': 1, 'stores': [{'store': {'id': 1, 'address': 'tikv:20160', 'state_name': 'Up', 'version': '8.1.0'}, 'status': {'capacity': '100GiB', 'available': '80GiB', 'leader_count': 10, 'region_count': 30}}]}
resp = PDStoresResponse(**stores_json)
print(f'Parsed store: {resp.stores[0].store.address}')

prom_json = {'status': 'success', 'data': {'resultType': 'vector', 'result': [{'metric': {'__name__': 'test'}, 'value': [1234567890, '42.5']}]}}
prom = PrometheusQueryResponse(**prom_json)
print(f'Parsed metric value: {prom.get_single_value()}')
"
```
  </verify>
  <done>Pydantic models parse PD API and Prometheus responses correctly, handling nested structures and string-to-float conversion</done>
</task>

</tasks>

<verification>
After both tasks:
1. `uv sync` completes without errors
2. `uv run python -c "import operator_tikv"` succeeds
3. All types are importable and parse sample JSON correctly
4. No linting errors in new files
</verification>

<success_criteria>
- operator-tikv package is a valid workspace member
- Package depends on operator-core (inherits httpx, pydantic)
- Pydantic models handle PD API nested responses (stores.store.id pattern)
- Pydantic models handle Prometheus string-value conversion
- All types exported from package __init__.py
</success_criteria>

<output>
After completion, create `.planning/phases/02-tikv-subject/02-01-SUMMARY.md`
</output>
