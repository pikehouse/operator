---
phase: 10-demo-flow-control
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/operator-core/src/operator_core/tui/keyboard.py
  - packages/operator-core/src/operator_core/tui/chapters.py
  - packages/operator-core/src/operator_core/tui/controller.py
  - packages/operator-core/pyproject.toml
autonomous: false

must_haves:
  truths:
    - "Demo advances to next chapter on SPACE/ENTER/RIGHT key press"
    - "Narration panel displays story text for current chapter"
    - "Chapter text explains what is happening and what to watch for"
    - "Available key commands (SPACE, Q) are visible in narration panel"
    - "Q key quits the demo cleanly"
  artifacts:
    - path: "packages/operator-core/src/operator_core/tui/keyboard.py"
      provides: "KeyboardTask for async keyboard input"
      exports: ["KeyboardTask"]
    - path: "packages/operator-core/src/operator_core/tui/chapters.py"
      provides: "Chapter definitions and DemoState"
      exports: ["Chapter", "DemoState", "DEMO_CHAPTERS"]
    - path: "packages/operator-core/src/operator_core/tui/controller.py"
      provides: "TUIController with keyboard and narration integration"
      contains: "KeyboardTask"
  key_links:
    - from: "controller.py"
      to: "keyboard.py"
      via: "KeyboardTask import and TaskGroup integration"
      pattern: "from.*keyboard.*import.*KeyboardTask"
    - from: "controller.py"
      to: "chapters.py"
      via: "DemoState and DEMO_CHAPTERS import"
      pattern: "from.*chapters.*import"
    - from: "KeyboardTask.run()"
      to: "on_key callback"
      via: "callback invocation on each keypress"
      pattern: "_on_key\\(key\\)"
---

<objective>
Add key-press chapter progression and narration to the TUI demo.

Purpose: Enable presenters to control demo pacing via keyboard, with narration explaining each stage of the chaos demo.
Output: KeyboardTask class, Chapter definitions, and TUIController integration for interactive demo flow.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-demo-flow-control/10-RESEARCH.md
@packages/operator-core/src/operator_core/tui/controller.py
@packages/operator-core/src/operator_core/tui/layout.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create keyboard.py and chapters.py modules</name>
  <files>
    packages/operator-core/src/operator_core/tui/keyboard.py
    packages/operator-core/src/operator_core/tui/chapters.py
    packages/operator-core/pyproject.toml
  </files>
  <action>
Create two new modules following RESEARCH.md patterns:

**keyboard.py** - Per RESEARCH.md Pattern 1 (Async Keyboard Reader with Executor):
- Create `KeyboardTask` class with:
  - `__init__(self, on_key: Callable[[str], None])` - stores callback
  - `_shutdown: asyncio.Event` for graceful stop
  - `async def run(self)` - main loop using `loop.run_in_executor(None, readchar.readkey)` with 0.5s timeout
  - `def stop(self)` - sets shutdown event
- Use `asyncio.wait_for()` with timeout around executor call per RESEARCH.md Pitfall 2
- Handle `asyncio.CancelledError` for TaskGroup cancellation
- Import `readchar` for cross-platform keypress reading

**chapters.py** - Per RESEARCH.md Pattern 2 (Chapter State Machine):
- Create `Chapter` dataclass (frozen=True) with:
  - `title: str`
  - `narration: str`
  - `key_hint: str = "[dim]SPACE/ENTER: next | Q: quit[/dim]"`
- Create `DemoState` dataclass with:
  - `chapters: list[Chapter]`
  - `current: int = 0`
  - `def advance(self) -> bool` - increments current, returns False if at end
  - `def get_current(self) -> Chapter` - returns current chapter
  - `def is_complete(self) -> bool` - checks if at final chapter
- Create `DEMO_CHAPTERS` list matching the demo flow from RESEARCH.md:
  1. Welcome
  2. Stage 1: Cluster Health
  3. Stage 2: Load Generation
  4. Stage 3: Fault Injection
  5. Stage 4: Detection
  6. Stage 5: AI Diagnosis
  7. Demo Complete

**pyproject.toml** - Add readchar dependency:
- Add `"readchar>=4.2.0"` to dependencies list

Do NOT manually set terminal modes (cbreak/raw) - let readchar handle it per RESEARCH.md Don't Hand-Roll guidance.
  </action>
  <verify>
    - `python -c "from operator_core.tui.keyboard import KeyboardTask; print('keyboard OK')"`
    - `python -c "from operator_core.tui.chapters import Chapter, DemoState, DEMO_CHAPTERS; print(f'{len(DEMO_CHAPTERS)} chapters')"`
    - `grep readchar packages/operator-core/pyproject.toml` shows dependency
  </verify>
  <done>
    - KeyboardTask class exists with async run() using executor
    - Chapter and DemoState dataclasses exist
    - DEMO_CHAPTERS has 7 chapters with title, narration, key_hint
    - readchar is in pyproject.toml dependencies
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate keyboard and narration into TUIController</name>
  <files>
    packages/operator-core/src/operator_core/tui/controller.py
  </files>
  <action>
Modify TUIController to add keyboard input and narration updates per RESEARCH.md Pattern 3 (Key-to-Action Dispatch) and Pattern 4 (Narration Panel Update):

**Imports:**
- Add: `from operator_core.tui.keyboard import KeyboardTask`
- Add: `from operator_core.tui.chapters import DemoState, DEMO_CHAPTERS`
- Add: `import readchar` (for key constants like readchar.key.SPACE)

**New instance variables in __init__:**
- `self._demo_state: DemoState | None = None`
- `self._keyboard: KeyboardTask | None = None`

**New method _handle_key(self, key: str):**
Per RESEARCH.md Pattern 3:
- Check for advance keys: `key in (readchar.key.SPACE, readchar.key.ENTER, readchar.key.RIGHT, " ")`
  - If yes: call `self._demo_state.advance()` and `self._update_narration()`
- Check for quit keys: `key in ("q", "Q")`
  - If yes: set `self._shutdown.set()` to trigger clean exit
- Ignore other keys silently

**New method _update_narration(self):**
Per RESEARCH.md Pattern 4:
- Get current chapter: `chapter = self._demo_state.get_current()`
- Build content with title, narration, and key_hint using Rich Text or string concatenation
- Update narration panel: `self._layout["main"]["narration"].update(make_panel(content, "Chapter", "magenta"))`

**Modify run() method:**
After health_poller creation (line ~115), add:
```python
# Initialize demo state and keyboard
self._demo_state = DemoState(chapters=list(DEMO_CHAPTERS))
self._keyboard = KeyboardTask(on_key=self._handle_key)
```

In _init_panels(), change narration initialization to call `self._update_narration()` to show first chapter.

In TaskGroup section, add keyboard task:
```python
tg.create_task(self._keyboard.run())
```

In _handle_signal(), add keyboard stop:
```python
if self._keyboard is not None:
    self._keyboard.stop()
```

CRITICAL: Do NOT call readchar.readkey() directly in async code - always use the KeyboardTask's executor wrapper per RESEARCH.md Pitfall 1.
  </action>
  <verify>
    - `python -c "from operator_core.tui.controller import TUIController; print('import OK')"`
    - `grep "KeyboardTask" packages/operator-core/src/operator_core/tui/controller.py` shows import
    - `grep "_handle_key" packages/operator-core/src/operator_core/tui/controller.py` shows method
    - `grep "_update_narration" packages/operator-core/src/operator_core/tui/controller.py` shows method
  </verify>
  <done>
    - TUIController imports KeyboardTask, DemoState, DEMO_CHAPTERS
    - _handle_key() method dispatches SPACE/ENTER/RIGHT to advance, Q to quit
    - _update_narration() method updates narration panel with current chapter
    - KeyboardTask runs in TaskGroup alongside other tasks
    - Initial narration shows first chapter on startup
    - Clean shutdown stops keyboard task
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Checkpoint: Verify demo flow control</name>
  <what-built>
    Key-press chapter progression with narration panel updates. The TUI now responds to keyboard input to advance through demo stages.
  </what-built>
  <how-to-verify>
    1. Install dependencies: `cd packages/operator-core && pip install -e .`
    2. Ensure TiDB cluster is running (or mock PD endpoint)
    3. Start the TUI: `python -m operator_core.tui.controller` (or appropriate entry point)
    4. Observe initial state:
       - Narration panel shows "Welcome" chapter
       - Key hints visible: "SPACE/ENTER: next | Q: quit"
    5. Press SPACE or ENTER:
       - Narration advances to "Stage 1: Cluster Health"
       - Chapter text explains what to watch for
    6. Press SPACE repeatedly through all 7 chapters
    7. On final chapter, verify it shows "Demo Complete"
    8. Press Q to quit:
       - TUI exits cleanly
       - Terminal is restored properly
    9. Verify Ctrl+C still works for emergency exit
  </how-to-verify>
  <resume-signal>Type "approved" if demo flow works, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
Phase 10 requirements verification:
- DEMO-01: Key-press chapter progression - press key to advance demo stages
- DEMO-02: Narration panel with story text explaining what's happening at each stage

Run the TUI and verify:
1. Keyboard input works without blocking panel updates
2. All 7 chapters are accessible via key presses
3. Narration text is readable and informative
4. Q key exits cleanly
5. No terminal corruption on exit
</verification>

<success_criteria>
- [ ] KeyboardTask reads keypresses without blocking event loop
- [ ] DemoState tracks chapter progression (7 chapters total)
- [ ] SPACE/ENTER/RIGHT advance to next chapter
- [ ] Q key triggers clean shutdown
- [ ] Narration panel updates with chapter title, text, and key hints
- [ ] All 6 demo stages + welcome + complete chapters present
- [ ] No terminal mode issues on startup or shutdown
- [ ] Clean integration with existing TaskGroup pattern
</success_criteria>

<output>
After completion, create `.planning/phases/10-demo-flow-control/10-01-SUMMARY.md`
</output>
