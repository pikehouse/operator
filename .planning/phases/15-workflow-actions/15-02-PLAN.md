---
phase: 15-workflow-actions
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - packages/operator-core/src/operator_core/db/actions.py
autonomous: true

must_haves:
  truths:
    - "Can create a workflow with multiple actions in database"
    - "Can list actions belonging to a workflow in execution order"
    - "Can query scheduled actions ready for execution"
    - "Can query failed actions eligible for retry"
  artifacts:
    - path: "packages/operator-core/src/operator_core/db/actions.py"
      provides: "Workflow and scheduling database methods"
      exports: ["create_workflow", "list_workflow_actions", "list_ready_scheduled", "list_retry_eligible"]
  key_links:
    - from: "db/actions.py"
      to: "actions/types.py"
      via: "Uses WorkflowProposal, WorkflowStatus types"
      pattern: "WorkflowProposal|WorkflowStatus"
---

<objective>
Implement ActionDB methods for workflow management, scheduled action queries, and retry tracking.

Purpose: These database methods enable WRK-01 (create and query workflows), WRK-02 (find scheduled actions ready to execute), and WRK-03 (find failed actions eligible for retry). The executor and agent runner will use these methods.

Output: ActionDB extended with create_workflow, list_workflow_actions, update_workflow_status, list_ready_scheduled, list_retry_eligible, increment_retry_count, and update_next_retry methods.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-workflow-actions/15-RESEARCH.md
@packages/operator-core/src/operator_core/db/actions.py
@packages/operator-core/src/operator_core/actions/types.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add workflow CRUD methods to ActionDB</name>
  <files>packages/operator-core/src/operator_core/db/actions.py</files>
  <action>
Add a new section comment after the Approval operations section:

```python
# =========================================================================
# Workflow operations (WRK-01)
# =========================================================================
```

Add _row_to_workflow helper method (after _row_to_record):

```python
def _row_to_workflow(self, row: aiosqlite.Row) -> WorkflowProposal:
    """
    Convert a database row to a WorkflowProposal.

    Args:
        row: Database row with workflow fields

    Returns:
        WorkflowProposal instance
    """
    created_at = datetime.fromisoformat(row["created_at"])

    return WorkflowProposal(
        id=row["id"],
        name=row["name"],
        description=row["description"],
        ticket_id=row["ticket_id"],
        status=WorkflowStatus(row["status"]),
        created_at=created_at,
    )
```

Add create_workflow method:

```python
async def create_workflow(
    self,
    name: str,
    description: str,
    actions: list[ActionProposal],
    ticket_id: int | None = None,
) -> int:
    """
    Create a workflow with its actions.

    Creates the workflow record, then creates each action proposal
    linked to the workflow with proper execution_order.

    Args:
        name: Workflow name (e.g., "drain_and_verify")
        description: What this workflow accomplishes
        actions: List of ActionProposal objects to include
        ticket_id: Optional ticket ID for traceability

    Returns:
        The created workflow ID
    """
    # Insert workflow
    cursor = await self._conn.execute(
        """
        INSERT INTO workflows (name, description, ticket_id, status)
        VALUES (?, ?, ?, 'pending')
        """,
        (name, description, ticket_id),
    )
    workflow_id = cursor.lastrowid

    # Insert actions with workflow_id and execution_order
    for i, action in enumerate(actions):
        # Set workflow fields
        action.workflow_id = workflow_id
        action.execution_order = i
        if i > 0:
            # Each action depends on the previous one
            # This will be set after we get IDs
            pass

        await self.create_proposal(action)

    await self._conn.commit()
    return workflow_id
```

Add list_workflow_actions method:

```python
async def list_workflow_actions(
    self, workflow_id: int
) -> list[ActionProposal]:
    """
    Get all actions for a workflow in execution order.

    Args:
        workflow_id: The workflow ID

    Returns:
        List of ActionProposal objects ordered by execution_order
    """
    async with self._conn.execute(
        """
        SELECT * FROM action_proposals
        WHERE workflow_id = ?
        ORDER BY execution_order ASC
        """,
        (workflow_id,),
    ) as cursor:
        rows = await cursor.fetchall()

    return [self._row_to_proposal(row) for row in rows]
```

Add get_workflow method:

```python
async def get_workflow(self, workflow_id: int) -> WorkflowProposal | None:
    """
    Fetch a workflow by ID.

    Args:
        workflow_id: The workflow ID

    Returns:
        The WorkflowProposal if found, None otherwise
    """
    async with self._conn.execute(
        "SELECT * FROM workflows WHERE id = ?",
        (workflow_id,),
    ) as cursor:
        row = await cursor.fetchone()

    if row:
        return self._row_to_workflow(row)
    return None
```

Add update_workflow_status method:

```python
async def update_workflow_status(
    self,
    workflow_id: int,
    status: WorkflowStatus,
) -> None:
    """
    Update the status of a workflow.

    Args:
        workflow_id: The workflow ID to update
        status: The new status
    """
    await self._conn.execute(
        "UPDATE workflows SET status = ? WHERE id = ?",
        (status.value, workflow_id),
    )
    await self._conn.commit()
```
  </action>
  <verify>python -c "
import asyncio
from pathlib import Path
from operator_core.db.actions import ActionDB
from operator_core.actions.types import ActionProposal, ActionStatus

async def test():
    import tempfile
    with tempfile.NamedTemporaryFile(suffix='.db', delete=False) as f:
        db_path = Path(f.name)

    async with ActionDB(db_path) as db:
        # Create workflow with 2 actions
        actions = [
            ActionProposal(action_name='step1', reason='first step'),
            ActionProposal(action_name='step2', reason='second step'),
        ]
        wf_id = await db.create_workflow('test_wf', 'test workflow', actions)
        print(f'Created workflow {wf_id}')

        # List workflow actions
        wf_actions = await db.list_workflow_actions(wf_id)
        print(f'Got {len(wf_actions)} actions in order: {[a.action_name for a in wf_actions]}')

        # Get workflow
        wf = await db.get_workflow(wf_id)
        print(f'Workflow status: {wf.status.value}')

    import os
    os.unlink(db_path)

asyncio.run(test())
"</verify>
  <done>ActionDB has create_workflow, list_workflow_actions, get_workflow, and update_workflow_status methods working correctly.</done>
</task>

<task type="auto">
  <name>Task 2: Add scheduling query methods to ActionDB</name>
  <files>packages/operator-core/src/operator_core/db/actions.py</files>
  <action>
Add a new section comment:

```python
# =========================================================================
# Scheduling operations (WRK-02)
# =========================================================================
```

Add list_ready_scheduled method:

```python
async def list_ready_scheduled(self) -> list[ActionProposal]:
    """
    Get validated actions ready for scheduled execution.

    Returns actions that:
    - Have status 'validated'
    - Have a scheduled_at timestamp
    - scheduled_at is in the past (ready to execute)
    - Are approved (if part of approved workflow, or individually approved)

    Returns:
        List of ActionProposal objects ordered by scheduled_at ASC
    """
    now = datetime.now().isoformat()

    async with self._conn.execute(
        """
        SELECT * FROM action_proposals
        WHERE status = 'validated'
          AND scheduled_at IS NOT NULL
          AND scheduled_at <= ?
          AND (approved_at IS NOT NULL OR workflow_id IS NOT NULL)
        ORDER BY scheduled_at ASC
        """,
        (now,),
    ) as cursor:
        rows = await cursor.fetchall()

    return [self._row_to_proposal(row) for row in rows]
```

Add update_scheduled_at method:

```python
async def update_scheduled_at(
    self,
    proposal_id: int,
    scheduled_at: datetime | None,
) -> None:
    """
    Update the scheduled execution time for a proposal.

    Args:
        proposal_id: The proposal ID to update
        scheduled_at: When to execute (None to clear scheduling)
    """
    scheduled_str = scheduled_at.isoformat() if scheduled_at else None

    await self._conn.execute(
        "UPDATE action_proposals SET scheduled_at = ? WHERE id = ?",
        (scheduled_str, proposal_id),
    )
    await self._conn.commit()
```
  </action>
  <verify>python -c "
import asyncio
from pathlib import Path
from datetime import datetime, timedelta
from operator_core.db.actions import ActionDB
from operator_core.actions.types import ActionProposal, ActionStatus

async def test():
    import tempfile
    with tempfile.NamedTemporaryFile(suffix='.db', delete=False) as f:
        db_path = Path(f.name)

    async with ActionDB(db_path) as db:
        # Create scheduled action (in the past - ready)
        p = ActionProposal(
            action_name='check',
            reason='follow-up',
            status=ActionStatus.VALIDATED,
            scheduled_at=datetime.now() - timedelta(minutes=1),
        )
        created = await db.create_proposal(p)
        # Approve it so it shows up
        await db.approve_proposal(created.id)

        # Query ready scheduled
        ready = await db.list_ready_scheduled()
        print(f'Ready scheduled: {len(ready)} action(s)')

    import os
    os.unlink(db_path)

asyncio.run(test())
"</verify>
  <done>ActionDB has list_ready_scheduled and update_scheduled_at methods for WRK-02 scheduling support.</done>
</task>

<task type="auto">
  <name>Task 3: Add retry query and update methods to ActionDB</name>
  <files>packages/operator-core/src/operator_core/db/actions.py</files>
  <action>
Add a new section comment:

```python
# =========================================================================
# Retry operations (WRK-03)
# =========================================================================
```

Add list_retry_eligible method:

```python
async def list_retry_eligible(self) -> list[ActionProposal]:
    """
    Get failed actions eligible for retry.

    Returns actions that:
    - Have status 'failed'
    - Have retry_count < max_retries
    - Have a next_retry_at timestamp in the past (ready to retry)

    Returns:
        List of ActionProposal objects ordered by next_retry_at ASC
    """
    now = datetime.now().isoformat()

    async with self._conn.execute(
        """
        SELECT * FROM action_proposals
        WHERE status = 'failed'
          AND retry_count < max_retries
          AND next_retry_at IS NOT NULL
          AND next_retry_at <= ?
        ORDER BY next_retry_at ASC
        """,
        (now,),
    ) as cursor:
        rows = await cursor.fetchall()

    return [self._row_to_proposal(row) for row in rows]
```

Add increment_retry_count method:

```python
async def increment_retry_count(
    self,
    proposal_id: int,
    error_message: str | None = None,
) -> None:
    """
    Increment retry count and record last error.

    Args:
        proposal_id: The proposal ID to update
        error_message: Error from the failed attempt
    """
    await self._conn.execute(
        """
        UPDATE action_proposals SET
            retry_count = retry_count + 1,
            last_error = ?
        WHERE id = ?
        """,
        (error_message, proposal_id),
    )
    await self._conn.commit()
```

Add update_next_retry method:

```python
async def update_next_retry(
    self,
    proposal_id: int,
    next_retry_at: datetime | None,
) -> None:
    """
    Update the next retry time for a failed action.

    Args:
        proposal_id: The proposal ID to update
        next_retry_at: When to retry next (None to disable retry)
    """
    retry_str = next_retry_at.isoformat() if next_retry_at else None

    await self._conn.execute(
        "UPDATE action_proposals SET next_retry_at = ? WHERE id = ?",
        (retry_str, proposal_id),
    )
    await self._conn.commit()
```

Add reset_for_retry method:

```python
async def reset_for_retry(self, proposal_id: int) -> None:
    """
    Reset a failed action to validated status for retry.

    This is called before retrying an action to move it back
    to a state where it can be executed again.

    Args:
        proposal_id: The proposal ID to reset
    """
    await self._conn.execute(
        """
        UPDATE action_proposals SET
            status = 'validated',
            next_retry_at = NULL
        WHERE id = ?
        """,
        (proposal_id,),
    )
    await self._conn.commit()
```
  </action>
  <verify>python -c "
import asyncio
from pathlib import Path
from datetime import datetime, timedelta
from operator_core.db.actions import ActionDB
from operator_core.actions.types import ActionProposal, ActionStatus

async def test():
    import tempfile
    with tempfile.NamedTemporaryFile(suffix='.db', delete=False) as f:
        db_path = Path(f.name)

    async with ActionDB(db_path) as db:
        # Create failed action with retry scheduled
        p = ActionProposal(
            action_name='flaky_op',
            reason='test retry',
            status=ActionStatus.FAILED,
            retry_count=1,
            max_retries=3,
            next_retry_at=datetime.now() - timedelta(seconds=10),
            last_error='Connection timeout',
        )
        created = await db.create_proposal(p)

        # Query retry eligible
        eligible = await db.list_retry_eligible()
        print(f'Retry eligible: {len(eligible)} action(s)')

        # Increment retry
        await db.increment_retry_count(created.id, 'Second failure')
        fetched = await db.get_proposal(created.id)
        print(f'Retry count after increment: {fetched.retry_count}')

    import os
    os.unlink(db_path)

asyncio.run(test())
"</verify>
  <done>ActionDB has list_retry_eligible, increment_retry_count, update_next_retry, and reset_for_retry methods for WRK-03 retry support.</done>
</task>

</tasks>

<verification>
1. Workflow creation: Create workflow, verify actions have workflow_id and execution_order
2. Workflow queries: list_workflow_actions returns actions in order
3. Scheduling queries: list_ready_scheduled finds validated+scheduled+approved actions past due
4. Retry queries: list_retry_eligible finds failed actions with retries remaining past due
5. All methods commit changes properly
</verification>

<success_criteria>
1. create_workflow creates workflow row and links actions with execution_order
2. list_workflow_actions returns actions for workflow in execution_order
3. get_workflow returns WorkflowProposal with correct status
4. update_workflow_status changes workflow status
5. list_ready_scheduled returns validated+scheduled+approved actions where scheduled_at <= now
6. update_scheduled_at sets/clears scheduled_at timestamp
7. list_retry_eligible returns failed actions with retry_count < max_retries where next_retry_at <= now
8. increment_retry_count increases count and records error
9. update_next_retry sets/clears next_retry_at timestamp
10. reset_for_retry sets status back to validated and clears next_retry_at
</success_criteria>

<output>
After completion, create `.planning/phases/15-workflow-actions/15-02-SUMMARY.md`
</output>
