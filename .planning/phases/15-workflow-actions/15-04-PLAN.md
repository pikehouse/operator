---
phase: 15-workflow-actions
plan: 04
type: execute
wave: 3
depends_on: ["15-02", "15-03"]
files_modified:
  - packages/operator-core/src/operator_core/agent/runner.py
autonomous: true

must_haves:
  truths:
    - "Agent poll loop checks for scheduled actions ready to execute"
    - "Agent poll loop checks for failed actions eligible for retry"
    - "Scheduled actions execute at their scheduled time"
    - "Failed actions retry with exponential backoff"
  artifacts:
    - path: "packages/operator-core/src/operator_core/agent/runner.py"
      provides: "Scheduled and retry action processing in poll loop"
      contains: "_process_scheduled_actions"
  key_links:
    - from: "agent/runner.py"
      to: "db/actions.py"
      via: "Queries list_ready_scheduled and list_retry_eligible"
      pattern: "list_ready_scheduled|list_retry_eligible"
    - from: "agent/runner.py"
      to: "actions/executor.py"
      via: "Calls execute_proposal and schedule_next_retry"
      pattern: "execute_proposal|schedule_next_retry"
---

<objective>
Integrate scheduled action execution and retry processing into the AgentRunner poll loop.

Purpose: This plan extends the agent's poll loop to check for scheduled actions ready to execute (WRK-02) and failed actions eligible for retry (WRK-03). This completes the workflow functionality by enabling the agent to automatically execute deferred and retried actions.

Output: AgentRunner with _process_scheduled_actions and _process_retry_eligible methods called from _process_cycle.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-workflow-actions/15-RESEARCH.md
@packages/operator-core/src/operator_core/agent/runner.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add scheduled action processing to AgentRunner</name>
  <files>packages/operator-core/src/operator_core/agent/runner.py</files>
  <action>
Add import for ActionDB at top (inside TYPE_CHECKING or direct):

```python
from operator_core.db.actions import ActionDB
from operator_core.actions.types import ActionProposal
```

Add _process_scheduled_actions method (after _propose_actions_from_diagnosis):

```python
async def _process_scheduled_actions(self) -> None:
    """
    Execute scheduled actions that are ready.

    Queries for validated actions with scheduled_at <= now and executes them.
    This enables WRK-02: schedule follow-up actions.
    """
    if self.executor is None:
        return

    async with ActionDB(self.db_path) as db:
        ready_actions = await db.list_ready_scheduled()

        if ready_actions:
            print(f"Found {len(ready_actions)} scheduled action(s) ready to execute")

        for action in ready_actions:
            if self._shutdown.is_set():
                break

            await self._execute_scheduled_action(action)
```

Add _execute_scheduled_action method:

```python
async def _execute_scheduled_action(self, action: ActionProposal) -> None:
    """
    Execute a single scheduled action.

    Args:
        action: The scheduled ActionProposal to execute
    """
    print(
        f"Executing scheduled action {action.id}: {action.action_name} "
        f"(scheduled for {action.scheduled_at})"
    )

    try:
        record = await self.executor.execute_proposal(action.id, self.subject)

        if record.success:
            print(f"Scheduled action {action.id} completed successfully")
        else:
            print(f"Scheduled action {action.id} failed: {record.error_message}")
            # Schedule retry if applicable
            await self._schedule_retry_if_needed(action.id, record.error_message)

    except Exception as e:
        print(f"Error executing scheduled action {action.id}: {e}")
        await self._schedule_retry_if_needed(action.id, str(e))
```

Update _process_cycle to call _process_scheduled_actions (add after ticket processing loop):

In _process_cycle, after the `for ticket in tickets:` loop and before the function ends, add:

```python
# Process scheduled actions (WRK-02)
await self._process_scheduled_actions()
```
  </action>
  <verify>python -c "
from operator_core.agent.runner import AgentRunner
import inspect

# Check methods exist
assert hasattr(AgentRunner, '_process_scheduled_actions')
assert hasattr(AgentRunner, '_execute_scheduled_action')

# Check signatures
sched_sig = inspect.signature(AgentRunner._process_scheduled_actions)
exec_sig = inspect.signature(AgentRunner._execute_scheduled_action)
assert 'action' in exec_sig.parameters

print('_process_scheduled_actions and _execute_scheduled_action methods exist')
"</verify>
  <done>AgentRunner has _process_scheduled_actions method that queries list_ready_scheduled and calls _execute_scheduled_action for each. _process_cycle calls _process_scheduled_actions after ticket processing.</done>
</task>

<task type="auto">
  <name>Task 2: Add retry processing to AgentRunner</name>
  <files>packages/operator-core/src/operator_core/agent/runner.py</files>
  <action>
Add _process_retry_eligible method (after _execute_scheduled_action):

```python
async def _process_retry_eligible(self) -> None:
    """
    Retry failed actions that are eligible.

    Queries for failed actions with next_retry_at <= now and retry_count < max_retries,
    then attempts to re-execute them. This enables WRK-03: retry with backoff.
    """
    if self.executor is None:
        return

    async with ActionDB(self.db_path) as db:
        retry_actions = await db.list_retry_eligible()

        if retry_actions:
            print(f"Found {len(retry_actions)} action(s) eligible for retry")

        for action in retry_actions:
            if self._shutdown.is_set():
                break

            await self._retry_failed_action(action)
```

Add _retry_failed_action method:

```python
async def _retry_failed_action(self, action: ActionProposal) -> None:
    """
    Retry a single failed action.

    Resets the action to validated status and attempts execution again.

    Args:
        action: The failed ActionProposal to retry
    """
    print(
        f"Retrying action {action.id}: {action.action_name} "
        f"(attempt {action.retry_count + 1}/{action.max_retries})"
    )

    try:
        # Reset action to validated for re-execution
        async with ActionDB(self.db_path) as db:
            await db.reset_for_retry(action.id)

        # Execute the action
        record = await self.executor.execute_proposal(action.id, self.subject)

        if record.success:
            print(f"Retry succeeded for action {action.id}")
            self._retries_succeeded = getattr(self, '_retries_succeeded', 0) + 1
        else:
            print(f"Retry failed for action {action.id}: {record.error_message}")
            await self._schedule_retry_if_needed(action.id, record.error_message)

    except Exception as e:
        print(f"Error retrying action {action.id}: {e}")
        await self._schedule_retry_if_needed(action.id, str(e))
```

Add _schedule_retry_if_needed helper method:

```python
async def _schedule_retry_if_needed(
    self,
    proposal_id: int,
    error_message: str,
) -> None:
    """
    Schedule next retry for a failed action if retries remain.

    Args:
        proposal_id: The failed proposal ID
        error_message: Error from the failed attempt
    """
    try:
        next_retry = await self.executor.schedule_next_retry(proposal_id, error_message)
        if next_retry:
            delay = (next_retry - __import__('datetime').datetime.now()).total_seconds()
            print(f"Action {proposal_id} scheduled for retry in {delay:.1f}s")
        else:
            print(f"Action {proposal_id} exhausted all retries")
    except Exception as e:
        print(f"Error scheduling retry for action {proposal_id}: {e}")
```

Update _process_cycle to call _process_retry_eligible (add after _process_scheduled_actions):

```python
# Process retry-eligible actions (WRK-03)
await self._process_retry_eligible()
```

Update __init__ to initialize retry stats:

In __init__, after `self._actions_proposed = 0`, add:

```python
self._retries_succeeded = 0
```
  </action>
  <verify>python -c "
from operator_core.agent.runner import AgentRunner
import inspect

# Check methods exist
assert hasattr(AgentRunner, '_process_retry_eligible')
assert hasattr(AgentRunner, '_retry_failed_action')
assert hasattr(AgentRunner, '_schedule_retry_if_needed')

# Check signatures
retry_sig = inspect.signature(AgentRunner._retry_failed_action)
assert 'action' in retry_sig.parameters

sched_sig = inspect.signature(AgentRunner._schedule_retry_if_needed)
assert 'proposal_id' in sched_sig.parameters
assert 'error_message' in sched_sig.parameters

print('_process_retry_eligible, _retry_failed_action, and _schedule_retry_if_needed methods exist')
"</verify>
  <done>AgentRunner has _process_retry_eligible method that queries list_retry_eligible and calls _retry_failed_action for each. _retry_failed_action resets action to validated and re-executes. _schedule_retry_if_needed uses executor to schedule backoff. _process_cycle calls both new methods.</done>
</task>

</tasks>

<verification>
1. Methods exist: Import AgentRunner and check for new methods
2. _process_cycle calls new methods: Verify scheduled and retry processing in loop
3. Integration with ActionDB: Methods use list_ready_scheduled and list_retry_eligible
4. Integration with executor: Methods use execute_proposal and schedule_next_retry
5. Error handling: Exceptions are caught and logged, don't crash loop
</verification>

<success_criteria>
1. _process_scheduled_actions queries ActionDB.list_ready_scheduled
2. _process_scheduled_actions calls _execute_scheduled_action for each ready action
3. _execute_scheduled_action calls executor.execute_proposal
4. _execute_scheduled_action schedules retry on failure
5. _process_retry_eligible queries ActionDB.list_retry_eligible
6. _process_retry_eligible calls _retry_failed_action for each eligible action
7. _retry_failed_action resets action via ActionDB.reset_for_retry before execution
8. _retry_failed_action schedules next retry on failure
9. _schedule_retry_if_needed uses executor.schedule_next_retry
10. _process_cycle calls both _process_scheduled_actions and _process_retry_eligible
11. All methods respect shutdown signal
12. All errors are caught and logged without crashing the loop
</success_criteria>

<output>
After completion, create `.planning/phases/15-workflow-actions/15-04-SUMMARY.md`
</output>
