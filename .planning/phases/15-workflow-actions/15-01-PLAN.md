---
phase: 15-workflow-actions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/operator-core/src/operator_core/db/schema.py
  - packages/operator-core/src/operator_core/actions/types.py
  - packages/operator-core/src/operator_core/db/actions.py
autonomous: true

must_haves:
  truths:
    - "ActionProposal can reference a parent workflow"
    - "ActionProposal can be scheduled for future execution"
    - "ActionProposal tracks retry state"
    - "Workflows table exists for grouping actions"
  artifacts:
    - path: "packages/operator-core/src/operator_core/db/schema.py"
      provides: "Workflows table and action_proposals extensions"
      contains: "CREATE TABLE IF NOT EXISTS workflows"
    - path: "packages/operator-core/src/operator_core/actions/types.py"
      provides: "WorkflowProposal, WorkflowStatus, extended ActionProposal"
      contains: "class WorkflowStatus"
  key_links:
    - from: "actions/types.py"
      to: "db/schema.py"
      via: "Field names match column names"
      pattern: "workflow_id|scheduled_at|retry_count"
---

<objective>
Extend database schema and action types for workflow chaining, scheduled execution, and retry tracking.

Purpose: This plan creates the foundational data structures needed for WRK-01 (workflow chaining), WRK-02 (scheduled follow-ups), and WRK-03 (retry with backoff). All subsequent plans depend on these schema and type definitions.

Output: Extended ActionProposal with workflow/scheduling/retry fields, new WorkflowProposal and WorkflowStatus types, and database schema with workflows table.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-workflow-actions/15-RESEARCH.md
@packages/operator-core/src/operator_core/db/schema.py
@packages/operator-core/src/operator_core/actions/types.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ActionProposal with workflow and scheduling fields</name>
  <files>packages/operator-core/src/operator_core/actions/types.py</files>
  <action>
Add the following new fields to ActionProposal (after rejection_reason):

```python
# Workflow fields (WRK-01)
workflow_id: int | None = Field(
    default=None, description="Parent workflow ID if part of a chain"
)
execution_order: int = Field(
    default=0, description="Order within workflow (0-indexed)"
)
depends_on_proposal_id: int | None = Field(
    default=None, description="Proposal ID that must complete before this runs"
)

# Scheduling fields (WRK-02)
scheduled_at: datetime | None = Field(
    default=None, description="Execute at this time (None = immediate)"
)

# Retry fields (WRK-03)
retry_count: int = Field(default=0, description="Number of retry attempts so far")
max_retries: int = Field(default=3, description="Maximum retry attempts")
next_retry_at: datetime | None = Field(
    default=None, description="When to retry next (None = not scheduled)"
)
last_error: str | None = Field(
    default=None, description="Error message from last failed attempt"
)
```

Add WorkflowStatus enum (before ActionProposal class):

```python
class WorkflowStatus(str, Enum):
    """
    Valid workflow lifecycle states.

    Workflows flow through these states:
        pending -> in_progress -> completed/failed/cancelled
    """

    PENDING = "pending"
    """Workflow created, no actions started yet."""

    IN_PROGRESS = "in_progress"
    """At least one action is executing."""

    COMPLETED = "completed"
    """All actions completed successfully."""

    FAILED = "failed"
    """At least one action failed."""

    CANCELLED = "cancelled"
    """Workflow was cancelled."""
```

Add WorkflowProposal class (after ActionProposal):

```python
class WorkflowProposal(BaseModel):
    """
    Group of related actions to execute as a workflow.

    A workflow is a sequence of ActionProposals that execute in order.
    Approval can happen at the workflow level (approve once, execute all).

    Attributes:
        id: Database ID (None before insert)
        name: Workflow name (e.g., "drain_and_verify")
        description: What this workflow accomplishes
        ticket_id: Associated ticket (optional, for traceability)
        status: Current lifecycle state
        created_at: When created
    """

    id: int | None = Field(default=None, description="Database ID")
    name: str = Field(..., description="Workflow name")
    description: str = Field(..., description="What this workflow accomplishes")
    ticket_id: int | None = Field(
        default=None, description="Associated ticket ID for traceability"
    )
    status: WorkflowStatus = Field(
        default=WorkflowStatus.PENDING, description="Current lifecycle state"
    )
    created_at: datetime = Field(
        default_factory=datetime.now, description="When the workflow was created"
    )

    class Config:
        """Pydantic configuration."""
        use_enum_values = False
```

Update module docstring to mention workflow types.
  </action>
  <verify>python -c "from operator_core.actions.types import WorkflowStatus, WorkflowProposal, ActionProposal; p = ActionProposal(action_name='test', reason='test'); print(f'workflow_id={p.workflow_id}, scheduled_at={p.scheduled_at}, retry_count={p.retry_count}')"</verify>
  <done>ActionProposal has workflow_id, execution_order, depends_on_proposal_id, scheduled_at, retry_count, max_retries, next_retry_at, last_error fields. WorkflowStatus and WorkflowProposal types exist.</done>
</task>

<task type="auto">
  <name>Task 2: Extend database schema for workflows</name>
  <files>packages/operator-core/src/operator_core/db/schema.py</files>
  <action>
Add workflows table and indexes to ACTIONS_SCHEMA_SQL (before the closing triple-quote):

```sql
-- Workflows table for grouping related actions (WRK-01)
CREATE TABLE IF NOT EXISTS workflows (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    description TEXT,
    ticket_id INTEGER,
    status TEXT NOT NULL DEFAULT 'pending',
    created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (ticket_id) REFERENCES tickets(id)
);

-- Index for finding workflow actions
CREATE INDEX IF NOT EXISTS idx_action_proposals_workflow
ON action_proposals(workflow_id) WHERE workflow_id IS NOT NULL;

-- Index for finding scheduled actions (WRK-02)
CREATE INDEX IF NOT EXISTS idx_action_proposals_scheduled
ON action_proposals(scheduled_at) WHERE scheduled_at IS NOT NULL;

-- Index for finding retry-eligible actions (WRK-03)
CREATE INDEX IF NOT EXISTS idx_action_proposals_retry
ON action_proposals(next_retry_at) WHERE next_retry_at IS NOT NULL;

-- Trigger to update updated_at on workflows modification
CREATE TRIGGER IF NOT EXISTS workflows_updated_at
AFTER UPDATE ON workflows
BEGIN
    UPDATE workflows SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
END;
```

Update the module docstring to mention workflow management.
  </action>
  <verify>python -c "from operator_core.db.schema import ACTIONS_SCHEMA_SQL; assert 'CREATE TABLE IF NOT EXISTS workflows' in ACTIONS_SCHEMA_SQL; assert 'idx_action_proposals_workflow' in ACTIONS_SCHEMA_SQL; print('Schema extensions present')"</verify>
  <done>ACTIONS_SCHEMA_SQL includes workflows table, idx_action_proposals_workflow, idx_action_proposals_scheduled, idx_action_proposals_retry indexes, and workflows_updated_at trigger.</done>
</task>

<task type="auto">
  <name>Task 3: Add migration for new ActionProposal columns</name>
  <files>packages/operator-core/src/operator_core/db/actions.py</files>
  <action>
Extend _ensure_schema() method to add migration for new columns (Pattern 4 from existing code - try/except per column).

Add after existing approval column migrations:

```python
# Migration: Add workflow/scheduling/retry columns if they don't exist
# Workflow columns (WRK-01)
try:
    await self._conn.execute(
        "ALTER TABLE action_proposals ADD COLUMN workflow_id INTEGER"
    )
except Exception:
    pass  # Column already exists

try:
    await self._conn.execute(
        "ALTER TABLE action_proposals ADD COLUMN execution_order INTEGER DEFAULT 0"
    )
except Exception:
    pass

try:
    await self._conn.execute(
        "ALTER TABLE action_proposals ADD COLUMN depends_on_proposal_id INTEGER"
    )
except Exception:
    pass

# Scheduling columns (WRK-02)
try:
    await self._conn.execute(
        "ALTER TABLE action_proposals ADD COLUMN scheduled_at TEXT"
    )
except Exception:
    pass

# Retry columns (WRK-03)
try:
    await self._conn.execute(
        "ALTER TABLE action_proposals ADD COLUMN retry_count INTEGER DEFAULT 0"
    )
except Exception:
    pass

try:
    await self._conn.execute(
        "ALTER TABLE action_proposals ADD COLUMN max_retries INTEGER DEFAULT 3"
    )
except Exception:
    pass

try:
    await self._conn.execute(
        "ALTER TABLE action_proposals ADD COLUMN next_retry_at TEXT"
    )
except Exception:
    pass

try:
    await self._conn.execute(
        "ALTER TABLE action_proposals ADD COLUMN last_error TEXT"
    )
except Exception:
    pass

await self._conn.commit()
```

Update _row_to_proposal() to parse new fields. Add after existing field parsing (before the return statement):

```python
# Parse scheduling datetime (may be None)
scheduled_at = (
    datetime.fromisoformat(row["scheduled_at"]) if row["scheduled_at"] else None
)

# Parse retry datetime (may be None)
next_retry_at = (
    datetime.fromisoformat(row["next_retry_at"]) if row["next_retry_at"] else None
)
```

And add these fields to the ActionProposal constructor call:

```python
workflow_id=row["workflow_id"],
execution_order=row["execution_order"] or 0,
depends_on_proposal_id=row["depends_on_proposal_id"],
scheduled_at=scheduled_at,
retry_count=row["retry_count"] or 0,
max_retries=row["max_retries"] or 3,
next_retry_at=next_retry_at,
last_error=row["last_error"],
```

Add WorkflowStatus and WorkflowProposal to imports at top:

```python
from operator_core.actions.types import (
    ActionProposal,
    ActionRecord,
    ActionStatus,
    ActionType,
    WorkflowProposal,
    WorkflowStatus,
)
```
  </action>
  <verify>python -c "
import asyncio
from pathlib import Path
from operator_core.db.actions import ActionDB
from operator_core.actions.types import ActionProposal, ActionStatus

async def test():
    import tempfile
    with tempfile.NamedTemporaryFile(suffix='.db', delete=False) as f:
        db_path = Path(f.name)

    async with ActionDB(db_path) as db:
        # Create proposal with new fields
        p = ActionProposal(
            action_name='test',
            reason='test',
            workflow_id=None,
            scheduled_at=None,
            retry_count=0,
        )
        created = await db.create_proposal(p)
        fetched = await db.get_proposal(created.id)
        print(f'Created proposal with workflow_id={fetched.workflow_id}, retry_count={fetched.retry_count}')

    import os
    os.unlink(db_path)

asyncio.run(test())
"</verify>
  <done>ActionDB._ensure_schema() migrates workflow/scheduling/retry columns. _row_to_proposal() correctly parses all new fields including scheduled_at and next_retry_at as datetime.</done>
</task>

</tasks>

<verification>
1. All tests pass: `cd /Users/jrtipton/x/operator && python -m pytest packages/operator-core/tests/ -v --tb=short 2>/dev/null || echo "No tests yet"`
2. Types import correctly: `python -c "from operator_core.actions.types import WorkflowStatus, WorkflowProposal; print('Types OK')"`
3. Schema contains new tables: `python -c "from operator_core.db.schema import ACTIONS_SCHEMA_SQL; print('workflows' in ACTIONS_SCHEMA_SQL)"`
4. Database migration works: Create temp DB, verify columns exist
</verification>

<success_criteria>
1. ActionProposal has 8 new fields: workflow_id, execution_order, depends_on_proposal_id, scheduled_at, retry_count, max_retries, next_retry_at, last_error
2. WorkflowStatus enum has 5 states: pending, in_progress, completed, failed, cancelled
3. WorkflowProposal model exists with id, name, description, ticket_id, status, created_at
4. ACTIONS_SCHEMA_SQL includes workflows table and 3 new indexes
5. ActionDB migrations add columns without error on existing databases
6. _row_to_proposal correctly parses all new fields including datetime conversions
</success_criteria>

<output>
After completion, create `.planning/phases/15-workflow-actions/15-01-SUMMARY.md`
</output>
