---
phase: 15-workflow-actions
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/operator-core/src/operator_core/actions/tools.py
  - packages/operator-core/src/operator_core/actions/__init__.py
  - packages/operator-core/src/operator_core/actions/executor.py
autonomous: true

must_haves:
  truths:
    - "General tools exist beyond subject-defined actions"
    - "Wait tool pauses execution for specified duration"
    - "Log message tool records audit entry"
    - "Executor can execute general tools"
  artifacts:
    - path: "packages/operator-core/src/operator_core/actions/tools.py"
      provides: "General tool definitions and implementations"
      contains: "GENERAL_TOOLS"
    - path: "packages/operator-core/src/operator_core/actions/executor.py"
      provides: "Tool execution support"
      contains: "ActionType.TOOL"
  key_links:
    - from: "actions/tools.py"
      to: "actions/executor.py"
      via: "execute_tool called for ActionType.TOOL"
      pattern: "execute_tool|GENERAL_TOOLS"
---

<objective>
Implement general tools (wait, log_message) that work beyond subject-defined actions for ACT-03.

Purpose: This plan adds general-purpose tools that the agent can use regardless of the subject. The wait tool enables timed delays between actions (useful in workflows), and log_message enables explicit audit trail entries. These tools fulfill ACT-03: Agent can use general tools beyond subject-defined actions.

Output: tools.py module with GENERAL_TOOLS list, wait and log_message implementations, and executor support for ActionType.TOOL.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-workflow-actions/15-RESEARCH.md
@packages/operator-core/src/operator_core/actions/registry.py
@packages/operator-core/src/operator_core/actions/executor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create general tools module with wait and log_message</name>
  <files>packages/operator-core/src/operator_core/actions/tools.py, packages/operator-core/src/operator_core/actions/__init__.py</files>
  <action>
Create packages/operator-core/src/operator_core/actions/tools.py:

```python
"""
General-purpose tools for agent workflows.

This module provides tools that work independently of the subject,
enabling the agent to perform common operations like:
- Waiting between actions (for timing/pacing)
- Logging messages to the audit trail

Per ACT-03: Agent can use general tools beyond subject-defined actions.

These tools have ActionType.TOOL and are discoverable via get_general_tools().
"""

import asyncio
from datetime import datetime
from typing import Any

from operator_core.actions.registry import ActionDefinition, ParamDef
from operator_core.actions.types import ActionType


def get_general_tools() -> list[ActionDefinition]:
    """
    Get list of general-purpose tool definitions.

    These tools are available regardless of subject and can be used
    in any workflow for common operations.

    Returns:
        List of ActionDefinition for general tools
    """
    return [
        ActionDefinition(
            name="wait",
            description="Wait for a specified duration before continuing. Useful for timing between actions or waiting for systems to stabilize.",
            parameters={
                "seconds": ParamDef(
                    type="int",
                    description="Number of seconds to wait (1-300)",
                    required=True,
                ),
                "reason": ParamDef(
                    type="str",
                    description="Why we're waiting (for audit trail)",
                    required=False,
                ),
            },
            action_type=ActionType.TOOL,
            risk_level="low",
            requires_approval=False,
        ),
        ActionDefinition(
            name="log_message",
            description="Log a message to the audit trail. Useful for marking workflow progress or recording observations.",
            parameters={
                "message": ParamDef(
                    type="str",
                    description="Message to log",
                    required=True,
                ),
                "level": ParamDef(
                    type="str",
                    description="Log level: info, warning, error (default: info)",
                    required=False,
                ),
            },
            action_type=ActionType.TOOL,
            risk_level="low",
            requires_approval=False,
        ),
    ]


async def execute_wait(seconds: int, reason: str | None = None) -> dict[str, Any]:
    """
    Execute the wait tool.

    Pauses execution for the specified number of seconds.

    Args:
        seconds: Number of seconds to wait (capped at 300)
        reason: Optional reason for the wait

    Returns:
        Dict with wait duration and timestamp
    """
    # Cap at 5 minutes to prevent very long waits
    capped_seconds = min(seconds, 300)
    if capped_seconds != seconds:
        print(f"Wait capped from {seconds}s to {capped_seconds}s (max 300s)")

    start = datetime.now()
    print(f"Waiting {capped_seconds}s" + (f" ({reason})" if reason else ""))

    await asyncio.sleep(capped_seconds)

    return {
        "waited_seconds": capped_seconds,
        "reason": reason,
        "started_at": start.isoformat(),
        "completed_at": datetime.now().isoformat(),
    }


async def execute_log_message(
    message: str,
    level: str | None = None,
) -> dict[str, Any]:
    """
    Execute the log_message tool.

    Logs a message at the specified level.

    Args:
        message: Message to log
        level: Log level (info, warning, error)

    Returns:
        Dict with logged message and timestamp
    """
    level = level or "info"
    timestamp = datetime.now()

    # Print with level prefix
    prefix = {
        "info": "[INFO]",
        "warning": "[WARN]",
        "error": "[ERROR]",
    }.get(level.lower(), "[INFO]")

    print(f"{prefix} {message}")

    return {
        "message": message,
        "level": level,
        "timestamp": timestamp.isoformat(),
    }


# Map tool names to their execution functions
TOOL_EXECUTORS = {
    "wait": execute_wait,
    "log_message": execute_log_message,
}


async def execute_tool(tool_name: str, parameters: dict[str, Any]) -> Any:
    """
    Execute a general tool by name.

    Args:
        tool_name: Name of the tool to execute
        parameters: Parameters to pass to the tool

    Returns:
        Tool execution result

    Raises:
        ValueError: If tool not found
    """
    executor = TOOL_EXECUTORS.get(tool_name)
    if executor is None:
        raise ValueError(
            f"Unknown tool '{tool_name}'. "
            f"Available tools: {list(TOOL_EXECUTORS.keys())}"
        )

    return await executor(**parameters)
```

Add exports to actions/__init__.py:

```python
from operator_core.actions.tools import (
    execute_tool,
    get_general_tools,
    TOOL_EXECUTORS,
)
```
  </action>
  <verify>python -c "
from operator_core.actions.tools import get_general_tools, execute_tool
import asyncio

# Check tools defined
tools = get_general_tools()
print(f'General tools: {[t.name for t in tools]}')
assert len(tools) == 2
assert tools[0].name == 'wait'
assert tools[1].name == 'log_message'

# Test log_message (fast)
result = asyncio.run(execute_tool('log_message', {'message': 'test', 'level': 'info'}))
print(f'log_message result: {result}')
"</verify>
  <done>tools.py created with get_general_tools returning wait and log_message ActionDefinitions. execute_wait and execute_log_message async functions implemented. execute_tool dispatcher routes to correct function. Exports added to __init__.py.</done>
</task>

<task type="auto">
  <name>Task 2: Extend executor to support general tools</name>
  <files>packages/operator-core/src/operator_core/actions/executor.py</files>
  <action>
Add import for tools at top:

```python
from operator_core.actions.tools import execute_tool, get_general_tools
```

Modify execute_proposal to handle ActionType.TOOL differently. Find the execution block where it calls `method = getattr(subject, proposal.action_name, None)` and wrap it in a conditional:

Replace this section in execute_proposal (the try block that does execution):

```python
try:
    # Call subject method dynamically
    method = getattr(subject, proposal.action_name, None)
    if method is None:
        raise ValueError(
            f"Subject has no method '{proposal.action_name}'"
        )

    result = await method(**proposal.parameters)
    success = True
    result_data = {"result": result} if result is not None else None

except Exception as e:
    error_message = f"{type(e).__name__}: {e}"
```

With this updated version that handles both TOOL and SUBJECT types:

```python
try:
    if proposal.action_type == ActionType.TOOL:
        # Execute general tool
        result = await execute_tool(
            proposal.action_name,
            proposal.parameters,
        )
    else:
        # Execute subject method dynamically
        method = getattr(subject, proposal.action_name, None)
        if method is None:
            raise ValueError(
                f"Subject has no method '{proposal.action_name}'"
            )
        result = await method(**proposal.parameters)

    success = True
    result_data = {"result": result} if result is not None else None

except Exception as e:
    error_message = f"{type(e).__name__}: {e}"
```

Add method to get combined action definitions. Add after __init__:

```python
def get_all_definitions(self) -> list["ActionDefinition"]:
    """
    Get all available action definitions (subject + general tools).

    Returns:
        Combined list of ActionDefinition from registry and general tools
    """
    from operator_core.actions.registry import ActionDefinition

    subject_actions = self._registry.get_definitions()
    general_tools = get_general_tools()
    return subject_actions + general_tools
```

Modify propose_action to also accept general tools. In propose_action, after checking registry, add fallback to tools:

```python
# Validate action exists in registry or general tools
definition = self._registry.get_definition(recommendation.action_name)

# Check if it's a general tool
if definition is None:
    from operator_core.actions.tools import get_general_tools

    for tool in get_general_tools():
        if tool.name == recommendation.action_name:
            definition = tool
            break

if definition is None:
    raise ValueError(
        f"Unknown action '{recommendation.action_name}'. "
        f"Available actions: {self._registry.list_action_names()}"
    )
```

And update the action_type assignment to use the definition's type:

```python
# Create proposal
proposal = ActionProposal(
    ticket_id=ticket_id,
    action_name=recommendation.action_name,
    action_type=definition.action_type,  # Use definition's type, not hardcoded SUBJECT
    parameters=recommendation.parameters,
    reason=recommendation.reason,
    status=ActionStatus.PROPOSED,
    proposed_at=datetime.now(),
    proposed_by="agent",
)
```
  </action>
  <verify>python -c "
from operator_core.actions.executor import ActionExecutor
import inspect

# Check get_all_definitions exists
assert hasattr(ActionExecutor, 'get_all_definitions')
print('get_all_definitions method exists')

# Check execute_tool imported
source = inspect.getsource(ActionExecutor.execute_proposal)
assert 'ActionType.TOOL' in source or 'execute_tool' in source
print('execute_proposal handles ActionType.TOOL')
"</verify>
  <done>ActionExecutor.execute_proposal handles ActionType.TOOL by calling execute_tool instead of subject method. get_all_definitions returns combined subject actions and general tools. propose_action accepts general tools in addition to subject actions.</done>
</task>

</tasks>

<verification>
1. General tools defined: get_general_tools returns wait and log_message
2. Tool execution works: execute_tool('log_message', {...}) succeeds
3. Executor routes correctly: ActionType.TOOL goes to execute_tool
4. Combined definitions: get_all_definitions includes both subject and tools
5. propose_action accepts tools: Can propose wait action
</verification>

<success_criteria>
1. tools.py contains wait and log_message ActionDefinitions with ActionType.TOOL
2. execute_wait sleeps for specified seconds (capped at 300)
3. execute_log_message prints message with level prefix
4. execute_tool dispatches to correct executor function
5. ActionExecutor.execute_proposal handles ActionType.TOOL separately
6. ActionExecutor.get_all_definitions returns subject + general tools combined
7. ActionExecutor.propose_action accepts general tool recommendations
8. Tools don't require Subject for execution
</success_criteria>

<output>
After completion, create `.planning/phases/15-workflow-actions/15-05-SUMMARY.md`
</output>
