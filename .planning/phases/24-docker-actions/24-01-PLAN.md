---
phase: 24-docker-actions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/operator-core/src/operator_core/docker/__init__.py
  - packages/operator-core/src/operator_core/docker/actions.py
autonomous: true

must_haves:
  truths:
    - "DockerActionExecutor can start a stopped container"
    - "DockerActionExecutor can stop a running container with graceful shutdown"
    - "DockerActionExecutor can restart a container"
    - "DockerActionExecutor can inspect container status without modification"
    - "All operations use asyncio.run_in_executor for non-blocking execution"
  artifacts:
    - path: "packages/operator-core/src/operator_core/docker/__init__.py"
      provides: "Public API exports for Docker actions"
      exports: ["DockerActionExecutor"]
    - path: "packages/operator-core/src/operator_core/docker/actions.py"
      provides: "DockerActionExecutor class with lifecycle methods"
      min_lines: 100
      contains: "run_in_executor"
  key_links:
    - from: "packages/operator-core/src/operator_core/docker/actions.py"
      to: "python_on_whales"
      via: "import and method calls"
      pattern: "from python_on_whales import docker"
    - from: "packages/operator-core/src/operator_core/docker/actions.py"
      to: "asyncio"
      via: "run_in_executor wrapping"
      pattern: "loop\\.run_in_executor\\(None"
---

<objective>
Create DockerActionExecutor class with container lifecycle operations: start, stop, restart, and inspect.

Purpose: Foundation for agent Docker control. These four operations cover the core container lifecycle needed for remediation scenarios.
Output: New `docker/` module with DockerActionExecutor class implementing async wrappers around python-on-whales.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-docker-actions/24-RESEARCH.md

# Existing patterns
@packages/operator-core/src/operator_core/actions/tools.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DockerActionExecutor with lifecycle methods</name>
  <files>
    packages/operator-core/src/operator_core/docker/__init__.py
    packages/operator-core/src/operator_core/docker/actions.py
  </files>
  <action>
Create new `docker/` module under `operator_core/`:

1. **docker/__init__.py** - Export DockerActionExecutor:
   ```python
   from operator_core.docker.actions import DockerActionExecutor
   __all__ = ["DockerActionExecutor"]
   ```

2. **docker/actions.py** - Implement DockerActionExecutor class:

   - Import python_on_whales docker client (thread-safe, shared instance)
   - Import asyncio for run_in_executor pattern
   - Import NoSuchContainer exception from python_on_whales.exceptions

   **Class structure:**
   ```python
   class DockerActionExecutor:
       def __init__(self):
           self._docker = docker  # from python_on_whales
   ```

   **Methods (each wraps blocking call with run_in_executor):**

   a) `async def start_container(self, container_id: str) -> dict[str, Any]:`
      - DOCK-01: Start stopped container
      - Check if already running (idempotent)
      - Return dict with: container_id, name, state, running (bool)

   b) `async def stop_container(self, container_id: str, timeout: int = 10) -> dict[str, Any]:`
      - DOCK-02: Stop running container (graceful SIGTERM then SIGKILL)
      - Check if already stopped (idempotent)
      - Return dict with: container_id, name, state, exit_code, graceful_shutdown (bool), killed (bool)
      - Exit code 143 = graceful (SIGTERM), 137 = killed (SIGKILL/OOM)

   c) `async def restart_container(self, container_id: str, timeout: int = 10) -> dict[str, Any]:`
      - DOCK-03: Restart container (stop then start)
      - Return dict with: container_id, name, state, running (bool)

   d) `async def inspect_container(self, container_id: str) -> dict[str, Any]:`
      - DOCK-05: Read-only container inspection
      - Return dict with: id, name, image, state (status, running, paused, exit_code, started_at), networks list

   **Pattern for each method:**
   ```python
   async def method(self, container_id: str) -> dict[str, Any]:
       loop = asyncio.get_running_loop()

       def _blocking_operation():
           # python-on-whales calls here
           return result

       result = await loop.run_in_executor(None, _blocking_operation)
       return {"field": value, ...}
   ```

   **Important implementation details:**
   - Default timeout 10s for stop/restart (configurable via parameter)
   - Idempotent: start on running container returns success, stop on stopped container returns success
   - All datetime fields serialized with .isoformat()
   - Handle None values gracefully (started_at may be None)
  </action>
  <verify>
Run Python syntax check:
```bash
python -c "from operator_core.docker.actions import DockerActionExecutor; print('Import OK')"
```
  </verify>
  <done>
DockerActionExecutor class exists with start_container, stop_container, restart_container, and inspect_container methods. All methods use asyncio.run_in_executor pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for lifecycle operations</name>
  <files>
    packages/operator-core/tests/test_docker_actions.py
  </files>
  <action>
Create test file for DockerActionExecutor lifecycle operations.

**Test structure:**
```python
import pytest
from unittest.mock import MagicMock, patch, AsyncMock
from operator_core.docker.actions import DockerActionExecutor
```

**Mock strategy:** Patch `python_on_whales.docker` at module level since DockerActionExecutor imports it.

**Test cases:**

1. `test_start_container_success` - Mock container.start() and inspect(), verify return dict
2. `test_start_container_already_running` - Mock inspect() returning running=True, verify idempotent
3. `test_start_container_not_found` - Mock raising NoSuchContainer, verify exception propagates
4. `test_stop_container_success` - Mock container.stop() and inspect(), verify return dict
5. `test_stop_container_already_stopped` - Mock inspect() returning running=False, verify idempotent
6. `test_stop_container_graceful_exit` - Verify exit_code=143 sets graceful_shutdown=True
7. `test_stop_container_killed_exit` - Verify exit_code=137 sets killed=True
8. `test_restart_container_success` - Mock container.restart() and inspect(), verify return dict
9. `test_inspect_container_success` - Mock inspect(), verify all fields returned
10. `test_inspect_container_not_found` - Verify NoSuchContainer propagates

**Mock pattern:**
```python
@pytest.mark.asyncio
async def test_start_container_success():
    with patch('operator_core.docker.actions.docker') as mock_docker:
        mock_container = MagicMock()
        mock_container.id = "abc123"
        mock_container.name = "test-container"
        mock_container.state.status = "running"
        mock_container.state.running = True
        mock_docker.container.inspect.return_value = mock_container

        executor = DockerActionExecutor()
        result = await executor.start_container("test-container")

        assert result["container_id"] == "abc123"
        assert result["running"] is True
```
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator && python -m pytest packages/operator-core/tests/test_docker_actions.py -v
```
All tests pass.
  </verify>
  <done>
Test file exists with 10+ test cases covering start, stop, restart, and inspect operations including edge cases (idempotent behavior, exit codes, not found errors).
  </done>
</task>

</tasks>

<verification>
Overall verification after all tasks complete:

1. **Module structure:**
   ```bash
   ls -la packages/operator-core/src/operator_core/docker/
   # Should show __init__.py and actions.py
   ```

2. **Import verification:**
   ```bash
   python -c "from operator_core.docker import DockerActionExecutor; print(DockerActionExecutor)"
   ```

3. **Test suite:**
   ```bash
   python -m pytest packages/operator-core/tests/test_docker_actions.py -v
   ```

4. **Async pattern verification:**
   ```bash
   grep -c "run_in_executor" packages/operator-core/src/operator_core/docker/actions.py
   # Should return 4 (one per method)
   ```
</verification>

<success_criteria>
- DockerActionExecutor class created with 4 lifecycle methods
- All methods use asyncio.run_in_executor pattern (DOCK-09 partial)
- Tests cover success paths and edge cases (idempotent, exit codes, not found)
- All tests pass
- Requirements covered: DOCK-01, DOCK-02, DOCK-03, DOCK-05, DOCK-09 (partial)
</success_criteria>

<output>
After completion, create `.planning/phases/24-docker-actions/24-01-SUMMARY.md`
</output>
