---
phase: 24-docker-actions
plan: 02
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - packages/operator-core/src/operator_core/docker/actions.py
  - packages/operator-core/tests/test_docker_actions.py
autonomous: true

must_haves:
  truths:
    - "Agent can retrieve container logs with configurable tail limit"
    - "Tail limit enforced at max 10000 lines to prevent memory exhaustion"
    - "Agent can connect containers to Docker networks"
    - "Agent can disconnect containers from Docker networks"
    - "Agent can execute commands inside running containers"
    - "Network operations validate container and network existence"
  artifacts:
    - path: "packages/operator-core/src/operator_core/docker/actions.py"
      provides: "DockerActionExecutor with logs, network, and exec methods"
      min_lines: 200
      contains: "get_container_logs"
  key_links:
    - from: "packages/operator-core/src/operator_core/docker/actions.py"
      to: "docker.container.logs"
      via: "python-on-whales call"
      pattern: "self._docker\\.container\\.logs"
    - from: "packages/operator-core/src/operator_core/docker/actions.py"
      to: "docker.network.connect"
      via: "python-on-whales call"
      pattern: "self._docker\\.network\\.(connect|disconnect)"
---

<objective>
Add log retrieval, network operations, and command execution to DockerActionExecutor.

Purpose: Complete the Docker action capabilities needed for agent remediation workflows.
Output: DockerActionExecutor extended with get_container_logs, connect_container_to_network, disconnect_container_from_network, and execute_command methods.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-docker-actions/24-RESEARCH.md
@.planning/phases/24-docker-actions/24-01-SUMMARY.md

# Implementation from Plan 01
@packages/operator-core/src/operator_core/docker/actions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add logs, network, and exec methods to DockerActionExecutor</name>
  <files>
    packages/operator-core/src/operator_core/docker/actions.py
  </files>
  <action>
Extend DockerActionExecutor with four new methods:

**1. get_container_logs (DOCK-04):**
```python
async def get_container_logs(
    self,
    container_id: str,
    tail: int | None = None,
    since: str | None = None,
) -> dict[str, Any]:
```
- Default tail: 100 lines
- MAX tail: 10000 lines (enforced - cap silently)
- NEVER use follow=True (blocks indefinitely)
- Always timestamps=True for debugging
- Return: container_id, logs (full string), line_count, tail_limit, truncated (bool)

**2. connect_container_to_network (DOCK-06):**
```python
async def connect_container_to_network(
    self,
    container_id: str,
    network: str,
    alias: str | None = None,
) -> dict[str, Any]:
```
- Validate container exists first (better error message)
- Validate network exists via docker.network.exists()
- Raise descriptive error if network not found
- Return: container_id, network, alias, connected=True

**3. disconnect_container_from_network (DOCK-07):**
```python
async def disconnect_container_from_network(
    self,
    container_id: str,
    network: str,
    force: bool = False,
) -> dict[str, Any]:
```
- Return: container_id, network, disconnected=True

**4. execute_command (DOCK-08):**
```python
async def execute_command(
    self,
    container_id: str,
    command: list[str],
    user: str | None = None,
    workdir: str | None = None,
) -> dict[str, Any]:
```
- Execute with tty=False, interactive=False (programmatic access)
- Catch exceptions and return in error field
- Return: container_id, command, success (bool), output, error (str or None)

**Import additions:**
- Add NoSuchNetwork to imports from python_on_whales.exceptions

**Error handling pattern:**
For network operations, explicitly check existence and raise clear errors:
```python
if not self._docker.network.exists(network):
    raise ValueError(f"Network '{network}' not found")
```
  </action>
  <verify>
```bash
python -c "from operator_core.docker.actions import DockerActionExecutor; e = DockerActionExecutor(); print(hasattr(e, 'get_container_logs'), hasattr(e, 'execute_command'))"
```
Should print: True True
  </verify>
  <done>
DockerActionExecutor has get_container_logs, connect_container_to_network, disconnect_container_from_network, and execute_command methods. All use run_in_executor pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for logs, network, and exec operations</name>
  <files>
    packages/operator-core/tests/test_docker_actions.py
  </files>
  <action>
Extend test file with tests for new methods:

**Logs tests:**
1. `test_get_logs_default_tail` - Verify default tail=100
2. `test_get_logs_custom_tail` - Verify custom tail respected
3. `test_get_logs_max_tail_enforced` - Request 20000, verify capped to 10000
4. `test_get_logs_with_since` - Verify since parameter passed through
5. `test_get_logs_empty_container` - Verify handles empty logs gracefully

**Network tests:**
6. `test_connect_to_network_success` - Verify connect flow
7. `test_connect_network_not_found` - Verify descriptive error
8. `test_connect_container_not_found` - Verify NoSuchContainer propagates
9. `test_disconnect_from_network_success` - Verify disconnect flow
10. `test_disconnect_with_force` - Verify force parameter passed

**Exec tests:**
11. `test_execute_command_success` - Verify output captured
12. `test_execute_command_failure` - Verify error captured in error field
13. `test_execute_command_with_user` - Verify user parameter passed
14. `test_execute_command_with_workdir` - Verify workdir parameter passed

**Mock patterns:**
```python
# For logs
mock_docker.container.logs.return_value = "line1\nline2\nline3"

# For network
mock_docker.network.exists.return_value = True
mock_docker.network.connect.return_value = None

# For exec
mock_docker.container.execute.return_value = "command output"
```
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator && python -m pytest packages/operator-core/tests/test_docker_actions.py -v
```
All tests pass (should be 24+ tests now).
  </verify>
  <done>
Test file extended with 14+ new test cases covering logs (with tail enforcement), network operations (with validation errors), and exec (with output capture and error handling).
  </done>
</task>

</tasks>

<verification>
Overall verification after all tasks complete:

1. **Method count:**
   ```bash
   grep -E "^\s+async def" packages/operator-core/src/operator_core/docker/actions.py | wc -l
   # Should return 8 (4 from Plan 01 + 4 from Plan 02)
   ```

2. **Tail limit enforcement:**
   ```bash
   grep "MAX_TAIL = 10000" packages/operator-core/src/operator_core/docker/actions.py
   # Should find the constant
   ```

3. **Network validation:**
   ```bash
   grep "network.exists" packages/operator-core/src/operator_core/docker/actions.py
   # Should find existence check
   ```

4. **Test count:**
   ```bash
   python -m pytest packages/operator-core/tests/test_docker_actions.py --collect-only | grep "test_" | wc -l
   # Should be 24+ tests
   ```
</verification>

<success_criteria>
- DockerActionExecutor has 8 async methods total
- Logs enforce 10000 line max tail limit
- Network operations validate existence before action
- Exec captures output and errors
- All tests pass
- Requirements covered: DOCK-04, DOCK-06, DOCK-07, DOCK-08, DOCK-09 (continued)
</success_criteria>

<output>
After completion, create `.planning/phases/24-docker-actions/24-02-SUMMARY.md`
</output>
