---
phase: 24-docker-actions
plan: 03
type: execute
wave: 3
depends_on: ["24-02"]
files_modified:
  - packages/operator-core/src/operator_core/actions/tools.py
  - packages/operator-core/src/operator_core/docker/actions.py
  - packages/operator-core/tests/test_docker_actions.py
autonomous: true

must_haves:
  truths:
    - "Docker actions appear in get_general_tools() output"
    - "TOOL_EXECUTORS map contains all 8 Docker action executors"
    - "ActionType.TOOL used for all Docker action definitions"
    - "Docker actions can be proposed and executed through ActionExecutor"
  artifacts:
    - path: "packages/operator-core/src/operator_core/actions/tools.py"
      provides: "Docker action definitions and executor mapping"
      exports: ["get_general_tools", "TOOL_EXECUTORS"]
      contains: "docker_start_container"
    - path: "packages/operator-core/src/operator_core/docker/actions.py"
      provides: "get_docker_tools() function"
      exports: ["get_docker_tools"]
  key_links:
    - from: "packages/operator-core/src/operator_core/actions/tools.py"
      to: "packages/operator-core/src/operator_core/docker/actions.py"
      via: "import and tool aggregation"
      pattern: "from operator_core\\.docker\\.actions import"
    - from: "packages/operator-core/src/operator_core/actions/executor.py"
      to: "packages/operator-core/src/operator_core/actions/tools.py"
      via: "execute_tool for ActionType.TOOL"
      pattern: "execute_tool"
---

<objective>
Register Docker actions as ActionType.TOOL in the action framework for agent discovery and execution.

Purpose: Enable the agent to propose and execute Docker actions through the standard action workflow.
Output: Docker actions registered in get_general_tools() and TOOL_EXECUTORS, completing the integration.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-docker-actions/24-RESEARCH.md
@.planning/phases/24-docker-actions/24-02-SUMMARY.md

# Integration points
@packages/operator-core/src/operator_core/actions/tools.py
@packages/operator-core/src/operator_core/actions/executor.py
@packages/operator-core/src/operator_core/docker/actions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create get_docker_tools() function with ActionDefinition for each Docker action</name>
  <files>
    packages/operator-core/src/operator_core/docker/actions.py
  </files>
  <action>
Add get_docker_tools() function to docker/actions.py that returns ActionDefinition list.

**Add imports:**
```python
from operator_core.actions.registry import ActionDefinition, ParamDef
from operator_core.actions.types import ActionType
```

**Create function:**
```python
def get_docker_tools() -> list[ActionDefinition]:
    """
    Get Docker action tool definitions.

    Returns list of ActionDefinition for all Docker container operations.
    Per DOCK-10: All Docker actions register as ActionType.TOOL.
    """
    return [...]
```

**ActionDefinition for each Docker action (8 total):**

1. **docker_start_container** (DOCK-01):
   - description: "Start a stopped Docker container"
   - parameters: container_id (str, required)
   - risk_level: "medium"
   - requires_approval: True

2. **docker_stop_container** (DOCK-02):
   - description: "Stop a running Docker container gracefully (SIGTERM then SIGKILL after timeout)"
   - parameters: container_id (str, required), timeout (int, optional, default 10)
   - risk_level: "high"
   - requires_approval: True

3. **docker_restart_container** (DOCK-03):
   - description: "Restart a Docker container (stop then start)"
   - parameters: container_id (str, required), timeout (int, optional)
   - risk_level: "high"
   - requires_approval: True

4. **docker_logs** (DOCK-04):
   - description: "Retrieve container logs with tail limit (max 10000 lines)"
   - parameters: container_id (str, required), tail (int, optional), since (str, optional)
   - risk_level: "low"
   - requires_approval: False

5. **docker_inspect_container** (DOCK-05):
   - description: "Get container status and configuration (read-only)"
   - parameters: container_id (str, required)
   - risk_level: "low"
   - requires_approval: False

6. **docker_network_connect** (DOCK-06):
   - description: "Connect container to a Docker network"
   - parameters: container_id (str, required), network (str, required), alias (str, optional)
   - risk_level: "medium"
   - requires_approval: True

7. **docker_network_disconnect** (DOCK-07):
   - description: "Disconnect container from a Docker network"
   - parameters: container_id (str, required), network (str, required), force (bool, optional)
   - risk_level: "medium"
   - requires_approval: True

8. **docker_exec** (DOCK-08):
   - description: "Execute command inside a running container with output capture"
   - parameters: container_id (str, required), command (list, required), user (str, optional), workdir (str, optional)
   - risk_level: "high"
   - requires_approval: True

**Risk level rationale (from research):**
- LOW: Read-only (logs, inspect)
- MEDIUM: State change but recoverable (start, network)
- HIGH: Availability impact or arbitrary execution (stop, restart, exec)

**Update __init__.py export:**
```python
from operator_core.docker.actions import DockerActionExecutor, get_docker_tools
__all__ = ["DockerActionExecutor", "get_docker_tools"]
```
  </action>
  <verify>
```bash
python -c "from operator_core.docker.actions import get_docker_tools; tools = get_docker_tools(); print(f'{len(tools)} Docker tools defined'); print([t.name for t in tools])"
```
Should print 8 tools with correct names.
  </verify>
  <done>
get_docker_tools() returns list of 8 ActionDefinition objects with correct names, parameters, risk levels, and ActionType.TOOL.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate Docker tools into tools.py and TOOL_EXECUTORS</name>
  <files>
    packages/operator-core/src/operator_core/actions/tools.py
  </files>
  <action>
Modify tools.py to include Docker actions in the tool framework.

**1. Update get_general_tools():**
```python
def get_general_tools() -> list[ActionDefinition]:
    """Get all general-purpose tool definitions including Docker actions."""
    from operator_core.docker.actions import get_docker_tools

    base_tools = [
        # existing wait and log_message definitions...
    ]

    docker_tools = get_docker_tools()

    return base_tools + docker_tools
```

**2. Add Docker executor instance and mappings to TOOL_EXECUTORS:**
```python
from operator_core.docker.actions import DockerActionExecutor

# Lazy initialization to avoid import issues
_docker_executor: DockerActionExecutor | None = None

def _get_docker_executor() -> DockerActionExecutor:
    global _docker_executor
    if _docker_executor is None:
        _docker_executor = DockerActionExecutor()
    return _docker_executor
```

**3. Extend TOOL_EXECUTORS map:**
```python
TOOL_EXECUTORS = {
    # Existing tools
    "wait": execute_wait,
    "log_message": execute_log_message,
    # Docker tools
    "docker_start_container": lambda **kw: _get_docker_executor().start_container(**kw),
    "docker_stop_container": lambda **kw: _get_docker_executor().stop_container(**kw),
    "docker_restart_container": lambda **kw: _get_docker_executor().restart_container(**kw),
    "docker_logs": lambda **kw: _get_docker_executor().get_container_logs(**kw),
    "docker_inspect_container": lambda **kw: _get_docker_executor().inspect_container(**kw),
    "docker_network_connect": lambda **kw: _get_docker_executor().connect_container_to_network(**kw),
    "docker_network_disconnect": lambda **kw: _get_docker_executor().disconnect_container_from_network(**kw),
    "docker_exec": lambda **kw: _get_docker_executor().execute_command(**kw),
}
```

**Important:** Use lambdas wrapping method calls to handle the lazy executor pattern. The executor is instantiated on first use.
  </action>
  <verify>
```bash
python -c "from operator_core.actions.tools import TOOL_EXECUTORS, get_general_tools; print(f'{len(TOOL_EXECUTORS)} executors'); print(f'{len(get_general_tools())} definitions'); docker_tools = [t for t in get_general_tools() if t.name.startswith('docker_')]; print(f'{len(docker_tools)} Docker tools')"
```
Should print: 10 executors, 10 definitions, 8 Docker tools
  </verify>
  <done>
get_general_tools() includes 8 Docker tools. TOOL_EXECUTORS maps all 8 Docker action names to executor methods.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add integration tests for Docker action proposal and execution</name>
  <files>
    packages/operator-core/tests/test_docker_actions.py
  </files>
  <action>
Add integration tests verifying Docker actions work through the action framework.

**New test class: TestDockerActionIntegration**

```python
class TestDockerActionIntegration:
    """Tests for Docker action integration with action framework."""

    def test_docker_tools_in_general_tools(self):
        """Docker tools should appear in get_general_tools()."""
        from operator_core.actions.tools import get_general_tools

        tools = get_general_tools()
        docker_tools = [t for t in tools if t.name.startswith("docker_")]

        assert len(docker_tools) == 8
        docker_names = {t.name for t in docker_tools}
        assert "docker_start_container" in docker_names
        assert "docker_stop_container" in docker_names
        assert "docker_logs" in docker_names
        assert "docker_exec" in docker_names

    def test_docker_tools_have_correct_action_type(self):
        """All Docker tools should have ActionType.TOOL."""
        from operator_core.actions.tools import get_general_tools
        from operator_core.actions.types import ActionType

        tools = get_general_tools()
        docker_tools = [t for t in tools if t.name.startswith("docker_")]

        for tool in docker_tools:
            assert tool.action_type == ActionType.TOOL

    def test_docker_executors_in_tool_executors(self):
        """All Docker actions should have executors registered."""
        from operator_core.actions.tools import TOOL_EXECUTORS

        expected_docker_actions = [
            "docker_start_container",
            "docker_stop_container",
            "docker_restart_container",
            "docker_logs",
            "docker_inspect_container",
            "docker_network_connect",
            "docker_network_disconnect",
            "docker_exec",
        ]

        for action_name in expected_docker_actions:
            assert action_name in TOOL_EXECUTORS, f"Missing executor for {action_name}"

    @pytest.mark.asyncio
    async def test_execute_tool_dispatches_to_docker(self):
        """execute_tool should dispatch Docker actions to DockerActionExecutor."""
        from operator_core.actions.tools import execute_tool

        with patch('operator_core.docker.actions.docker') as mock_docker:
            mock_container = MagicMock()
            mock_container.id = "test123"
            mock_container.name = "test-container"
            mock_container.state.status = "running"
            mock_container.state.running = True
            mock_container.state.paused = False
            mock_container.state.exit_code = 0
            mock_container.state.started_at = None
            mock_container.config.image = "test-image"
            mock_container.network_settings.networks = {}
            mock_docker.container.inspect.return_value = mock_container

            result = await execute_tool(
                "docker_inspect_container",
                {"container_id": "test-container"}
            )

            assert result["id"] == "test123"
            assert result["name"] == "test-container"
```

**Risk level tests:**
```python
    def test_docker_logs_is_low_risk(self):
        """docker_logs should be LOW risk (read-only)."""
        from operator_core.docker.actions import get_docker_tools

        logs_tool = next(t for t in get_docker_tools() if t.name == "docker_logs")
        assert logs_tool.risk_level == "low"
        assert logs_tool.requires_approval is False

    def test_docker_stop_is_high_risk(self):
        """docker_stop_container should be HIGH risk (availability impact)."""
        from operator_core.docker.actions import get_docker_tools

        stop_tool = next(t for t in get_docker_tools() if t.name == "docker_stop_container")
        assert stop_tool.risk_level == "high"
        assert stop_tool.requires_approval is True
```
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator && python -m pytest packages/operator-core/tests/test_docker_actions.py -v -k "Integration or risk"
```
All integration and risk level tests pass.
  </verify>
  <done>
Integration tests verify: 8 Docker tools in get_general_tools(), all have ActionType.TOOL, all mapped in TOOL_EXECUTORS, execute_tool dispatches correctly, risk levels are correct.
  </done>
</task>

</tasks>

<verification>
Overall verification after all tasks complete:

1. **Full tool count:**
   ```bash
   python -c "from operator_core.actions.tools import get_general_tools; print(len(get_general_tools()))"
   # Should return 10 (2 base + 8 Docker)
   ```

2. **Executor count:**
   ```bash
   python -c "from operator_core.actions.tools import TOOL_EXECUTORS; print(len(TOOL_EXECUTORS))"
   # Should return 10
   ```

3. **ActionType verification:**
   ```bash
   python -c "from operator_core.actions.tools import get_general_tools; from operator_core.actions.types import ActionType; docker = [t for t in get_general_tools() if t.name.startswith('docker_')]; assert all(t.action_type == ActionType.TOOL for t in docker); print('All TOOL type')"
   ```

4. **Full test suite:**
   ```bash
   python -m pytest packages/operator-core/tests/test_docker_actions.py -v
   # All tests pass (30+ tests)
   ```

5. **Existing tests still pass:**
   ```bash
   python -m pytest packages/operator-core/tests/ -v
   # All tests pass
   ```
</verification>

<success_criteria>
- get_docker_tools() returns 8 ActionDefinition objects
- get_general_tools() includes all Docker tools (DOCK-10)
- TOOL_EXECUTORS maps all 8 Docker action names
- All Docker actions have ActionType.TOOL
- Risk levels correctly assigned (low for read-only, high for exec/stop)
- Integration tests pass
- All existing tests pass
- Requirements covered: DOCK-09 (all use run_in_executor), DOCK-10 (registered as TOOL)
</success_criteria>

<output>
After completion, create `.planning/phases/24-docker-actions/24-03-SUMMARY.md`
</output>
