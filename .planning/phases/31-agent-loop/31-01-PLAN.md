---
phase: 31-agent-loop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/operator-core/src/operator_core/agent_lab/loop.py
  - packages/operator-core/src/operator_core/agent_lab/prompts.py
  - packages/operator-core/src/operator_core/agent_lab/__init__.py
  - packages/operator-core/src/operator_core/db/schema.py
  - packages/operator-core/src/operator_core/db/audit_log.py
autonomous: true

must_haves:
  truths:
    - "Agent polls database for open tickets every 1 second"
    - "Claude receives ticket and can call shell tool to investigate/fix"
    - "Tool results are summarized by Haiku before logging"
    - "Session ends when Claude declares done or stop_reason is end_turn"
    - "Resolved tickets are marked resolved with Claude's summary"
    - "Failed sessions escalate ticket to needs-human-attention"
    - "Complete audit trail stored in database"
    - "Core loop.py is under 200 lines"
  artifacts:
    - path: "packages/operator-core/src/operator_core/agent_lab/loop.py"
      provides: "Core agent loop with tool_runner"
      min_lines: 100
      max_lines: 200
    - path: "packages/operator-core/src/operator_core/agent_lab/prompts.py"
      provides: "SRE system prompt"
      contains: "SYSTEM_PROMPT"
    - path: "packages/operator-core/src/operator_core/db/audit_log.py"
      provides: "Database audit log storage"
      exports: ["AuditLogDB"]
    - path: "packages/operator-core/src/operator_core/db/schema.py"
      provides: "agent_sessions and agent_log_entries tables"
      contains: "agent_sessions"
  key_links:
    - from: "loop.py"
      to: "tool_runner"
      via: "client.beta.messages.tool_runner()"
      pattern: "tool_runner"
    - from: "loop.py"
      to: "shell()"
      via: "@beta_tool decorator"
      pattern: "@beta_tool"
    - from: "loop.py"
      to: "AuditLogDB"
      via: "log session entries"
      pattern: "AuditLogDB"
    - from: "loop.py"
      to: "TicketDB"
      via: "poll and update tickets"
      pattern: "TicketDB"
    - from: "loop.py"
      to: "Haiku summarization"
      via: "client.messages.create with Haiku model"
      pattern: "claude-haiku"
---

<objective>
Implement the ~200 line core agent loop that polls the database for tickets, runs Claude with shell tool access via tool_runner, summarizes outputs with Haiku, and stores complete audit trails in the database.

Purpose: This is the heart of the v3.0 Operator Laboratory - the conversation loop that lets Claude autonomously investigate and fix issues using shell commands.

Output:
- `loop.py` - Core agent loop using tool_runner (~150-180 lines)
- `prompts.py` - SRE system prompt
- `audit_log.py` - Database audit log storage
- Schema additions for agent_sessions and agent_log_entries tables
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-core-agent/30-01-SUMMARY.md
@.planning/phases/31-agent-loop/31-CONTEXT.md
@.planning/phases/31-agent-loop/31-RESEARCH.md

# Existing code to integrate with
@packages/operator-core/src/operator_core/agent_lab/tools.py
@packages/operator-core/src/operator_core/agent_lab/audit.py
@packages/operator-core/src/operator_core/db/tickets.py
@packages/operator-core/src/operator_core/db/schema.py
@packages/operator-core/src/operator_core/monitor/types.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add audit schema and AuditLogDB</name>
  <files>
    packages/operator-core/src/operator_core/db/schema.py
    packages/operator-core/src/operator_core/db/audit_log.py
  </files>
  <action>
Add agent session audit tables to schema.py:

1. Add to SCHEMA_SQL (before the final `"""`) - two new tables:
   - `agent_sessions` table:
     - id INTEGER PRIMARY KEY AUTOINCREMENT
     - session_id TEXT NOT NULL UNIQUE (format: {timestamp}-{uuid[:8]})
     - ticket_id INTEGER (FK to tickets)
     - status TEXT NOT NULL DEFAULT 'running' (running, completed, failed, escalated)
     - started_at TEXT NOT NULL
     - ended_at TEXT
     - outcome_summary TEXT (Claude's final summary, Haiku-summarized)
     - created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
   - `agent_log_entries` table:
     - id INTEGER PRIMARY KEY AUTOINCREMENT
     - session_id TEXT NOT NULL (FK to agent_sessions.session_id)
     - entry_type TEXT NOT NULL (reasoning, tool_call, tool_result)
     - content TEXT NOT NULL (the summarized content)
     - raw_content TEXT (optional: full content before summarization)
     - tool_name TEXT (for tool_call/tool_result entries)
     - tool_params TEXT (JSON for tool_call)
     - exit_code INTEGER (for tool_result)
     - timestamp TEXT NOT NULL
     - created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP

2. Add indexes:
   - idx_agent_sessions_ticket ON agent_sessions(ticket_id)
   - idx_agent_sessions_status ON agent_sessions(status)
   - idx_agent_log_entries_session ON agent_log_entries(session_id)

3. Create `audit_log.py` with AuditLogDB class:
   - Async context manager pattern (like TicketDB)
   - Methods:
     - `create_session(ticket_id: int) -> str` - returns session_id
     - `log_entry(session_id: str, entry_type: str, content: str, raw_content: str | None, tool_name: str | None, tool_params: dict | None, exit_code: int | None) -> int`
     - `complete_session(session_id: str, status: str, outcome_summary: str) -> None`
     - `get_session_entries(session_id: str) -> list[dict]` - for replay/review
  </action>
  <verify>
Run python -c "from operator_core.db.audit_log import AuditLogDB; print('Import OK')"
Run python -c "from operator_core.db.schema import SCHEMA_SQL; assert 'agent_sessions' in SCHEMA_SQL; print('Schema OK')"
  </verify>
  <done>
AuditLogDB class can create sessions, log entries, and complete sessions. Schema includes agent_sessions and agent_log_entries tables with proper indexes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SRE system prompt</name>
  <files>
    packages/operator-core/src/operator_core/agent_lab/prompts.py
  </files>
  <action>
Create prompts.py with the SRE agent system prompt.

Per CONTEXT.md decisions:
- Position Claude as SRE operator
- Minimal hints about tools ("you have shell access")
- Let Claude discover what's available

SYSTEM_PROMPT should:
1. Establish role: "You are an SRE operator responsible for diagnosing and fixing infrastructure issues."
2. Explain context: "You will receive a ticket describing an issue. Your job is to investigate and resolve it."
3. Mention capabilities: "You have shell access to the environment. You can run any command needed to diagnose and fix issues."
4. Set expectations: "When you've resolved the issue or determined you cannot fix it, clearly state your conclusion and what was done."
5. Encourage autonomy: "Trust your judgment. Query metrics, check logs, restart services - do what an experienced SRE would do."

Also add HAIKU_SUMMARIZE_PROMPT for summarization:
"Summarize this in 1-2 concise sentences, capturing the key action or finding. Be brief."

Keep the prompt focused and under 500 words - let Claude figure out the specifics.
  </action>
  <verify>
Run python -c "from operator_core.agent_lab.prompts import SYSTEM_PROMPT, HAIKU_SUMMARIZE_PROMPT; print(f'System prompt: {len(SYSTEM_PROMPT)} chars'); print(f'Haiku prompt: {len(HAIKU_SUMMARIZE_PROMPT)} chars')"
Verify SYSTEM_PROMPT mentions shell access and SRE role.
  </verify>
  <done>
prompts.py exports SYSTEM_PROMPT (SRE agent prompt) and HAIKU_SUMMARIZE_PROMPT (summarization prompt). Both are concise and focused.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement core agent loop</name>
  <files>
    packages/operator-core/src/operator_core/agent_lab/loop.py
    packages/operator-core/src/operator_core/agent_lab/__init__.py
  </files>
  <action>
Create loop.py with the core agent loop. Target: ~150-180 lines (MUST be under 200).

Use patterns from RESEARCH.md:

1. Imports and setup (~15 lines):
   - anthropic, time, subprocess
   - from anthropic import beta_tool
   - from .prompts import SYSTEM_PROMPT, HAIKU_SUMMARIZE_PROMPT
   - from operator_core.db.tickets import TicketDB
   - from operator_core.db.audit_log import AuditLogDB
   - from pathlib import Path

2. Shell tool with @beta_tool decorator (~20 lines):
   **IMPORTANT: Create a NEW synchronous shell() function in loop.py. The Phase 30 async shell() in tools.py cannot be used with @beta_tool because tool_runner requires synchronous tool functions.**
   ```python
   @beta_tool
   def shell(command: str, reasoning: str) -> str:
       """Execute a shell command.

       Args:
           command: Shell command to execute
           reasoning: Why you're running this command
       """
       result = subprocess.run(command, shell=True, capture_output=True, timeout=120)
       output = result.stdout.decode('utf-8', errors='replace')
       if result.returncode != 0:
           output += f"\nSTDERR: {result.stderr.decode('utf-8', errors='replace')}"
           output += f"\nExit code: {result.returncode}"
       return output
   ```
   Note: This is a NEW synchronous shell() for tool_runner. The Phase 30 async version in tools.py remains for backwards compatibility but is not used here.

3. Haiku summarization helper (~15 lines):
   ```python
   def summarize_with_haiku(client: anthropic.Anthropic, text: str) -> str:
       """Summarize text using Haiku for concise audit logs."""
       if len(text) < 100:  # Don't summarize short text
           return text
       response = client.messages.create(
           model="claude-haiku-4-5-20250929",
           max_tokens=150,
           messages=[{"role": "user", "content": f"{HAIKU_SUMMARIZE_PROMPT}\n\n{text}"}]
       )
       return response.content[0].text
   ```

4. Process ticket function (~50 lines):
   ```python
   def process_ticket(client: anthropic.Anthropic, ticket, audit_db: AuditLogDB, session_id: str) -> tuple[str, str]:
       """Process a single ticket with Claude. Returns (status, summary)."""

       # Build ticket description for Claude
       ticket_text = f"Ticket #{ticket.id}: {ticket.invariant_name}\n{ticket.message}"
       if ticket.metric_snapshot:
           ticket_text += f"\nMetrics: {ticket.metric_snapshot}"

       # Create tool_runner
       runner = client.beta.messages.tool_runner(
           model="claude-opus-4-20250514",
           max_tokens=8192,
           tools=[shell],
           system=SYSTEM_PROMPT,
           messages=[{"role": "user", "content": ticket_text}]
       )

       final_message = None
       for message in runner:
           # Log Claude's reasoning (summarized)
           if message.content:
               for block in message.content:
                   if hasattr(block, 'text') and block.text:
                       summary = summarize_with_haiku(client, block.text)
                       audit_db.log_entry(session_id, "reasoning", summary, block.text, None, None, None)
                       print(f"[Claude] {summary}")  # Verbose console output
           final_message = message

       # Determine outcome
       if final_message and final_message.stop_reason == "end_turn":
           summary_text = final_message.content[0].text if final_message.content else "Completed"
           summary = summarize_with_haiku(client, summary_text)
           return "resolved", summary
       else:
           return "escalated", f"Session ended with stop_reason: {final_message.stop_reason if final_message else 'unknown'}"
   ```

5. Main run loop (~40 lines):
   ```python
   def run_agent_loop(db_path: Path, audit_dir: Path | None = None):
       """Run the agent polling loop. Blocks forever (or until interrupted)."""
       client = anthropic.Anthropic()  # Uses ANTHROPIC_API_KEY env var

       print("Agent loop starting. Polling for tickets...")

       while True:
           # Use sync wrapper for async TicketDB - run in new event loop
           # Or: use synchronous sqlite3 directly for simplicity
           ticket = poll_for_open_ticket(db_path)

           if ticket:
               print(f"\n{'='*60}")
               print(f"Processing ticket #{ticket.id}: {ticket.invariant_name}")
               print(f"{'='*60}\n")

               # Create audit session
               with AuditLogDB(db_path) as audit_db:
                   session_id = audit_db.create_session(ticket.id)

                   try:
                       status, summary = process_ticket(client, ticket, audit_db, session_id)
                       audit_db.complete_session(session_id, status, summary)

                       # Update ticket
                       if status == "resolved":
                           update_ticket_resolved(db_path, ticket.id, summary)
                       else:
                           update_ticket_escalated(db_path, ticket.id, summary)

                       print(f"\nTicket #{ticket.id} -> {status}")
                       print(f"Summary: {summary}\n")

                   except Exception as e:
                       audit_db.complete_session(session_id, "failed", str(e))
                       print(f"Error processing ticket: {e}")

           time.sleep(1)
   ```

6. Helper functions for sync database access (~30 lines):
   - `poll_for_open_ticket(db_path)` - sync query for one open ticket
   - `update_ticket_resolved(db_path, ticket_id, summary)` - mark resolved
   - `update_ticket_escalated(db_path, ticket_id, summary)` - mark needs attention

Important implementation notes:
- Use sync subprocess (not async) because tool_runner expects sync tool functions
- Use sync sqlite3 (not aiosqlite) for the polling loop to keep it simple
- AuditLogDB should also be sync (context manager, not async context manager)
- Print verbose output during processing per CONTEXT.md
- Keep total lines under 200!

Update __init__.py to export:
- shell (keep existing)
- SessionAuditor (keep existing for backwards compatibility)
- run_agent_loop (new)
- SYSTEM_PROMPT (new)
  </action>
  <verify>
Run python -c "from operator_core.agent_lab import run_agent_loop, SYSTEM_PROMPT; print('Import OK')"
Count lines: wc -l packages/operator-core/src/operator_core/agent_lab/loop.py (must be under 200)
  </verify>
  <done>
Core agent loop implemented with:
1. @beta_tool shell function for tool_runner
2. Haiku summarization for audit logs
3. Polling loop with 1-second interval
4. Verbose console output
5. Database audit logging
6. Ticket status updates (resolved or escalated)
Total lines under 200.
  </done>
</task>

</tasks>

<verification>
1. All imports work:
   ```bash
   cd packages/operator-core
   python -c "from operator_core.agent_lab import run_agent_loop, shell, SYSTEM_PROMPT"
   python -c "from operator_core.db.audit_log import AuditLogDB"
   ```

2. Schema includes new tables:
   ```bash
   python -c "from operator_core.db.schema import SCHEMA_SQL; print('agent_sessions' in SCHEMA_SQL and 'agent_log_entries' in SCHEMA_SQL)"
   ```

3. Line count under 200:
   ```bash
   wc -l packages/operator-core/src/operator_core/agent_lab/loop.py
   # Should be < 200
   ```

4. Core loop structure matches design:
   - Uses tool_runner (not manual message loop)
   - Uses @beta_tool decorator
   - Polls every 1 second
   - Summarizes with Haiku
   - Logs to database
</verification>

<success_criteria>
1. `run_agent_loop()` function exists and is importable
2. Shell tool uses @beta_tool decorator for tool_runner compatibility
3. Agent polls database every 1 second for open tickets
4. Claude's reasoning and tool outputs are summarized by Haiku before logging
5. Complete audit trail stored in agent_sessions and agent_log_entries tables
6. Resolved tickets marked as resolved with summary
7. Failed sessions escalate ticket (new status or diagnosis field)
8. Core loop.py is under 200 lines
9. Verbose console output shows Claude's reasoning and tool calls
</success_criteria>

<output>
After completion, create `.planning/phases/31-agent-loop/31-01-SUMMARY.md` using the summary template.
</output>
