---
phase: 18-docker-compose
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/ratelimiter-service/Dockerfile
  - docker/docker-compose.yml
  - docker/.env.example
autonomous: true

must_haves:
  truths:
    - "docker-compose up starts Redis and 3 rate limiter nodes"
    - "Each rate limiter node connects to Redis successfully"
    - "Prometheus scrapes metrics from all 3 nodes"
    - "Services wait for dependencies via healthchecks"
  artifacts:
    - path: "packages/ratelimiter-service/Dockerfile"
      provides: "Container image for rate limiter service"
      contains: "python:3.11-slim-bookworm"
    - path: "docker/docker-compose.yml"
      provides: "Multi-service orchestration"
      contains: "ratelimiter-1"
    - path: "docker/.env.example"
      provides: "Port configuration template"
      contains: "RATELIMITER_1_PORT"
  key_links:
    - from: "docker-compose.yml"
      to: "packages/ratelimiter-service/Dockerfile"
      via: "build context"
      pattern: "build:.*context:.*packages/ratelimiter-service"
    - from: "ratelimiter services"
      to: "redis service"
      via: "depends_on with condition"
      pattern: "condition: service_healthy"
    - from: "prometheus"
      to: "ratelimiter nodes"
      via: "scrape config targets"
      pattern: "ratelimiter-[123]:8000"
---

<objective>
Create Docker Compose environment with Redis, 3 rate limiter nodes, and Prometheus

Purpose: Enable reproducible development environment for the rate limiter cluster where `docker-compose up` brings up the entire stack with proper service dependencies and health checks.

Output: Working docker-compose.yml that orchestrates Redis, 3 rate limiter instances, and Prometheus with proper startup ordering and metric scraping.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-docker-compose/18-RESEARCH.md
@.planning/phases/18-docker-compose/18-CONTEXT.md
@packages/ratelimiter-service/pyproject.toml
@packages/ratelimiter-service/src/ratelimiter_service/main.py
@packages/ratelimiter-service/src/ratelimiter_service/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Dockerfile for rate limiter service</name>
  <files>packages/ratelimiter-service/Dockerfile</files>
  <action>
Create Dockerfile in packages/ratelimiter-service/ following FastAPI Docker best practices:

1. Base image: python:3.11-slim-bookworm (matches project requires-python, slim for smaller image)
2. WORKDIR /app
3. Install curl for healthcheck (apt-get install -y --no-install-recommends curl, clean up apt lists)
4. Copy pyproject.toml first for layer caching, then pip install --no-cache-dir .
5. Copy src/ directory
6. EXPOSE 8000
7. Use exec form CMD: ["uvicorn", "ratelimiter_service.main:app", "--host", "0.0.0.0", "--port", "8000"]

Critical patterns from research:
- Use exec form CMD (not shell form) for graceful shutdown signal handling
- Install curl because python:slim-bookworm does not include it (healthcheck needs it)
- No --reload flag in container (production mode)
  </action>
  <verify>
docker build -t ratelimiter-service-test packages/ratelimiter-service/ should complete without errors
  </verify>
  <done>Dockerfile builds successfully and produces working container image</done>
</task>

<task type="auto">
  <name>Task 2: Create docker-compose.yml with Redis, nodes, and Prometheus</name>
  <files>docker/docker-compose.yml</files>
  <action>
Create docker/docker-compose.yml with all services:

**Structure (from research):**
1. configs section with inline prometheus_config (no separate file)
2. services: redis, ratelimiter-1, ratelimiter-2, ratelimiter-3, prometheus
3. networks: single ratelimiter network (bridge driver)

**Redis service:**
- image: redis:7-alpine
- healthcheck: ["CMD", "redis-cli", "ping"] with interval 5s, timeout 3s, retries 3, start_period 5s
- network: ratelimiter

**Rate limiter services (3 instances):**
- build context: ../packages/ratelimiter-service
- environment variables for each node:
  - RATELIMITER_REDIS_URL=redis://redis:6379
  - RATELIMITER_NODE_ID=node-{N}
  - RATELIMITER_NODE_HOST=ratelimiter-{N}
  - RATELIMITER_NODE_PORT=8000
- ports: "${RATELIMITER_{N}_PORT:-800{N}}:8000" (use env vars with defaults 8001, 8002, 8003)
- depends_on redis with condition: service_healthy
- healthcheck: ["CMD", "curl", "-f", "http://localhost:8000/health"] with interval 10s, timeout 5s, retries 3, start_period 10s
- restart: "no" (dev environment - show failures)
- network: ratelimiter

**Prometheus service:**
- image: prom/prometheus:v2.50.0
- command: ['--config.file=/etc/prometheus/prometheus.yml']
- configs: prometheus_config mapped to /etc/prometheus/prometheus.yml
- ports: "${PROMETHEUS_PORT:-9090}:9090"
- depends_on all 3 ratelimiter services with condition: service_healthy
- network: ratelimiter

**Inline Prometheus config:**
```yaml
configs:
  prometheus_config:
    content: |
      global:
        scrape_interval: 15s
        evaluation_interval: 15s
      scrape_configs:
        - job_name: 'ratelimiter'
          static_configs:
            - targets:
              - ratelimiter-1:8000
              - ratelimiter-2:8000
              - ratelimiter-3:8000
```

Do NOT include version: field (deprecated in Compose v2).
  </action>
  <verify>
cd docker && docker compose config should validate the compose file without errors
  </verify>
  <done>docker-compose.yml validates and defines all required services with proper dependencies</done>
</task>

<task type="auto">
  <name>Task 3: Create .env.example with port configuration</name>
  <files>docker/.env.example</files>
  <action>
Create docker/.env.example as a template for configurable ports:

```
# Rate Limiter Service Ports
# Each rate limiter node exposes its health and API on a separate host port
RATELIMITER_1_PORT=8001
RATELIMITER_2_PORT=8002
RATELIMITER_3_PORT=8003

# Prometheus Port
PROMETHEUS_PORT=9090
```

Add a comment at the top explaining:
- Copy to .env to customize
- Default values are shown
- Change ports if conflicts with local services
  </action>
  <verify>
File exists at docker/.env.example with documented port variables
  </verify>
  <done>.env.example provides documented template for port configuration</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Build passes: `docker build -t ratelimiter-service packages/ratelimiter-service/`
2. Compose validates: `cd docker && docker compose config`
3. Stack starts: `cd docker && docker compose up -d` brings up redis, 3 ratelimiter nodes, prometheus
4. All services healthy: `docker compose ps` shows all services as "healthy"
5. Prometheus scrapes: Visit http://localhost:9090/targets shows all 3 ratelimiter targets UP
</verification>

<success_criteria>
- Dockerfile builds rate limiter service image
- docker-compose.yml orchestrates Redis, 3 rate limiter nodes, Prometheus
- Health checks ensure proper startup ordering
- Prometheus scrapes all nodes successfully
- Ports configurable via .env file
</success_criteria>

<output>
After completion, create `.planning/phases/18-docker-compose/18-01-SUMMARY.md`
</output>
