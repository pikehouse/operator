---
phase: 14-approval-workflow
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - packages/operator-core/src/operator_core/actions/executor.py
  - packages/operator-core/src/operator_core/cli/actions.py
autonomous: true

must_haves:
  truths:
    - "With OPERATOR_APPROVAL_MODE=false (default), actions execute immediately after validation"
    - "With OPERATOR_APPROVAL_MODE=true, validated actions wait for human approval before execution"
    - "User can approve a validated proposal via CLI"
    - "User can reject a validated proposal via CLI with reason"
  artifacts:
    - path: "packages/operator-core/src/operator_core/actions/executor.py"
      provides: "approval gate check and ApprovalRequiredError"
      exports: ["ApprovalRequiredError"]
      contains: "_requires_approval"
    - path: "packages/operator-core/src/operator_core/cli/actions.py"
      provides: "approve and reject CLI commands"
      contains: "@actions_app.command(\"approve\")"
  key_links:
    - from: "executor.py"
      to: "os.environ"
      via: "OPERATOR_APPROVAL_MODE check"
      pattern: "OPERATOR_APPROVAL_MODE"
    - from: "cli/actions.py"
      to: "db/actions.py"
      via: "ActionDB.approve_proposal call"
      pattern: "await db\\.approve_proposal"
---

<objective>
Implement approval gate in executor and CLI commands for approve/reject.

Purpose: Enable configurable human-in-the-loop approval for action execution. When approval mode is off (default), actions execute autonomously. When on, validated actions wait for human approval.
Output: ActionExecutor with approval gate, CLI commands for approve/reject, ApprovalRequiredError exception.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-approval-workflow/14-RESEARCH.md
@.planning/phases/14-approval-workflow/14-01-SUMMARY.md

# Existing files to modify
@packages/operator-core/src/operator_core/actions/executor.py
@packages/operator-core/src/operator_core/cli/actions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add approval gate to ActionExecutor</name>
  <files>
    packages/operator-core/src/operator_core/actions/executor.py
  </files>
  <action>
    1. Add ApprovalRequiredError exception class at module level (after existing imports):
       ```python
       class ApprovalRequiredError(Exception):
           """Raised when action requires approval but hasn't been approved."""

           def __init__(self, proposal_id: int, action_name: str) -> None:
               self.proposal_id = proposal_id
               self.action_name = action_name
               super().__init__(
                   f"Action '{action_name}' (proposal {proposal_id}) requires approval. "
                   f"Run: operator actions approve {proposal_id}"
               )
       ```

    2. Add approval_mode parameter to ActionExecutor.__init__():
       ```python
       def __init__(
           self,
           db_path: Path,
           registry: ActionRegistry,
           safety: SafetyController,
           auditor: ActionAuditor,
           approval_mode: bool | None = None,  # NEW
       ) -> None:
       ```
       If approval_mode is None, read from os.environ.get("OPERATOR_APPROVAL_MODE", "false").lower() == "true".
       Store as self._approval_mode.

    3. Add helper method _requires_approval(self, proposal: ActionProposal) -> bool:
       - If self._approval_mode is False, return False (APR-01: default off = autonomous)
       - If self._approval_mode is True, return True (all actions need approval when mode enabled)
       Per research recommendation, start with global mode only. Per-action requires_approval can be added later.

    4. Modify execute_proposal() to check approval gate:
       After fetching proposal and before checking VALIDATED status:
       ```python
       # Check if approval is required
       if self._requires_approval(proposal):
           if not proposal.is_approved:
               raise ApprovalRequiredError(proposal.id, proposal.action_name)
       ```

    5. Export ApprovalRequiredError from actions/__init__.py:
       Add to the imports and __all__ list in packages/operator-core/src/operator_core/actions/__init__.py

    Add import os at top of executor.py.
  </action>
  <verify>
    Run Python to verify ApprovalRequiredError exists and approval_mode parameter works:
    ```bash
    cd /Users/jrtipton/x/operator/packages/operator-core && python -c "
import os
os.environ['OPERATOR_APPROVAL_MODE'] = 'false'
from operator_core.actions.executor import ActionExecutor, ApprovalRequiredError
print('ApprovalRequiredError:', ApprovalRequiredError)
print('Module OK')
"
    ```
  </verify>
  <done>
    ActionExecutor checks approval gate before execution, raises ApprovalRequiredError if approval required but not approved, reads approval_mode from OPERATOR_APPROVAL_MODE env var (default false).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add approve and reject CLI commands</name>
  <files>
    packages/operator-core/src/operator_core/cli/actions.py
  </files>
  <action>
    Add two new CLI commands to actions_app:

    1. `operator actions approve <proposal_id>`:
       ```python
       @actions_app.command("approve")
       def approve_action(
           proposal_id: int = typer.Argument(..., help="Proposal ID to approve"),
           db_path: Path = typer.Option(
               None,
               help="Database path (default: ~/.operator/operator.db)",
           ),
       ) -> None:
           """Approve a validated action proposal for execution."""

           async def _approve():
               path = _get_db_path(db_path)

               if not path.exists():
                   console.print("[red]Database not found.[/red]")
                   raise typer.Exit(1)

               async with ActionDB(path) as db:
                   proposal = await db.get_proposal(proposal_id)

                   if not proposal:
                       console.print(f"[red]Proposal {proposal_id} not found.[/red]")
                       raise typer.Exit(1)

                   if proposal.status != ActionStatus.VALIDATED:
                       console.print(
                           f"[red]Proposal {proposal_id} is {proposal.status.value}, "
                           f"expected 'validated'.[/red]"
                       )
                       raise typer.Exit(1)

                   await db.approve_proposal(proposal_id, approved_by="user")

                   console.print(
                       f"[green]Proposal {proposal_id} approved.[/green]\n"
                       f"  Action: {proposal.action_name}\n"
                       f"  The action will execute on next agent cycle."
                   )

           asyncio.run(_approve())
       ```

    2. `operator actions reject <proposal_id>`:
       ```python
       @actions_app.command("reject")
       def reject_action(
           proposal_id: int = typer.Argument(..., help="Proposal ID to reject"),
           reason: str = typer.Option(
               "Rejected by user",
               help="Rejection reason",
           ),
           db_path: Path = typer.Option(
               None,
               help="Database path (default: ~/.operator/operator.db)",
           ),
       ) -> None:
           """Reject a validated action proposal (cancels it with reason)."""

           async def _reject():
               path = _get_db_path(db_path)

               if not path.exists():
                   console.print("[red]Database not found.[/red]")
                   raise typer.Exit(1)

               async with ActionDB(path) as db:
                   proposal = await db.get_proposal(proposal_id)

                   if not proposal:
                       console.print(f"[red]Proposal {proposal_id} not found.[/red]")
                       raise typer.Exit(1)

                   if proposal.status != ActionStatus.VALIDATED:
                       console.print(
                           f"[red]Proposal {proposal_id} is {proposal.status.value}, "
                           f"expected 'validated'.[/red]"
                       )
                       raise typer.Exit(1)

                   await db.reject_proposal(proposal_id, rejected_by="user", reason=reason)

                   console.print(
                       f"[yellow]Proposal {proposal_id} rejected.[/yellow]\n"
                       f"  Action: {proposal.action_name}\n"
                       f"  Reason: {reason}"
                   )

           asyncio.run(_reject())
       ```

    Update the show_action command to display approval state:
    After the "Proposed at:" line, add:
    ```python
    if proposal.approved_at:
        console.print(f"  Approved by: {proposal.approved_by}")
        console.print(f"  Approved at: {proposal.approved_at.isoformat()}")
    if proposal.rejected_at:
        console.print(f"  Rejected by: {proposal.rejected_by}")
        console.print(f"  Rejected at: {proposal.rejected_at.isoformat()}")
        console.print(f"  Rejection reason: {proposal.rejection_reason}")
    ```
  </action>
  <verify>
    Run CLI help to verify new commands exist:
    ```bash
    cd /Users/jrtipton/x/operator/packages/operator-core && python -m operator_core.cli.main actions --help
    ```
    Should show: approve, reject in the commands list

    Verify command help:
    ```bash
    cd /Users/jrtipton/x/operator/packages/operator-core && python -m operator_core.cli.main actions approve --help
    cd /Users/jrtipton/x/operator/packages/operator-core && python -m operator_core.cli.main actions reject --help
    ```
  </verify>
  <done>
    CLI has `operator actions approve <id>` and `operator actions reject <id> --reason "..."` commands, show command displays approval state.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. ActionExecutor with approval_mode=True raises ApprovalRequiredError for unapproved proposals
2. ActionExecutor with approval_mode=False (default) executes without approval check
3. CLI approve command marks proposal as approved
4. CLI reject command marks proposal as rejected and cancels it
5. CLI show command displays approval/rejection state

Integration test (manual):
1. Set OPERATOR_APPROVAL_MODE=true
2. Create a proposal (via agent or directly)
3. Validate it (via executor.validate_proposal)
4. Try execute_proposal -> should raise ApprovalRequiredError
5. Run `operator actions approve <id>`
6. Try execute_proposal again -> should proceed
</verification>

<success_criteria>
- OPERATOR_APPROVAL_MODE=false: actions execute immediately after validation (autonomous mode)
- OPERATOR_APPROVAL_MODE=true: actions wait for human approval
- `operator actions approve <id>` marks proposal approved
- `operator actions reject <id>` marks proposal rejected and cancels it
- ApprovalRequiredError raised when approval needed but not granted
- show command displays approval state
</success_criteria>

<output>
After completion, create `.planning/phases/14-approval-workflow/14-02-SUMMARY.md`
</output>
