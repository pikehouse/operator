---
phase: 14-approval-workflow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/operator-core/src/operator_core/db/schema.py
  - packages/operator-core/src/operator_core/db/actions.py
  - packages/operator-core/src/operator_core/actions/types.py
autonomous: true

must_haves:
  truths:
    - "Proposal can be marked as approved with timestamp and approver"
    - "Proposal can be marked as rejected with timestamp, rejector, and reason"
    - "Approval_mode config controls whether approval is required"
  artifacts:
    - path: "packages/operator-core/src/operator_core/db/schema.py"
      provides: "approval columns in action_proposals table"
      contains: "approved_at TEXT"
    - path: "packages/operator-core/src/operator_core/db/actions.py"
      provides: "approve_proposal and reject_proposal methods"
      exports: ["approve_proposal", "reject_proposal", "is_approved"]
    - path: "packages/operator-core/src/operator_core/actions/types.py"
      provides: "ActionProposal with approval fields"
      contains: "approved_at"
  key_links:
    - from: "db/actions.py"
      to: "db/schema.py"
      via: "ALTER TABLE migration"
      pattern: "ALTER TABLE action_proposals ADD COLUMN approved_at"
---

<objective>
Add approval infrastructure to action proposals.

Purpose: Enable proposals to track approval state (approved/rejected) with audit trail, and provide configuration for approval mode.
Output: Schema with approval columns, ActionDB methods for approve/reject, approval config via environment variable.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-approval-workflow/14-RESEARCH.md

# Existing files to modify
@packages/operator-core/src/operator_core/db/schema.py
@packages/operator-core/src/operator_core/db/actions.py
@packages/operator-core/src/operator_core/actions/types.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add approval columns to schema and ActionDB</name>
  <files>
    packages/operator-core/src/operator_core/db/schema.py
    packages/operator-core/src/operator_core/db/actions.py
  </files>
  <action>
    Add 5 new columns to action_proposals table in ACTIONS_SCHEMA_SQL:
    - approved_at TEXT (ISO8601 timestamp when approved)
    - approved_by TEXT (who approved: "user" typically)
    - rejected_at TEXT (ISO8601 timestamp when rejected)
    - rejected_by TEXT (who rejected)
    - rejection_reason TEXT (why rejected)

    In db/actions.py, add migration logic to _ensure_schema() using try/except ALTER TABLE pattern (per 14-RESEARCH.md Pattern 4). Add columns one at a time with individual try/except blocks.

    Add three new methods to ActionDB:
    1. `async def is_approved(self, proposal_id: int) -> bool` - returns True if approved_at is not None
    2. `async def approve_proposal(self, proposal_id: int, approved_by: str = "user") -> None` - sets approved_at and approved_by for a VALIDATED proposal. Raise ValueError if proposal not found or not in VALIDATED status.
    3. `async def reject_proposal(self, proposal_id: int, rejected_by: str = "user", reason: str = "") -> None` - sets rejected_at, rejected_by, rejection_reason and updates status to CANCELLED. Raise ValueError if proposal not found or not in VALIDATED status.

    Update _row_to_proposal() to parse the new fields from rows.

    Follow existing ActionDB patterns for all methods (async with self._conn.execute, await self._conn.commit).
  </action>
  <verify>
    Run Python to verify schema compiles:
    ```bash
    cd /Users/jrtipton/x/operator/packages/operator-core && python -c "from operator_core.db.schema import ACTIONS_SCHEMA_SQL; print('Schema OK')"
    ```

    Run Python to verify ActionDB has new methods:
    ```bash
    cd /Users/jrtipton/x/operator/packages/operator-core && python -c "from operator_core.db.actions import ActionDB; print(hasattr(ActionDB, 'approve_proposal'), hasattr(ActionDB, 'reject_proposal'), hasattr(ActionDB, 'is_approved'))"
    ```
    Expected: True True True
  </verify>
  <done>
    Schema has approval columns, ActionDB has approve_proposal, reject_proposal, is_approved methods, migration adds columns if missing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add approval fields to ActionProposal model</name>
  <files>
    packages/operator-core/src/operator_core/actions/types.py
  </files>
  <action>
    Add 5 optional fields to ActionProposal Pydantic model:
    - approved_at: datetime | None = Field(default=None, description="When the proposal was approved")
    - approved_by: str | None = Field(default=None, description="Who approved: 'user'")
    - rejected_at: datetime | None = Field(default=None, description="When the proposal was rejected")
    - rejected_by: str | None = Field(default=None, description="Who rejected")
    - rejection_reason: str | None = Field(default=None, description="Why the proposal was rejected")

    Add a computed property `is_approved` that returns `self.approved_at is not None`.

    Update docstring to mention these new fields.

    Go back to db/actions.py and update _row_to_proposal() to include the new fields:
    - Parse approved_at as datetime.fromisoformat() if not None
    - Parse rejected_at as datetime.fromisoformat() if not None
    - Pass through approved_by, rejected_by, rejection_reason as strings
  </action>
  <verify>
    Run Python to verify ActionProposal has new fields:
    ```bash
    cd /Users/jrtipton/x/operator/packages/operator-core && python -c "
from operator_core.actions.types import ActionProposal
p = ActionProposal(action_name='test', reason='test')
print('approved_at' in p.model_fields)
print('is_approved' in dir(p))
print(p.is_approved)  # Should be False
"
    ```
    Expected output:
    True
    True
    False
  </verify>
  <done>
    ActionProposal model has approval fields and is_approved property, _row_to_proposal parses new fields from database rows.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. Schema defines all 5 approval columns
2. ActionDB can approve/reject proposals
3. ActionProposal model includes approval state
4. No import errors when loading the modules
</verification>

<success_criteria>
- ACTIONS_SCHEMA_SQL contains approved_at, approved_by, rejected_at, rejected_by, rejection_reason columns
- ActionDB.approve_proposal() updates approved_at and approved_by
- ActionDB.reject_proposal() updates rejection columns and cancels proposal
- ActionProposal.is_approved returns True when approved_at is set
- All Python imports work without errors
</success_criteria>

<output>
After completion, create `.planning/phases/14-approval-workflow/14-01-SUMMARY.md`
</output>
