---
phase: 12-action-foundation
plan: 04
type: execute
wave: 3
depends_on: ["12-02", "12-03"]
files_modified:
  - packages/operator-core/src/operator_core/actions/executor.py
  - packages/operator-core/src/operator_core/agent/diagnosis.py
  - packages/operator-core/src/operator_core/agent/runner.py
  - packages/operator-core/src/operator_core/cli/actions.py
  - packages/operator-core/src/operator_core/cli/main.py
  - packages/operator-core/src/operator_core/actions/__init__.py
autonomous: true

must_haves:
  truths:
    - "Agent can propose actions based on diagnosis"
    - "Action proposals are stored in database with typed parameters"
    - "User can list pending action proposals via CLI"
    - "Observe-only mode blocks action proposal creation"
  artifacts:
    - path: "packages/operator-core/src/operator_core/actions/executor.py"
      provides: "ActionExecutor orchestrating validation, safety, execution"
      exports: ["ActionExecutor"]
    - path: "packages/operator-core/src/operator_core/agent/diagnosis.py"
      provides: "ActionRecommendation in DiagnosisOutput"
      contains: "class ActionRecommendation"
    - path: "packages/operator-core/src/operator_core/cli/actions.py"
      provides: "CLI commands for action management"
      exports: ["actions_app"]
  key_links:
    - from: "packages/operator-core/src/operator_core/actions/executor.py"
      to: "packages/operator-core/src/operator_core/actions/validation.py"
      via: "calls validate_action_params before execution"
      pattern: "validate_action_params"
    - from: "packages/operator-core/src/operator_core/actions/executor.py"
      to: "packages/operator-core/src/operator_core/actions/safety.py"
      via: "checks SafetyController before execution"
      pattern: "check_can_execute"
    - from: "packages/operator-core/src/operator_core/agent/runner.py"
      to: "packages/operator-core/src/operator_core/actions/executor.py"
      via: "calls executor.propose_action after diagnosis"
      pattern: "propose_action"
---

<objective>
Wire agent to propose actions and create CLI for action management.

Purpose: Completes the action foundation by connecting diagnosis output to action proposals. Agent can now recommend specific actions with typed parameters based on its diagnosis. CLI provides visibility into pending actions.

Output: ActionExecutor class orchestrating the proposal flow, ActionRecommendation added to diagnosis output, and `operator actions` CLI commands.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-action-foundation/12-01-SUMMARY.md
@.planning/phases/12-action-foundation/12-02-SUMMARY.md
@.planning/phases/12-action-foundation/12-03-SUMMARY.md
@packages/operator-core/src/operator_core/agent/diagnosis.py
@packages/operator-core/src/operator_core/agent/runner.py
@packages/operator-core/src/operator_core/actions/types.py
@packages/operator-core/src/operator_core/actions/registry.py
@packages/operator-core/src/operator_core/actions/validation.py
@packages/operator-core/src/operator_core/actions/safety.py
@packages/operator-core/src/operator_core/actions/audit.py
@packages/operator-core/src/operator_core/db/actions.py
@packages/operator-core/src/operator_core/cli/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ActionRecommendation to diagnosis output</name>
  <files>
    packages/operator-core/src/operator_core/agent/diagnosis.py
  </files>
  <action>
Extend DiagnosisOutput to include structured action recommendations.

Add to `diagnosis.py`:

1. **ActionRecommendation** (Pydantic BaseModel):
   - `action_name: str` - Name matching a Subject action (e.g., "transfer_leader")
   - `parameters: dict[str, Any]` - Typed parameters for the action
   - `reason: str` - Why this action is recommended (ties to diagnosis)
   - `urgency: str` - "immediate", "soon", "when_convenient"
   - `expected_outcome: str` - What should happen if action succeeds
   - `risks: list[str]` - Potential negative outcomes

2. Add to **DiagnosisOutput** class:
   ```python
   recommended_actions: list[ActionRecommendation] = Field(
       default_factory=list,
       description="Specific actions the agent recommends taking"
   )
   ```

   Note: This is in addition to existing `recommended_action` (text) and `action_commands` (CLI hints). The new `recommended_actions` provides structured, executable recommendations.

3. Update **format_diagnosis_markdown** to include action recommendations:
   ```markdown
   ### Recommended Actions

   **1. transfer_leader** (urgency: immediate)
   - Parameters: region_id=123, to_store_id=2
   - Reason: Move leader away from unhealthy store
   - Expected: Region leadership moves to store 2
   - Risks: Brief unavailability during transfer
   ```

This enables the agent to produce machine-parseable action recommendations alongside human-readable diagnosis.
  </action>
  <verify>
    ```python
    from operator_core.agent.diagnosis import DiagnosisOutput, ActionRecommendation, format_diagnosis_markdown

    # Create diagnosis with action recommendation
    diagnosis = DiagnosisOutput(
        timeline="Store 1 became unreachable at 10:00",
        affected_components=["store-1", "region-123"],
        metric_readings={"store_1_status": "down"},
        primary_diagnosis="Store 1 is down",
        confidence="High - store status is definitively down",
        supporting_evidence=["PD reports store offline"],
        alternatives_considered=[],
        recommended_action="Transfer leaders away from store 1",
        action_commands=["pdctl operator add transfer-leader 123 2"],
        severity="Critical",
        risks=["Brief unavailability"],
        recommended_actions=[
            ActionRecommendation(
                action_name="transfer_leader",
                parameters={"region_id": 123, "to_store_id": "2"},
                reason="Move leader away from down store",
                urgency="immediate",
                expected_outcome="Region 123 leadership on store 2",
                risks=["Brief unavailability during transfer"]
            )
        ]
    )

    md = format_diagnosis_markdown(diagnosis)
    assert "Recommended Actions" in md
    assert "transfer_leader" in md
    print("ActionRecommendation test passed")
    ```
  </verify>
  <done>
    ActionRecommendation Pydantic model exists. DiagnosisOutput includes recommended_actions list. format_diagnosis_markdown renders actions in readable format.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ActionExecutor</name>
  <files>
    packages/operator-core/src/operator_core/actions/executor.py
    packages/operator-core/src/operator_core/actions/__init__.py
  </files>
  <action>
Create ActionExecutor to orchestrate the proposal and execution flow.

In `executor.py`:

1. **ActionExecutor** class:
   - Constructor:
     ```python
     def __init__(
         self,
         db_path: Path,
         registry: ActionRegistry,
         safety: SafetyController,
         auditor: ActionAuditor,
     ) -> None:
     ```

   - `async propose_action(self, recommendation: ActionRecommendation, ticket_id: int | None = None) -> ActionProposal`:
     - Check safety.can_execute (raises ObserveOnlyError if observe mode)
     - Validate action exists in registry
     - Validate parameters via validate_action_params
     - Create ActionProposal with status=PROPOSED
     - Store in database via ActionDB
     - Log "proposed" event to audit
     - Return created proposal

   - `async validate_proposal(self, proposal_id: int) -> ActionProposal`:
     - Fetch proposal from DB
     - Re-validate parameters (in case registry changed)
     - Update status to VALIDATED
     - Log "validated" event
     - Return updated proposal

   - `async execute_proposal(self, proposal_id: int, subject: Subject) -> ActionRecord`:
     - Check safety.can_execute
     - Fetch and verify proposal is VALIDATED
     - Update status to EXECUTING
     - Log "executing" event
     - Call subject method dynamically: `getattr(subject, proposal.action_name)(**proposal.parameters)`
     - Create ActionRecord with result
     - Update proposal status to COMPLETED or FAILED
     - Log completion event
     - Return record

   - `async cancel_proposal(self, proposal_id: int, reason: str) -> None`:
     - Update proposal status to CANCELLED
     - Log "cancelled" event

Note: execute_proposal is not called in Phase 12 - approval workflow (Phase 14) will trigger it. But the method must exist for the foundation to be complete.

Update `__init__.py` to export ActionExecutor.
  </action>
  <verify>
    ```python
    import asyncio
    from pathlib import Path
    from operator_core.actions.executor import ActionExecutor
    from operator_core.actions.registry import ActionRegistry, ActionDefinition, ParamDef
    from operator_core.actions.safety import SafetyController, SafetyMode
    from operator_core.actions.audit import ActionAuditor
    from operator_core.agent.diagnosis import ActionRecommendation

    # Mock subject with get_action_definitions
    class MockSubject:
        def get_action_definitions(self):
            return [
                ActionDefinition(
                    name="test_action",
                    description="Test",
                    parameters={"x": ParamDef(type="int", description="x")},
                    risk_level="low"
                )
            ]

    async def test():
        db_path = Path("/tmp/test_executor.db")
        subject = MockSubject()
        registry = ActionRegistry(subject)
        auditor = ActionAuditor(db_path)
        safety = SafetyController(db_path, auditor, mode=SafetyMode.EXECUTE)

        executor = ActionExecutor(db_path, registry, safety, auditor)

        rec = ActionRecommendation(
            action_name="test_action",
            parameters={"x": 42},
            reason="Test",
            urgency="immediate",
            expected_outcome="Success",
            risks=[]
        )

        proposal = await executor.propose_action(rec, ticket_id=1)
        assert proposal.id is not None
        assert proposal.status.value == "proposed"
        print(f"Created proposal {proposal.id}")

        # Validate
        validated = await executor.validate_proposal(proposal.id)
        assert validated.status.value == "validated"
        print("Validated proposal")

        print("ActionExecutor test passed")

    asyncio.run(test())
    ```
  </verify>
  <done>
    ActionExecutor exists with propose_action, validate_proposal, execute_proposal, and cancel_proposal methods. Integrates with registry, safety, and audit components.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create actions CLI and wire to agent</name>
  <files>
    packages/operator-core/src/operator_core/cli/actions.py
    packages/operator-core/src/operator_core/cli/main.py
    packages/operator-core/src/operator_core/agent/runner.py
  </files>
  <action>
Create CLI for action management and integrate proposal flow into agent.

**1. Create `cli/actions.py`:**

```python
"""CLI commands for action management."""

import typer
from pathlib import Path
from rich.console import Console
from rich.table import Table

actions_app = typer.Typer(help="Manage action proposals")

@actions_app.command("list")
def list_actions(
    status: str = typer.Option(None, help="Filter by status"),
    db_path: Path = typer.Option(
        Path.home() / ".operator" / "operator.db",
        help="Database path"
    ),
):
    """List action proposals."""
    # Implementation using ActionDB
    # Show table with id, action_name, status, proposed_at

@actions_app.command("show")
def show_action(
    proposal_id: int,
    db_path: Path = typer.Option(...),
):
    """Show details of an action proposal."""
    # Show full proposal details including parameters

@actions_app.command("cancel")
def cancel_action(
    proposal_id: int,
    reason: str = typer.Option("Cancelled by user", help="Cancellation reason"),
    db_path: Path = typer.Option(...),
):
    """Cancel a pending action proposal."""
    # Call executor.cancel_proposal

@actions_app.command("kill-switch")
def kill_switch(
    db_path: Path = typer.Option(...),
):
    """Emergency stop - cancel all pending actions and switch to observe mode."""
    # Call safety.kill_switch()
    # Print count of cancelled actions

@actions_app.command("mode")
def set_mode(
    mode: str = typer.Argument(..., help="observe or execute"),
    db_path: Path = typer.Option(...),
):
    """Set safety mode (observe or execute)."""
    # Call safety.set_mode()
```

**2. Update `cli/main.py`:**
- Import actions_app
- Add: `app.add_typer(actions_app, name="actions")`

**3. Update `agent/runner.py`:**

In AgentRunner.__init__, add:
- `executor: ActionExecutor | None = None` parameter
- Store as self.executor

In _diagnose_ticket, after storing diagnosis:
```python
# Propose actions if executor available and recommendations exist
if self.executor and diagnosis_output.recommended_actions:
    for rec in diagnosis_output.recommended_actions:
        try:
            proposal = await self.executor.propose_action(rec, ticket_id=ticket.id)
            print(f"Proposed action: {proposal.action_name} (id={proposal.id})")
        except ObserveOnlyError:
            print("Skipping action proposal: observe-only mode")
        except ValidationError as e:
            print(f"Action proposal validation failed: {e}")
```

Note: The executor is optional - if not provided, agent operates in observe-only mode (v1 behavior). This preserves backward compatibility.
  </action>
  <verify>
    ```bash
    # Test CLI commands exist
    cd /Users/jrtipton/x/operator && uv run operator actions --help
    cd /Users/jrtipton/x/operator && uv run operator actions list --help
    cd /Users/jrtipton/x/operator && uv run operator actions kill-switch --help
    cd /Users/jrtipton/x/operator && uv run operator actions mode --help
    ```

    ```python
    # Test agent runner accepts executor parameter
    from operator_core.agent.runner import AgentRunner
    import inspect
    sig = inspect.signature(AgentRunner.__init__)
    assert 'executor' in sig.parameters
    print("AgentRunner accepts executor parameter")
    ```
  </verify>
  <done>
    - `operator actions list` shows pending proposals
    - `operator actions show ID` displays proposal details
    - `operator actions cancel ID` cancels proposal
    - `operator actions kill-switch` emergency stops all pending
    - `operator actions mode observe|execute` changes safety mode
    - AgentRunner optionally accepts executor and proposes actions from diagnosis
  </done>
</task>

</tasks>

<verification>
1. ActionRecommendation included in DiagnosisOutput
2. format_diagnosis_markdown renders actions
3. ActionExecutor.propose_action creates proposals
4. ActionExecutor.validate_proposal updates status
5. `operator actions list` works
6. `operator actions kill-switch` cancels and logs
7. AgentRunner proposes actions when executor provided
8. AgentRunner skips proposals in observe-only mode
</verification>

<success_criteria>
- ActionRecommendation Pydantic model with 6 fields
- DiagnosisOutput.recommended_actions field
- Markdown output includes recommended actions
- ActionExecutor orchestrates proposal flow
- CLI commands for list, show, cancel, kill-switch, mode
- AgentRunner integrates with executor (optional)
- Observe-only mode prevents proposals
- All action lifecycle events logged to audit
</success_criteria>

<output>
After completion, create `.planning/phases/12-action-foundation/12-04-SUMMARY.md`
</output>
