---
phase: 12-action-foundation
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - packages/operator-core/src/operator_core/actions/registry.py
  - packages/operator-core/src/operator_core/actions/validation.py
  - packages/operator-core/src/operator_core/actions/__init__.py
  - packages/operator-core/src/operator_core/subject.py
autonomous: true

must_haves:
  truths:
    - "Agent discovers available actions from subject at runtime"
    - "Action parameters are validated against action definitions before execution"
    - "Invalid parameters produce clear validation errors"
  artifacts:
    - path: "packages/operator-core/src/operator_core/actions/registry.py"
      provides: "ActionRegistry for discovering subject actions"
      exports: ["ActionRegistry", "ActionDefinition"]
    - path: "packages/operator-core/src/operator_core/actions/validation.py"
      provides: "Parameter validation with type checking"
      exports: ["validate_action_params", "ValidationError"]
    - path: "packages/operator-core/src/operator_core/subject.py"
      provides: "get_action_definitions method in Subject protocol"
      contains: "def get_action_definitions"
  key_links:
    - from: "packages/operator-core/src/operator_core/actions/registry.py"
      to: "packages/operator-core/src/operator_core/subject.py"
      via: "calls subject.get_action_definitions()"
      pattern: "get_action_definitions"
    - from: "packages/operator-core/src/operator_core/actions/validation.py"
      to: "packages/operator-core/src/operator_core/actions/registry.py"
      via: "validates against ActionDefinition"
      pattern: "ActionDefinition"
---

<objective>
Create action registry for runtime discovery and parameter validation framework.

Purpose: Enables the agent to discover what actions are available from the current subject without hard-coding subject-specific logic in the core. Validation ensures action parameters match expected types before execution, preventing runtime errors.

Output: ActionRegistry class that queries subjects for their actions, ActionDefinition model for action metadata, and validate_action_params function for pre-flight parameter checking.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-action-foundation/12-01-SUMMARY.md
@packages/operator-core/src/operator_core/subject.py
@packages/operator-core/src/operator_core/config.py
@packages/operator-core/src/operator_core/actions/types.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add action discovery to Subject protocol</name>
  <files>
    packages/operator-core/src/operator_core/subject.py
  </files>
  <action>
Extend the Subject Protocol to support runtime action discovery.

Add a new method to the Subject protocol:

```python
def get_action_definitions(self) -> list["ActionDefinition"]:
    """
    Return definitions of all actions this subject supports.

    Used by ActionRegistry to discover available actions at runtime.
    Each definition includes the action name, parameter schema,
    description, and risk level.

    Returns:
        List of ActionDefinition objects describing available actions.
    """
    ...
```

Note: This uses a forward reference since ActionDefinition is defined in the actions module. Add the import at top of file:

```python
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from operator_core.actions.registry import ActionDefinition
```

This keeps the Subject protocol clean while enabling runtime discovery. The TiKV subject will implement this method in Phase 13.
  </action>
  <verify>
    `python -c "from operator_core.subject import Subject; print('Subject OK')"`
  </verify>
  <done>
    Subject protocol includes get_action_definitions() method. Forward reference to ActionDefinition allows type checking without circular imports.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ActionRegistry and ActionDefinition</name>
  <files>
    packages/operator-core/src/operator_core/actions/registry.py
    packages/operator-core/src/operator_core/actions/__init__.py
  </files>
  <action>
Create the action registry module for runtime discovery.

In `registry.py`:

1. **ActionDefinition** (Pydantic BaseModel):
   - `name: str` - Action name matching Subject method (e.g., "transfer_leader")
   - `description: str` - Human-readable description
   - `parameters: dict[str, ParamDef]` - Parameter definitions (name -> def)
   - `risk_level: str` - "low", "medium", "high" (future: approval tiers)
   - `requires_approval: bool = False` - Default to autonomous (per APR-01)

2. **ParamDef** (Pydantic BaseModel):
   - `type: str` - Python type name ("int", "str", "float", "bool")
   - `description: str` - What this parameter represents
   - `required: bool = True` - Whether parameter must be provided
   - `default: Any = None` - Default value if not required

3. **ActionRegistry** class:
   - `__init__(self, subject: Subject)` - Store subject reference
   - `get_definitions(self) -> list[ActionDefinition]` - Return subject's action definitions
   - `get_definition(self, action_name: str) -> ActionDefinition | None` - Find by name
   - `list_action_names(self) -> list[str]` - Just the names (for prompts)
   - `_cache: dict[str, ActionDefinition] | None` - Lazy cache, built on first call

Example ActionDefinition for transfer_leader (will be implemented by TiKV in Phase 13):
```python
ActionDefinition(
    name="transfer_leader",
    description="Transfer region leadership to another store",
    parameters={
        "region_id": ParamDef(type="int", description="Region to transfer"),
        "to_store_id": ParamDef(type="str", description="Target store ID"),
    },
    risk_level="medium",
    requires_approval=False,
)
```

Update `__init__.py` to export ActionRegistry, ActionDefinition, ParamDef.
  </action>
  <verify>
    ```python
    from operator_core.actions.registry import ActionRegistry, ActionDefinition, ParamDef

    # Test ActionDefinition creation
    defn = ActionDefinition(
        name="test_action",
        description="Test",
        parameters={"x": ParamDef(type="int", description="test param")},
        risk_level="low"
    )
    print(f"Definition: {defn.name}")
    print("Registry imports OK")
    ```
  </verify>
  <done>
    ActionDefinition and ParamDef Pydantic models exist. ActionRegistry can query subject for action definitions and cache them. list_action_names returns just action names for prompt construction.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create parameter validation framework</name>
  <files>
    packages/operator-core/src/operator_core/actions/validation.py
    packages/operator-core/src/operator_core/actions/__init__.py
  </files>
  <action>
Create validation module for pre-flight parameter checking (ACT-05).

In `validation.py`:

1. **ValidationError** exception class:
   - `__init__(self, action_name: str, errors: list[str])` - Store action and error list
   - `__str__` - Format as readable error message
   - Human-friendly output like: "Validation failed for transfer_leader: region_id must be int, got str"

2. **validate_action_params** function:
   ```python
   def validate_action_params(
       definition: ActionDefinition,
       parameters: dict[str, Any],
   ) -> None:
       """
       Validate parameters against action definition.

       Checks:
       1. All required parameters are present
       2. No unknown parameters provided
       3. Parameter types match expected types

       Args:
           definition: The ActionDefinition to validate against
           parameters: The parameters to validate

       Raises:
           ValidationError: If validation fails (contains all errors)
       """
   ```

3. **Type checking logic**:
   - "int" -> isinstance(value, int) and not isinstance(value, bool)
   - "str" -> isinstance(value, str)
   - "float" -> isinstance(value, (int, float)) and not isinstance(value, bool)
   - "bool" -> isinstance(value, bool)
   - Unknown types -> skip validation (log warning)

4. Collect ALL errors before raising (don't fail on first error). This gives users complete feedback.

Update `__init__.py` to export validate_action_params, ValidationError.

Example usage:
```python
try:
    validate_action_params(transfer_leader_def, {"region_id": "not-an-int"})
except ValidationError as e:
    print(e)  # "Validation failed for transfer_leader: region_id must be int, got str"
```
  </action>
  <verify>
    ```python
    from operator_core.actions.validation import validate_action_params, ValidationError
    from operator_core.actions.registry import ActionDefinition, ParamDef

    defn = ActionDefinition(
        name="test",
        description="Test",
        parameters={
            "x": ParamDef(type="int", description="x"),
            "y": ParamDef(type="str", description="y", required=False),
        },
        risk_level="low"
    )

    # Valid params
    validate_action_params(defn, {"x": 42})
    print("Valid params: OK")

    # Invalid type
    try:
        validate_action_params(defn, {"x": "not-int"})
        print("Should have raised!")
    except ValidationError as e:
        print(f"Caught expected error: {e}")

    # Missing required
    try:
        validate_action_params(defn, {})
        print("Should have raised!")
    except ValidationError as e:
        print(f"Caught expected error: {e}")

    print("Validation tests passed")
    ```
  </verify>
  <done>
    ValidationError exception provides clear error messages. validate_action_params checks required params, unknown params, and type correctness. All errors collected before raising.
  </done>
</task>

</tasks>

<verification>
1. Subject protocol includes get_action_definitions() method
2. ActionDefinition can describe action with parameters and risk level
3. ActionRegistry discovers actions from subject
4. validate_action_params catches type mismatches
5. validate_action_params catches missing required params
6. ValidationError provides actionable error messages
</verification>

<success_criteria>
- Subject protocol extended with get_action_definitions()
- ActionDefinition Pydantic model with parameters dict
- ParamDef model for individual parameter schema
- ActionRegistry class with get_definitions(), get_definition(), list_action_names()
- validate_action_params function with comprehensive checking
- ValidationError exception with clear error formatting
- All validation scenarios tested (type mismatch, missing required, unknown params)
</success_criteria>

<output>
After completion, create `.planning/phases/12-action-foundation/12-02-SUMMARY.md`
</output>
