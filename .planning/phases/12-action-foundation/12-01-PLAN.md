---
phase: 12-action-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/operator-core/src/operator_core/actions/__init__.py
  - packages/operator-core/src/operator_core/actions/types.py
  - packages/operator-core/src/operator_core/db/schema.py
  - packages/operator-core/src/operator_core/db/actions.py
autonomous: true

must_haves:
  truths:
    - "Action proposals can be created with typed parameters"
    - "Action records track execution state transitions"
    - "Action data persists in database across restarts"
  artifacts:
    - path: "packages/operator-core/src/operator_core/actions/types.py"
      provides: "ActionProposal, ActionRecord, ActionStatus, ActionType Pydantic models"
      exports: ["ActionProposal", "ActionRecord", "ActionStatus", "ActionType"]
    - path: "packages/operator-core/src/operator_core/db/schema.py"
      provides: "action_proposals and action_records tables"
      contains: "CREATE TABLE IF NOT EXISTS action_proposals"
    - path: "packages/operator-core/src/operator_core/db/actions.py"
      provides: "ActionDB class for action persistence"
      exports: ["ActionDB"]
  key_links:
    - from: "packages/operator-core/src/operator_core/db/actions.py"
      to: "packages/operator-core/src/operator_core/actions/types.py"
      via: "imports ActionProposal, ActionRecord"
      pattern: "from operator_core.actions.types import"
    - from: "packages/operator-core/src/operator_core/db/actions.py"
      to: "packages/operator-core/src/operator_core/db/schema.py"
      via: "uses ACTIONS_SCHEMA_SQL"
      pattern: "ACTIONS_SCHEMA_SQL"
---

<objective>
Create action type definitions and database schema for the action execution framework.

Purpose: Establishes the foundational data structures for action proposals, execution records, and lifecycle states. This enables all subsequent action functionality (registry, validation, execution, audit).

Output: Pydantic models for action types, SQLite schema for persistence, and ActionDB class for CRUD operations.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/operator-core/src/operator_core/types.py
@packages/operator-core/src/operator_core/db/schema.py
@packages/operator-core/src/operator_core/db/tickets.py
@packages/operator-core/src/operator_core/monitor/types.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create action type definitions</name>
  <files>
    packages/operator-core/src/operator_core/actions/__init__.py
    packages/operator-core/src/operator_core/actions/types.py
  </files>
  <action>
Create a new `actions` module in operator-core with Pydantic models.

In `types.py`, define:

1. **ActionStatus** (str Enum):
   - `proposed` - Action requested, awaiting validation/approval
   - `validated` - Parameters verified, ready to execute
   - `executing` - Currently running
   - `completed` - Finished successfully
   - `failed` - Execution error
   - `cancelled` - Halted by kill switch or user

2. **ActionType** (str Enum):
   - `subject` - Subject-defined action (e.g., transfer_leader)
   - `tool` - General tool action (future use)
   - `workflow` - Multi-step workflow (future use)

3. **ActionProposal** (Pydantic BaseModel):
   - `id: int | None` - Database ID (None before insert)
   - `ticket_id: int | None` - Associated ticket (optional)
   - `action_name: str` - Name matching Subject method (e.g., "transfer_leader")
   - `action_type: ActionType` - Source type
   - `parameters: dict[str, Any]` - Action arguments (validated later)
   - `reason: str` - Why this action is proposed (from diagnosis)
   - `status: ActionStatus` - Current lifecycle state
   - `proposed_at: datetime` - When created
   - `proposed_by: str` - "agent" or "user" (future: approval workflows)

4. **ActionRecord** (Pydantic BaseModel):
   - `id: int | None` - Database ID
   - `proposal_id: int` - Links to ActionProposal
   - `started_at: datetime | None` - Execution start
   - `completed_at: datetime | None` - Execution end
   - `success: bool | None` - Outcome (None while executing)
   - `error_message: str | None` - Error details if failed
   - `result_data: dict[str, Any] | None` - Execution output

Follow patterns from `operator_core/monitor/types.py` for consistency. Use Field() with descriptions for documentation.

In `__init__.py`, export all types.
  </action>
  <verify>
    `python -c "from operator_core.actions.types import ActionProposal, ActionRecord, ActionStatus, ActionType; print('Types OK')"`
  </verify>
  <done>
    ActionProposal and ActionRecord Pydantic models exist with all fields. ActionStatus enum has 6 states. ActionType enum has 3 sources.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend database schema for actions</name>
  <files>
    packages/operator-core/src/operator_core/db/schema.py
  </files>
  <action>
Add action tables to the existing schema.py file.

Create `ACTIONS_SCHEMA_SQL` constant with:

1. **action_proposals table**:
   ```sql
   CREATE TABLE IF NOT EXISTS action_proposals (
       id INTEGER PRIMARY KEY AUTOINCREMENT,
       ticket_id INTEGER,                    -- Optional link to ticket
       action_name TEXT NOT NULL,
       action_type TEXT NOT NULL DEFAULT 'subject',
       parameters TEXT NOT NULL,             -- JSON blob
       reason TEXT NOT NULL,
       status TEXT NOT NULL DEFAULT 'proposed',
       proposed_at TEXT NOT NULL,
       proposed_by TEXT NOT NULL DEFAULT 'agent',
       validated_at TEXT,
       cancelled_at TEXT,
       created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
       updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
       FOREIGN KEY (ticket_id) REFERENCES tickets(id)
   );
   ```

2. **action_records table** (execution results):
   ```sql
   CREATE TABLE IF NOT EXISTS action_records (
       id INTEGER PRIMARY KEY AUTOINCREMENT,
       proposal_id INTEGER NOT NULL,
       started_at TEXT,
       completed_at TEXT,
       success INTEGER,                       -- 1=success, 0=failure, NULL=executing
       error_message TEXT,
       result_data TEXT,                      -- JSON blob
       created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
       FOREIGN KEY (proposal_id) REFERENCES action_proposals(id)
   );
   ```

3. Indexes:
   - `idx_action_proposals_status` on `action_proposals(status)` for finding pending
   - `idx_action_proposals_ticket` on `action_proposals(ticket_id)` for ticket lookup
   - `idx_action_records_proposal` on `action_records(proposal_id)`

4. Update trigger for action_proposals.updated_at

Keep existing SCHEMA_SQL unchanged. Add ACTIONS_SCHEMA_SQL as a separate constant - both will be executed during DB initialization.
  </action>
  <verify>
    `python -c "from operator_core.db.schema import SCHEMA_SQL, ACTIONS_SCHEMA_SQL; print('Schema OK')"`
  </verify>
  <done>
    ACTIONS_SCHEMA_SQL constant exists with action_proposals and action_records tables. Indexes created for status and foreign key lookups.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create ActionDB persistence class</name>
  <files>
    packages/operator-core/src/operator_core/db/actions.py
    packages/operator-core/src/operator_core/db/__init__.py
  </files>
  <action>
Create ActionDB class following TicketDB patterns from `db/tickets.py`.

In `actions.py`:

1. **ActionDB class** (async context manager):
   - `__init__(self, db_path: Path)` - Store path, init connection holder
   - `__aenter__` - Open connection, ensure schema (both SCHEMA_SQL and ACTIONS_SCHEMA_SQL)
   - `__aexit__` - Close connection

2. **Proposal operations**:
   - `create_proposal(proposal: ActionProposal) -> ActionProposal` - Insert, return with ID
   - `get_proposal(proposal_id: int) -> ActionProposal | None` - Fetch by ID
   - `list_proposals(status: ActionStatus | None = None) -> list[ActionProposal]` - List, optional filter
   - `update_proposal_status(proposal_id: int, status: ActionStatus) -> None` - Status transition
   - `cancel_all_pending() -> int` - Cancel all proposed/validated proposals, return count (for kill switch)

3. **Record operations**:
   - `create_record(record: ActionRecord) -> ActionRecord` - Insert execution record
   - `update_record(record_id: int, success: bool, error_message: str | None, result_data: dict | None) -> None` - Complete execution

4. **Helper methods**:
   - `_row_to_proposal(row: aiosqlite.Row) -> ActionProposal` - Parse datetime, JSON
   - `_row_to_record(row: aiosqlite.Row) -> ActionRecord` - Parse datetime, JSON

Use `json.dumps/loads` for parameters and result_data fields. Follow TicketDB's datetime parsing pattern.

Update `db/__init__.py` to export ActionDB.
  </action>
  <verify>
    `python -c "from operator_core.db.actions import ActionDB; print('ActionDB OK')"`

    Run a quick integration test:
    ```python
    import asyncio
    from pathlib import Path
    from operator_core.db.actions import ActionDB
    from operator_core.actions.types import ActionProposal, ActionStatus, ActionType
    from datetime import datetime

    async def test():
        async with ActionDB(Path("/tmp/test_actions.db")) as db:
            p = ActionProposal(
                action_name="transfer_leader",
                action_type=ActionType.SUBJECT,
                parameters={"region_id": 1, "to_store_id": "2"},
                reason="Test proposal",
                status=ActionStatus.PROPOSED,
                proposed_at=datetime.now(),
                proposed_by="agent"
            )
            created = await db.create_proposal(p)
            assert created.id is not None
            fetched = await db.get_proposal(created.id)
            assert fetched.action_name == "transfer_leader"
            print("Integration test passed")

    asyncio.run(test())
    ```
  </verify>
  <done>
    ActionDB class exists with create/get/list/update operations for both proposals and records. Integration test passes showing data round-trips through database correctly.
  </done>
</task>

</tasks>

<verification>
1. All action types import without error
2. Database schema creates tables when ActionDB context entered
3. ActionProposal can be created, stored, retrieved with all fields intact
4. ActionRecord can be created and linked to proposal
5. cancel_all_pending returns correct count
</verification>

<success_criteria>
- ActionProposal Pydantic model with 9+ fields
- ActionRecord Pydantic model with 7+ fields
- ActionStatus enum with 6 states
- ActionType enum with 3 types
- action_proposals table with indexes
- action_records table with foreign key to proposals
- ActionDB class with CRUD operations
- Integration test passes
</success_criteria>

<output>
After completion, create `.planning/phases/12-action-foundation/12-01-SUMMARY.md`
</output>
