---
phase: 12-action-foundation
plan: 03
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - packages/operator-core/src/operator_core/actions/safety.py
  - packages/operator-core/src/operator_core/actions/audit.py
  - packages/operator-core/src/operator_core/actions/__init__.py
  - packages/operator-core/src/operator_core/db/schema.py
autonomous: true

must_haves:
  truths:
    - "Kill switch halts all pending actions immediately"
    - "Observe-only mode prevents any action execution"
    - "All action lifecycle events are recorded in audit log"
  artifacts:
    - path: "packages/operator-core/src/operator_core/actions/safety.py"
      provides: "SafetyController with kill switch and observe-only mode"
      exports: ["SafetyController", "SafetyMode"]
    - path: "packages/operator-core/src/operator_core/actions/audit.py"
      provides: "ActionAuditor for lifecycle event logging"
      exports: ["ActionAuditor", "AuditEvent"]
    - path: "packages/operator-core/src/operator_core/db/schema.py"
      provides: "action_audit_log table"
      contains: "CREATE TABLE IF NOT EXISTS action_audit_log"
  key_links:
    - from: "packages/operator-core/src/operator_core/actions/safety.py"
      to: "packages/operator-core/src/operator_core/db/actions.py"
      via: "calls ActionDB.cancel_all_pending()"
      pattern: "cancel_all_pending"
    - from: "packages/operator-core/src/operator_core/actions/audit.py"
      to: "packages/operator-core/src/operator_core/db/schema.py"
      via: "writes to action_audit_log table"
      pattern: "action_audit_log"
---

<objective>
Create safety controls and audit logging for action execution.

Purpose: Safety infrastructure (SAF-01, SAF-02) must exist BEFORE any action executes. Kill switch enables immediate halt of all pending actions. Observe-only mode provides fallback to v1 behavior. Audit log (ACT-07) records all action lifecycle events for transparency and debugging.

Output: SafetyController class for kill switch and mode management, ActionAuditor for event logging, and action_audit_log database table.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-action-foundation/12-01-SUMMARY.md
@packages/operator-core/src/operator_core/db/schema.py
@packages/operator-core/src/operator_core/db/actions.py
@packages/operator-core/src/operator_core/actions/types.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add audit log table to schema</name>
  <files>
    packages/operator-core/src/operator_core/db/schema.py
  </files>
  <action>
Extend ACTIONS_SCHEMA_SQL with the audit log table.

Add to the existing ACTIONS_SCHEMA_SQL constant:

```sql
-- Audit log for action lifecycle events (ACT-07)
CREATE TABLE IF NOT EXISTS action_audit_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    proposal_id INTEGER,                    -- NULL for system events (kill switch)
    event_type TEXT NOT NULL,               -- proposed, validated, executing, completed, failed, cancelled, kill_switch, mode_change
    event_data TEXT,                        -- JSON blob with event-specific details
    actor TEXT NOT NULL,                    -- "agent", "user", "system"
    timestamp TEXT NOT NULL,
    created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Index for finding events by proposal
CREATE INDEX IF NOT EXISTS idx_audit_proposal
ON action_audit_log(proposal_id);

-- Index for finding events by type
CREATE INDEX IF NOT EXISTS idx_audit_type
ON action_audit_log(event_type);

-- Index for time-range queries
CREATE INDEX IF NOT EXISTS idx_audit_timestamp
ON action_audit_log(timestamp);
```

Event types to track:
- `proposed` - Action proposal created
- `validated` - Parameters validated successfully
- `executing` - Execution started
- `completed` - Execution finished successfully
- `failed` - Execution failed
- `cancelled` - Cancelled by user or kill switch
- `kill_switch` - Kill switch activated (system event, no proposal_id)
- `mode_change` - Safety mode changed (system event)
  </action>
  <verify>
    `python -c "from operator_core.db.schema import ACTIONS_SCHEMA_SQL; assert 'action_audit_log' in ACTIONS_SCHEMA_SQL; print('Audit table OK')"`
  </verify>
  <done>
    action_audit_log table added to ACTIONS_SCHEMA_SQL with indexes for proposal_id, event_type, and timestamp queries.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ActionAuditor for event logging</name>
  <files>
    packages/operator-core/src/operator_core/actions/audit.py
    packages/operator-core/src/operator_core/actions/__init__.py
  </files>
  <action>
Create audit module for recording action lifecycle events (ACT-07).

In `audit.py`:

1. **AuditEvent** (Pydantic BaseModel):
   - `id: int | None` - Database ID
   - `proposal_id: int | None` - Associated proposal (None for system events)
   - `event_type: str` - Event type (proposed, validated, etc.)
   - `event_data: dict[str, Any] | None` - Event-specific details
   - `actor: str` - Who triggered ("agent", "user", "system")
   - `timestamp: datetime` - When event occurred

2. **ActionAuditor** class:
   - `__init__(self, db_path: Path)` - Store path for database connection
   - `async log_event(self, event: AuditEvent) -> None` - Write event to database
   - `async log_proposal_created(self, proposal: ActionProposal) -> None` - Helper for proposal events
   - `async log_execution_started(self, proposal_id: int) -> None` - Helper
   - `async log_execution_completed(self, proposal_id: int, success: bool, error: str | None = None) -> None` - Helper
   - `async log_cancelled(self, proposal_id: int, reason: str) -> None` - Helper
   - `async log_kill_switch(self, cancelled_count: int) -> None` - System event helper
   - `async log_mode_change(self, old_mode: str, new_mode: str) -> None` - System event helper
   - `async get_events(self, proposal_id: int | None = None, event_type: str | None = None, limit: int = 100) -> list[AuditEvent]` - Query events

Event data examples:
- `proposed`: `{"action_name": "transfer_leader", "parameters": {...}, "reason": "..."}`
- `completed`: `{"duration_ms": 1234, "result": {...}}`
- `failed`: `{"duration_ms": 500, "error": "Connection timeout"}`
- `kill_switch`: `{"cancelled_count": 3}`
- `mode_change`: `{"old_mode": "execute", "new_mode": "observe"}`

ActionAuditor opens its own connection for each operation (simple approach). Could be optimized later with connection pooling if needed.

Update `__init__.py` to export ActionAuditor, AuditEvent.
  </action>
  <verify>
    ```python
    import asyncio
    from pathlib import Path
    from datetime import datetime
    from operator_core.actions.audit import ActionAuditor, AuditEvent

    async def test():
        auditor = ActionAuditor(Path("/tmp/test_audit.db"))

        # Log a test event
        await auditor.log_event(AuditEvent(
            proposal_id=1,
            event_type="proposed",
            event_data={"action_name": "test"},
            actor="agent",
            timestamp=datetime.now()
        ))

        # Query events
        events = await auditor.get_events(proposal_id=1)
        assert len(events) == 1
        assert events[0].event_type == "proposed"
        print("Audit test passed")

    asyncio.run(test())
    ```
  </verify>
  <done>
    ActionAuditor class exists with log_event and helper methods. AuditEvent model captures all event details. Events persist to database and can be queried.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create SafetyController</name>
  <files>
    packages/operator-core/src/operator_core/actions/safety.py
    packages/operator-core/src/operator_core/actions/__init__.py
  </files>
  <action>
Create safety module for kill switch (SAF-01) and observe-only mode (SAF-02).

In `safety.py`:

1. **SafetyMode** (str Enum):
   - `OBSERVE` - Observe-only mode, no action execution (v1 behavior)
   - `EXECUTE` - Actions can be executed (v2 behavior)

2. **SafetyController** class:
   - `__init__(self, db_path: Path, auditor: ActionAuditor, mode: SafetyMode = SafetyMode.OBSERVE)` - Initialize with observe-only default
   - `mode: SafetyMode` - Current safety mode (property)
   - `is_observe_only: bool` - Convenience property
   - `can_execute: bool` - True if mode is EXECUTE

   - `async set_mode(self, mode: SafetyMode) -> None`:
     - Log mode change via auditor
     - Update internal state
     - If switching to OBSERVE, cancel all pending (like kill switch but gentler)

   - `async kill_switch(self) -> int` (SAF-01):
     - Cancel ALL pending/validated proposals in database
     - Switch mode to OBSERVE
     - Log kill_switch event
     - Return count of cancelled proposals
     - This is the emergency stop button

   - `check_can_execute(self) -> None`:
     - Raises `ObserveOnlyError` if mode is OBSERVE
     - Called before any action execution attempt
     - Provides clear error: "Action execution blocked: observe-only mode is active"

3. **ObserveOnlyError** exception:
   - Simple exception raised when execution attempted in observe mode
   - Includes helpful message about how to enable execution

The SafetyController is the gatekeeper. All action execution paths MUST check `can_execute` before proceeding.

Update `__init__.py` to export SafetyController, SafetyMode, ObserveOnlyError.
  </action>
  <verify>
    ```python
    import asyncio
    from pathlib import Path
    from operator_core.actions.safety import SafetyController, SafetyMode, ObserveOnlyError
    from operator_core.actions.audit import ActionAuditor

    async def test():
        auditor = ActionAuditor(Path("/tmp/test_safety.db"))
        controller = SafetyController(Path("/tmp/test_safety.db"), auditor)

        # Default is observe-only
        assert controller.is_observe_only
        assert not controller.can_execute

        # Check raises in observe mode
        try:
            controller.check_can_execute()
            print("Should have raised!")
        except ObserveOnlyError as e:
            print(f"Caught expected: {e}")

        # Switch to execute mode
        await controller.set_mode(SafetyMode.EXECUTE)
        assert controller.can_execute

        # Kill switch returns to observe
        count = await controller.kill_switch()
        assert controller.is_observe_only
        print(f"Kill switch cancelled {count} proposals")

        print("Safety tests passed")

    asyncio.run(test())
    ```
  </verify>
  <done>
    SafetyController exists with kill_switch and observe-only mode. Default mode is OBSERVE. Kill switch cancels all pending and switches to OBSERVE. check_can_execute raises ObserveOnlyError when appropriate.
  </done>
</task>

</tasks>

<verification>
1. action_audit_log table exists in schema
2. ActionAuditor logs events to database
3. Events can be queried by proposal_id and event_type
4. SafetyController defaults to observe-only mode
5. check_can_execute raises ObserveOnlyError in observe mode
6. kill_switch cancels all pending proposals
7. kill_switch switches mode to OBSERVE
8. Mode changes are logged to audit log
</verification>

<success_criteria>
- action_audit_log table with indexes
- AuditEvent Pydantic model
- ActionAuditor with log_event and query methods
- Helper methods for common audit patterns
- SafetyMode enum with OBSERVE and EXECUTE
- SafetyController with mode management
- kill_switch method cancels pending and logs event
- ObserveOnlyError exception
- All safety scenarios tested
</success_criteria>

<output>
After completion, create `.planning/phases/12-action-foundation/12-03-SUMMARY.md`
</output>
