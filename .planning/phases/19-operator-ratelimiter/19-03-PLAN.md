---
phase: 19-operator-ratelimiter
plan: 03
type: execute
wave: 2
depends_on: []
files_modified:
  - packages/ratelimiter-service/src/ratelimiter_service/api/management.py
  - packages/ratelimiter-service/tests/test_management_api.py
autonomous: true

must_haves:
  truths:
    - "POST /api/counters/{key}/reset returns 200 on success"
    - "POST /api/counters/{key}/reset clears the rate limit counter for that key"
    - "POST /api/counters/{key}/reset returns 200 with reset=False if key doesn't exist"
    - "PUT /api/limits/{key} returns 200 on success"
    - "PUT /api/limits/{key} updates the rate limit for that key"
  artifacts:
    - path: "packages/ratelimiter-service/src/ratelimiter_service/api/management.py"
      provides: "Reset counter and update limit endpoints"
      contains: ["reset_counter", "update_limit"]
    - path: "packages/ratelimiter-service/tests/test_management_api.py"
      provides: "Integration tests for management endpoints"
      contains: ["test_reset_counter", "test_update_limit"]
  key_links:
    - from: "management.py"
      to: "limiter.py"
      via: "calls limiter.reset_counter() and limiter.update_limit()"
      pattern: "await limiter\\.(reset_counter|update_limit)"
---

<objective>
Add POST /api/counters/{key}/reset and PUT /api/limits/{key} endpoints to ratelimiter-service management API.

Purpose: Enable operator-ratelimiter to execute the reset_counter and update_limit actions via HTTP API, allowing the AI to clear rate limit counters and adjust limits when diagnosing issues.

Output:
- New POST endpoint for reset_counter in management.py
- New PUT endpoint for update_limit in management.py
- Endpoints use existing RateLimiter methods
- Returns appropriate HTTP status codes
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing implementation
@packages/ratelimiter-service/src/ratelimiter_service/api/management.py
@packages/ratelimiter-service/src/ratelimiter_service/limiter.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add reset counter endpoint</name>
  <files>
    packages/ratelimiter-service/src/ratelimiter_service/api/management.py
  </files>
  <action>
Add POST endpoint for resetting a rate limit counter:

1. Add response model for the reset endpoint:
   ```python
   class ResetResponse(BaseModel):
       """Response from reset counter endpoint."""
       key: str
       reset: bool  # True if key existed and was reset, False if key didn't exist
   ```

2. Add POST endpoint at `/api/counters/{key}/reset`:
   ```python
   @management_router.post("/counters/{key}/reset", response_model=ResetResponse)
   async def reset_counter(
       key: str,
       limiter: RateLimiter = Depends(get_limiter),
   ) -> ResetResponse:
       """Reset rate limit counter for a specific key.

       This clears all entries in the sliding window for the given key,
       effectively resetting the counter to zero.

       Args:
           key: Rate limit key to reset (e.g., "user:123")

       Returns:
           ResetResponse indicating if the key was reset (existed and was cleared)
       """
       was_reset = await limiter.reset_counter(key)
       return ResetResponse(key=key, reset=was_reset)
   ```

3. The endpoint should:
   - Use the existing limiter.reset_counter() method which returns True if key existed
   - Return 200 for both cases (key existed or didn't exist) - caller can check reset field
   - Not require authentication (matches existing management endpoints)

Note: The existing reset_counter method in limiter.py already handles:
- Deleting the sorted set key (ratelimit:{key})
- Deleting the sequence key (ratelimit:{key}:seq)
- Returning True if anything was deleted
  </action>
  <verify>
```bash
# Verify syntax
cd packages/ratelimiter-service && python -c "
from ratelimiter_service.api.management import reset_counter, ResetResponse
print('Reset endpoint defined')
"
```
  </verify>
  <done>POST /api/counters/{key}/reset endpoint exists and uses limiter.reset_counter()</done>
</task>

<task type="auto">
  <name>Task 2: Add update limit endpoint</name>
  <files>
    packages/ratelimiter-service/src/ratelimiter_service/api/management.py
    packages/ratelimiter-service/src/ratelimiter_service/limiter.py
  </files>
  <action>
Add PUT endpoint for updating a rate limit:

1. First, check if limiter.py has an update_limit method. If not, add it:
   ```python
   async def update_limit(self, key: str, new_limit: int) -> bool:
       """Update the rate limit for a specific key.

       Args:
           key: Rate limit key to update
           new_limit: New limit value

       Returns:
           True if limit was updated successfully
       """
       # Store per-key limit override in Redis
       await self.redis.set(f"ratelimit:{key}:limit", new_limit)
       return True
   ```

2. Add request and response models:
   ```python
   class UpdateLimitRequest(BaseModel):
       """Request body for update limit endpoint."""
       new_limit: int = Field(..., gt=0, description="New limit value (must be positive)")

   class UpdateLimitResponse(BaseModel):
       """Response from update limit endpoint."""
       key: str
       new_limit: int
       updated: bool
   ```

3. Add PUT endpoint at `/api/limits/{key}`:
   ```python
   @management_router.put("/limits/{key}", response_model=UpdateLimitResponse)
   async def update_limit(
       key: str,
       request: UpdateLimitRequest,
       limiter: RateLimiter = Depends(get_limiter),
   ) -> UpdateLimitResponse:
       """Update rate limit for a specific key.

       This sets a per-key limit override that takes precedence over
       the default limit.

       Args:
           key: Rate limit key to update (e.g., "user:123")
           request: Request body containing new_limit

       Returns:
           UpdateLimitResponse indicating if the limit was updated
       """
       updated = await limiter.update_limit(key, request.new_limit)
       return UpdateLimitResponse(key=key, new_limit=request.new_limit, updated=updated)
   ```

4. Also add RateLimiterClient.update_limit() in operator-ratelimiter/ratelimiter_client.py:
   ```python
   async def update_limit(self, key: str, new_limit: int) -> None:
       """Update rate limit for a specific key.

       Args:
           key: Rate limit key to update
           new_limit: New limit value
       """
       response = await self.http.put(f"/api/limits/{key}", json={"new_limit": new_limit})
       response.raise_for_status()
   ```
  </action>
  <verify>
```bash
# Verify syntax for management.py
cd packages/ratelimiter-service && python -c "
from ratelimiter_service.api.management import update_limit, UpdateLimitRequest, UpdateLimitResponse
print('Update limit endpoint defined')
"

# Verify ratelimiter_client.py has update_limit method
cd packages/operator-ratelimiter && python -c "
from operator_ratelimiter.ratelimiter_client import RateLimiterClient
assert hasattr(RateLimiterClient, 'update_limit')
print('RateLimiterClient.update_limit() exists')
"
```
  </verify>
  <done>PUT /api/limits/{key} endpoint exists and limiter.update_limit() implemented</done>
</task>

<task type="auto">
  <name>Task 3: Add integration tests for management endpoints</name>
  <files>
    packages/ratelimiter-service/tests/test_management_api.py
  </files>
  <action>
Add tests for the new endpoints. Create new test file if it doesn't exist, or add to existing test file:

1. Create/update `packages/ratelimiter-service/tests/test_management_api.py`:
   ```python
   """Tests for management API endpoints."""

   import pytest
   from httpx import AsyncClient, ASGITransport
   from ratelimiter_service.main import app


   @pytest.fixture
   async def client():
       """Create test client."""
       async with AsyncClient(
           transport=ASGITransport(app=app),
           base_url="http://test"
       ) as client:
           yield client


   @pytest.mark.asyncio
   async def test_reset_counter_nonexistent_key(client):
       """Reset on nonexistent key returns reset=False."""
       response = await client.post("/api/counters/nonexistent_key_12345/reset")
       assert response.status_code == 200
       data = response.json()
       assert data["key"] == "nonexistent_key_12345"
       assert data["reset"] is False


   @pytest.mark.asyncio
   async def test_reset_counter_existing_key(client):
       """Reset on existing key returns reset=True and clears counter."""
       # First, create a counter by checking rate limit
       key = "test_reset_key"
       check_response = await client.post("/check", json={"key": key})
       assert check_response.status_code == 200

       # Reset the counter
       reset_response = await client.post(f"/api/counters/{key}/reset")
       assert reset_response.status_code == 200
       data = reset_response.json()
       assert data["key"] == key
       assert data["reset"] is True

       # Verify counter is gone (check counters endpoint)
       counters_response = await client.get("/api/counters")
       counters = counters_response.json()["counters"]
       assert not any(c["key"] == key for c in counters)


   @pytest.mark.asyncio
   async def test_update_limit_success(client):
       """Update limit for a key."""
       key = "test_update_limit_key"

       response = await client.put(f"/api/limits/{key}", json={"new_limit": 100})
       assert response.status_code == 200
       data = response.json()
       assert data["key"] == key
       assert data["new_limit"] == 100
       assert data["updated"] is True


   @pytest.mark.asyncio
   async def test_update_limit_invalid_value(client):
       """Update limit with invalid value returns 422."""
       key = "test_invalid_limit_key"

       response = await client.put(f"/api/limits/{key}", json={"new_limit": 0})
       assert response.status_code == 422  # Validation error (must be > 0)

       response = await client.put(f"/api/limits/{key}", json={"new_limit": -1})
       assert response.status_code == 422
   ```

2. If test file exists, add the new tests to it. Preserve existing tests.

Note: Tests depend on the ratelimiter-service test fixtures. If tests fail due to missing Redis, they may need to be marked as integration tests or run with docker-compose.
  </action>
  <verify>
```bash
# Verify test file syntax
python -c "
import ast
with open('packages/ratelimiter-service/tests/test_management_api.py') as f:
    ast.parse(f.read())
print('Test file syntax valid')
"

# Run the tests (may fail if Redis not available - that's expected in unit test context)
cd /Users/jrtipton/x/operator && python -m pytest packages/ratelimiter-service/tests/test_management_api.py -v --tb=short 2>/dev/null || echo "Tests require Redis - will verify in integration"
```
  </verify>
  <done>Integration tests exist for reset_counter and update_limit endpoints</done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Verify endpoints are registered in the router
cd packages/ratelimiter-service && python -c "
from ratelimiter_service.api.management import management_router
routes = [r.path for r in management_router.routes]
assert '/counters/{key}/reset' in routes
assert '/limits/{key}' in routes
print('Both endpoints registered')
print(f'All management routes: {routes}')
"

# Run existing ratelimiter tests to ensure no regressions
cd /Users/jrtipton/x/operator && python -m pytest packages/ratelimiter-service/tests/ -v --tb=short -k "not integration" 2>/dev/null || echo "Some tests may require Redis"
```
</verification>

<success_criteria>
- POST /api/counters/{key}/reset endpoint exists in management router
- PUT /api/limits/{key} endpoint exists in management router
- Endpoints call limiter methods and return results
- Response includes appropriate fields for each endpoint
- RateLimiterClient has update_limit() method
- Existing ratelimiter-service tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/19-operator-ratelimiter/19-03-SUMMARY.md`
</output>
