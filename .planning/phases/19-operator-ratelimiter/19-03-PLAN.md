---
phase: 19-operator-ratelimiter
plan: 03
type: execute
wave: 2
depends_on: []
files_modified:
  - packages/ratelimiter-service/src/ratelimiter_service/api/management.py
autonomous: true

must_haves:
  truths:
    - "POST /api/counters/{key}/reset returns 200 on success"
    - "POST /api/counters/{key}/reset clears the rate limit counter for that key"
    - "POST /api/counters/{key}/reset returns 404 if key doesn't exist"
  artifacts:
    - path: "packages/ratelimiter-service/src/ratelimiter_service/api/management.py"
      provides: "Reset counter endpoint"
      contains: "reset_counter"
  key_links:
    - from: "management.py"
      to: "limiter.py"
      via: "calls limiter.reset_counter()"
      pattern: "await limiter.reset_counter"
---

<objective>
Add POST /api/counters/{key}/reset endpoint to ratelimiter-service management API.

Purpose: Enable operator-ratelimiter to execute the reset_counter action via HTTP API, allowing the AI to clear rate limit counters when diagnosing issues.

Output:
- New POST endpoint in management.py
- Endpoint uses existing RateLimiter.reset_counter() method
- Returns appropriate HTTP status codes
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing implementation
@packages/ratelimiter-service/src/ratelimiter_service/api/management.py
@packages/ratelimiter-service/src/ratelimiter_service/limiter.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add reset counter endpoint</name>
  <files>
    packages/ratelimiter-service/src/ratelimiter_service/api/management.py
  </files>
  <action>
Add POST endpoint for resetting a rate limit counter:

1. Add response model for the reset endpoint:
   ```python
   class ResetResponse(BaseModel):
       """Response from reset counter endpoint."""
       key: str
       reset: bool  # True if key existed and was reset, False if key didn't exist
   ```

2. Add POST endpoint at `/api/counters/{key}/reset`:
   ```python
   @management_router.post("/counters/{key}/reset", response_model=ResetResponse)
   async def reset_counter(
       key: str,
       limiter: RateLimiter = Depends(get_limiter),
   ) -> ResetResponse:
       """Reset rate limit counter for a specific key.

       This clears all entries in the sliding window for the given key,
       effectively resetting the counter to zero.

       Args:
           key: Rate limit key to reset (e.g., "user:123")

       Returns:
           ResetResponse indicating if the key was reset (existed and was cleared)
       """
       was_reset = await limiter.reset_counter(key)
       return ResetResponse(key=key, reset=was_reset)
   ```

3. The endpoint should:
   - Use the existing limiter.reset_counter() method which returns True if key existed
   - Return 200 for both cases (key existed or didn't exist) - caller can check reset field
   - Not require authentication (matches existing management endpoints)

Note: The existing reset_counter method in limiter.py already handles:
- Deleting the sorted set key (ratelimit:{key})
- Deleting the sequence key (ratelimit:{key}:seq)
- Returning True if anything was deleted
  </action>
  <verify>
```bash
# Verify syntax
cd packages/ratelimiter-service && python -c "
from ratelimiter_service.api.management import reset_counter, ResetResponse
print('Reset endpoint defined')
"

# Run existing ratelimiter tests
cd /Users/jrtipton/x/operator && python -m pytest packages/ratelimiter-service/tests/ -v --tb=short
```
  </verify>
  <done>POST /api/counters/{key}/reset endpoint exists and uses limiter.reset_counter()</done>
</task>

<task type="auto">
  <name>Task 2: Add integration test for reset endpoint</name>
  <files>
    packages/ratelimiter-service/tests/test_management_api.py
  </files>
  <action>
Add test for the new reset endpoint. Create new test file if it doesn't exist, or add to existing test file:

1. Create/update `packages/ratelimiter-service/tests/test_management_api.py`:
   ```python
   """Tests for management API endpoints."""

   import pytest
   from httpx import AsyncClient, ASGITransport
   from ratelimiter_service.main import app


   @pytest.fixture
   async def client():
       """Create test client."""
       async with AsyncClient(
           transport=ASGITransport(app=app),
           base_url="http://test"
       ) as client:
           yield client


   @pytest.mark.asyncio
   async def test_reset_counter_nonexistent_key(client):
       """Reset on nonexistent key returns reset=False."""
       response = await client.post("/api/counters/nonexistent_key_12345/reset")
       assert response.status_code == 200
       data = response.json()
       assert data["key"] == "nonexistent_key_12345"
       assert data["reset"] is False


   @pytest.mark.asyncio
   async def test_reset_counter_existing_key(client):
       """Reset on existing key returns reset=True and clears counter."""
       # First, create a counter by checking rate limit
       key = "test_reset_key"
       check_response = await client.post("/check", json={"key": key})
       assert check_response.status_code == 200

       # Reset the counter
       reset_response = await client.post(f"/api/counters/{key}/reset")
       assert reset_response.status_code == 200
       data = reset_response.json()
       assert data["key"] == key
       assert data["reset"] is True

       # Verify counter is gone (check counters endpoint)
       counters_response = await client.get("/api/counters")
       counters = counters_response.json()["counters"]
       assert not any(c["key"] == key for c in counters)
   ```

2. If test file exists, add the new tests to it. Preserve existing tests.

Note: Tests depend on the ratelimiter-service test fixtures. If tests fail due to missing Redis, they may need to be marked as integration tests or run with docker-compose.
  </action>
  <verify>
```bash
# Run the new tests (may fail if Redis not available - that's expected in unit test context)
cd /Users/jrtipton/x/operator && python -m pytest packages/ratelimiter-service/tests/test_management_api.py -v --tb=short 2>/dev/null || echo "Tests require Redis - will verify in integration"

# Verify test file syntax
python -c "
import ast
with open('packages/ratelimiter-service/tests/test_management_api.py') as f:
    ast.parse(f.read())
print('Test file syntax valid')
"
```
  </verify>
  <done>Integration tests exist for reset_counter endpoint</done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Verify endpoint is registered in the router
cd packages/ratelimiter-service && python -c "
from ratelimiter_service.api.management import management_router
routes = [r.path for r in management_router.routes]
assert '/counters/{key}/reset' in routes
print('Reset endpoint registered')
print(f'All management routes: {routes}')
"

# Verify with curl if service is running (optional)
# curl -X POST http://localhost:8001/api/counters/test/reset
```
</verification>

<success_criteria>
- POST /api/counters/{key}/reset endpoint exists in management router
- Endpoint calls limiter.reset_counter() and returns result
- Response includes key and reset (bool) fields
- Existing ratelimiter-service tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/19-operator-ratelimiter/19-03-SUMMARY.md`
</output>
