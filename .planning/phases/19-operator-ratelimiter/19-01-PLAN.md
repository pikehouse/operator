---
phase: 19-operator-ratelimiter
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/operator-ratelimiter/pyproject.toml
  - packages/operator-ratelimiter/src/operator_ratelimiter/__init__.py
  - packages/operator-ratelimiter/src/operator_ratelimiter/types.py
  - packages/operator-ratelimiter/src/operator_ratelimiter/ratelimiter_client.py
  - packages/operator-ratelimiter/src/operator_ratelimiter/redis_client.py
  - packages/operator-ratelimiter/src/operator_ratelimiter/prom_client.py
autonomous: true

must_haves:
  truths:
    - "Package can be installed with pip install -e"
    - "HTTP client can query /api/nodes and /api/counters endpoints"
    - "Redis client can ping Redis and read counter values"
    - "Prometheus client can query latency metrics"
  artifacts:
    - path: "packages/operator-ratelimiter/pyproject.toml"
      provides: "Package configuration"
      contains: "operator-ratelimiter"
    - path: "packages/operator-ratelimiter/src/operator_ratelimiter/types.py"
      provides: "Pydantic response models"
      contains: "NodeInfo"
    - path: "packages/operator-ratelimiter/src/operator_ratelimiter/ratelimiter_client.py"
      provides: "HTTP client for management API"
      exports: ["RateLimiterClient"]
    - path: "packages/operator-ratelimiter/src/operator_ratelimiter/redis_client.py"
      provides: "Redis client for state inspection"
      exports: ["RedisClient"]
    - path: "packages/operator-ratelimiter/src/operator_ratelimiter/prom_client.py"
      provides: "Prometheus client for metrics"
      exports: ["PrometheusClient"]
  key_links:
    - from: "ratelimiter_client.py"
      to: "types.py"
      via: "imports NodeInfo, CounterInfo models"
      pattern: "from.*types import"
    - from: "ratelimiter_client.py"
      to: "httpx"
      via: "async HTTP client injection"
      pattern: "http: httpx.AsyncClient"
---

<objective>
Create operator-ratelimiter package foundation with HTTP, Redis, and Prometheus clients.

Purpose: Establish the package structure and client infrastructure needed for RateLimiterSubject to observe rate limiter cluster state.

Output:
- Package installable via pip
- RateLimiterClient for management API (/api/nodes, /api/counters, /api/limits, /api/blocks)
- RedisClient for direct Redis state inspection (ping, get counter values)
- PrometheusClient for latency metrics (histogram_quantile queries)
- Pydantic models matching ratelimiter-service API responses
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-operator-ratelimiter/19-RESEARCH.md

# Reference implementations
@packages/operator-tikv/pyproject.toml
@packages/operator-tikv/src/operator_tikv/pd_client.py
@packages/operator-tikv/src/operator_tikv/prom_client.py

# API contracts to match
@packages/ratelimiter-service/src/ratelimiter_service/api/management.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create package structure and types</name>
  <files>
    packages/operator-ratelimiter/pyproject.toml
    packages/operator-ratelimiter/src/operator_ratelimiter/__init__.py
    packages/operator-ratelimiter/src/operator_ratelimiter/types.py
  </files>
  <action>
Create new package following operator-tikv structure:

1. Create `packages/operator-ratelimiter/pyproject.toml`:
   - name: "operator-ratelimiter"
   - dependencies: operator-protocols, operator-core, httpx>=0.27.0, redis>=7.0.0, pydantic>=2.0.0
   - Use hatchling build system
   - packages = ["src/operator_ratelimiter"]

2. Create `packages/operator-ratelimiter/src/operator_ratelimiter/__init__.py`:
   - Empty for now (exports added in later plans)

3. Create `packages/operator-ratelimiter/src/operator_ratelimiter/types.py`:
   - Pydantic models matching ratelimiter-service API responses:
     - `NodeInfo(id: str, address: str, state: str, registered_at: datetime | None)`
     - `NodesResponse(nodes: list[NodeInfo])`
     - `CounterInfo(key: str, count: int, limit: int, remaining: int)`
     - `CountersResponse(counters: list[CounterInfo])`
     - `LimitsResponse(default_limit: int, default_window_ms: int)`
     - `BlockedKeyInfo(key: str, current_count: int, limit: int)`
     - `BlocksResponse(blocked: list[BlockedKeyInfo])`
   - All models should use BaseModel from pydantic
   - Match exact field names from ratelimiter-service/api/management.py
  </action>
  <verify>
```bash
# Verify directory structure
ls packages/operator-ratelimiter/pyproject.toml
ls packages/operator-ratelimiter/src/operator_ratelimiter/__init__.py
ls packages/operator-ratelimiter/src/operator_ratelimiter/types.py

# Verify types can be imported (syntax check)
cd packages/operator-ratelimiter && python -c "from operator_ratelimiter.types import NodeInfo, CounterInfo"
```
  </verify>
  <done>Package structure exists with pyproject.toml and Pydantic types matching ratelimiter-service API</done>
</task>

<task type="auto">
  <name>Task 2: Create HTTP and Redis clients</name>
  <files>
    packages/operator-ratelimiter/src/operator_ratelimiter/ratelimiter_client.py
    packages/operator-ratelimiter/src/operator_ratelimiter/redis_client.py
  </files>
  <action>
Create HTTP and Redis clients following operator-tikv patterns:

1. Create `ratelimiter_client.py`:
   - Dataclass `RateLimiterClient` with `http: httpx.AsyncClient` field
   - Methods matching management API:
     - `async def get_nodes() -> list[NodeInfo]` - GET /api/nodes
     - `async def get_counters() -> list[CounterInfo]` - GET /api/counters
     - `async def get_limits() -> LimitsResponse` - GET /api/limits
     - `async def get_blocks() -> list[BlockedKeyInfo]` - GET /api/blocks
     - `async def reset_counter(key: str) -> None` - POST /api/counters/{key}/reset (fire-and-forget)
   - Use Pydantic model_validate() for response parsing (not **response.json())
   - raise_for_status() after each request (fail loudly)

2. Create `redis_client.py`:
   - Dataclass `RedisClient` with `redis: redis.Redis` field (import redis.asyncio as redis)
   - Methods:
     - `async def ping() -> bool` - Check Redis connectivity, return True/False (catch ConnectionError, TimeoutError)
     - `async def get_counter_value(key: str) -> int` - Get raw counter value from Redis sorted set
       - Use prefixed key "ratelimit:{key}"
       - Return zcard result
     - `async def get_all_counter_keys() -> list[str]` - Scan for all ratelimit:* keys (excluding :seq)
  </action>
  <verify>
```bash
# Verify syntax
cd packages/operator-ratelimiter && python -c "
from operator_ratelimiter.ratelimiter_client import RateLimiterClient
from operator_ratelimiter.redis_client import RedisClient
print('Clients import successfully')
"
```
  </verify>
  <done>RateLimiterClient can call management API endpoints, RedisClient can ping and read counter values</done>
</task>

<task type="auto">
  <name>Task 3: Create Prometheus client</name>
  <files>
    packages/operator-ratelimiter/src/operator_ratelimiter/prom_client.py
  </files>
  <action>
Create Prometheus client for latency metrics, following operator-tikv/prom_client.py pattern:

1. Create `prom_client.py`:
   - Dataclass `PrometheusClient` with `http: httpx.AsyncClient` field
   - Methods:
     - `async def instant_query(query: str) -> list[dict]` - Execute PromQL query at /api/v1/query
     - `async def get_metric_value(query: str) -> float | None` - Get single value from query result
       - IMPORTANT: Prometheus returns values as strings ["timestamp", "string_value"], must convert to float
     - `async def get_node_latency_p99(node_id: str) -> float` - Query ratelimiter_check_duration_seconds histogram
       - Query: `histogram_quantile(0.99, rate(ratelimiter_check_duration_seconds_bucket{node_id="{node_id}"}[1m])) * 1000`
       - Returns latency in milliseconds
       - Return 0.0 if no data
     - `async def get_total_allowed_requests(key: str, window_seconds: int) -> int` - Get total allowed requests for ghost detection
       - Query: `increase(ratelimiter_requests_checked_total{result="allowed", key="{key}"}[{window_seconds}s])`
       - Return 0 if no data

2. Handle Prometheus query failures gracefully:
   - Return None/0 for missing metrics (don't block observation)
   - Raise on HTTP errors (fail loudly)

Note: Rate limiter metrics use these names from ratelimiter-service/metrics.py:
- ratelimiter_check_duration_seconds (histogram)
- ratelimiter_requests_checked_total (counter with result label)
  </action>
  <verify>
```bash
# Verify syntax and imports
cd packages/operator-ratelimiter && python -c "
from operator_ratelimiter.prom_client import PrometheusClient
print('PrometheusClient imports successfully')
"
```
  </verify>
  <done>PrometheusClient can query latency P99 and allowed request counts from Prometheus</done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Install package in development mode
cd packages/operator-ratelimiter && pip install -e .

# Verify all imports work
python -c "
from operator_ratelimiter.types import NodeInfo, CounterInfo, NodesResponse, CountersResponse
from operator_ratelimiter.ratelimiter_client import RateLimiterClient
from operator_ratelimiter.redis_client import RedisClient
from operator_ratelimiter.prom_client import PrometheusClient
print('All imports successful')
"

# Run any existing tests
cd /Users/jrtipton/x/operator && python -m pytest packages/operator-ratelimiter/tests/ -v 2>/dev/null || echo "No tests yet"
```
</verification>

<success_criteria>
- Package installs without errors via pip install -e
- All client classes can be imported
- Types match ratelimiter-service API response models exactly
- Clients follow operator-tikv patterns (dataclass with injected httpx/redis client)
</success_criteria>

<output>
After completion, create `.planning/phases/19-operator-ratelimiter/19-01-SUMMARY.md`
</output>
