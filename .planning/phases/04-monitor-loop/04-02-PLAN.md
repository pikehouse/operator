---
phase: 04-monitor-loop
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - packages/operator-core/src/operator_core/monitor/__init__.py
  - packages/operator-core/src/operator_core/monitor/loop.py
autonomous: true

must_haves:
  truths:
    - "Monitor loop runs continuously at configurable interval"
    - "Loop creates tickets when invariants are violated"
    - "Loop auto-resolves tickets when violations clear"
    - "Loop shuts down gracefully on SIGINT/SIGTERM"
    - "Loop outputs periodic heartbeat messages"
  artifacts:
    - path: "packages/operator-core/src/operator_core/monitor/loop.py"
      provides: "MonitorLoop daemon class"
      exports: ["MonitorLoop"]
      min_lines: 100
  key_links:
    - from: "packages/operator-core/src/operator_core/monitor/loop.py"
      to: "packages/operator-core/src/operator_core/db/tickets.py"
      via: "TicketDB operations"
      pattern: "TicketDB|create_or_update_ticket|auto_resolve"
    - from: "packages/operator-core/src/operator_core/monitor/loop.py"
      to: "packages/operator-tikv/src/operator_tikv/invariants.py"
      via: "InvariantChecker usage"
      pattern: "InvariantChecker|check_stores_up|check_latency"
---

<objective>
Implement the MonitorLoop daemon that continuously checks invariants and manages tickets.

Purpose: The monitor loop is the heart of Phase 4 â€” it runs as a long-lived daemon, periodically checking all registered invariants, creating tickets for violations, and auto-resolving tickets when conditions clear. This enables automated monitoring without human intervention.

Output: MonitorLoop class with asyncio daemon logic, signal handling for graceful shutdown, heartbeat logging, and integration with InvariantChecker and TicketDB.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-monitor-loop/04-RESEARCH.md
@.planning/phases/04-monitor-loop/04-01-SUMMARY.md
@packages/operator-tikv/src/operator_tikv/invariants.py
@packages/operator-tikv/src/operator_tikv/subject.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MonitorLoop class with daemon logic</name>
  <files>
    packages/operator-core/src/operator_core/monitor/loop.py
  </files>
  <action>
Create the MonitorLoop class with asyncio daemon pattern:

```python
# Per RESEARCH.md Pattern 2: Daemon Loop with Signal Handling
import asyncio
import signal
import functools
from pathlib import Path
from datetime import datetime

class MonitorLoop:
    """
    Long-running daemon that checks invariants and manages tickets.

    Runs continuously at configurable interval, checking all registered
    invariants, creating tickets for violations, and auto-resolving
    tickets when conditions clear.

    Uses asyncio.Event for shutdown coordination per RESEARCH.md.
    """

    def __init__(
        self,
        subject: TiKVSubject,
        checker: InvariantChecker,
        db_path: Path,
        interval_seconds: float = 30.0,
    ):
        """
        Initialize monitor loop.

        Args:
            subject: TiKVSubject for observations
            checker: InvariantChecker for invariant checks
            db_path: Path to SQLite database file
            interval_seconds: Seconds between check cycles (default 30)
        """
        self.subject = subject
        self.checker = checker
        self.db_path = db_path
        self.interval = interval_seconds
        self._shutdown = asyncio.Event()

        # Stats for heartbeat
        self._invariant_count = 0
        self._violation_count = 0
        self._last_check: datetime | None = None

    async def run(self) -> None:
        """
        Run the monitor loop until shutdown signal.

        Registers SIGINT and SIGTERM handlers for graceful shutdown.
        Checks invariants at configured interval, creating/updating
        tickets for violations.
        """
        loop = asyncio.get_running_loop()

        # Register signal handlers per RESEARCH.md Pattern 2
        for sig in (signal.SIGINT, signal.SIGTERM):
            loop.add_signal_handler(
                sig,
                functools.partial(self._handle_signal, sig)
            )

        async with TicketDB(self.db_path) as db:
            while not self._shutdown.is_set():
                await self._check_cycle(db)
                self._log_heartbeat()

                # Wait for interval or shutdown signal
                # Per RESEARCH.md: Use Event.wait() with timeout, not asyncio.sleep
                try:
                    await asyncio.wait_for(
                        self._shutdown.wait(),
                        timeout=self.interval
                    )
                except asyncio.TimeoutError:
                    pass  # Normal timeout, continue loop

        print("Monitor loop stopped")

    def _handle_signal(self, sig: signal.Signals) -> None:
        """Handle shutdown signal by setting shutdown event."""
        print(f"Received {sig.name}, shutting down...")
        self._shutdown.set()

    async def _check_cycle(self, db: TicketDB) -> None:
        """
        Run one check cycle across all invariants.

        1. Get current stores from subject
        2. Check store health invariants
        3. For each up store, check metrics invariants
        4. Create/update tickets for violations
        5. Auto-resolve tickets for cleared violations
        """
        # Implementation in Task 2
        pass

    def _log_heartbeat(self) -> None:
        """Output periodic status message."""
        # Implementation in Task 2
        pass
```

Key implementation details:
- Use asyncio.Event for shutdown coordination (not busy polling)
- Register signal handlers inside run() with get_running_loop()
- Use functools.partial to pass signal to handler
- Use wait_for with timeout for interruptible sleep
- TicketDB as async context manager wrapping the loop
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator && uv run python -c "
from operator_core.monitor.loop import MonitorLoop
import inspect

# Check class exists and has required methods
assert hasattr(MonitorLoop, 'run')
assert hasattr(MonitorLoop, '_handle_signal')
assert hasattr(MonitorLoop, '_check_cycle')
assert hasattr(MonitorLoop, '_log_heartbeat')

# Check run is async
assert inspect.iscoroutinefunction(MonitorLoop.run)
assert inspect.iscoroutinefunction(MonitorLoop._check_cycle)

print('MonitorLoop structure OK')
"
```
  </verify>
  <done>MonitorLoop class exists with run(), signal handling, and shutdown coordination structure.</done>
</task>

<task type="auto">
  <name>Task 2: Wire loop to InvariantChecker and add heartbeat</name>
  <files>
    packages/operator-core/src/operator_core/monitor/loop.py
    packages/operator-core/src/operator_core/monitor/__init__.py
  </files>
  <action>
Complete the MonitorLoop implementation:

1. Implement `_check_cycle(self, db: TicketDB)`:
```python
async def _check_cycle(self, db: TicketDB) -> None:
    """Run one check cycle across all invariants."""
    self._last_check = datetime.now()
    violations: list[InvariantViolation] = []

    # Get stores
    stores = await self.subject.get_stores()

    # Check store health (no grace period per CONTEXT.md)
    violations.extend(self.checker.check_stores_up(stores))

    # Check metrics for each up store
    for store in stores:
        if store.state == "Up":
            try:
                metrics = await self.subject.get_store_metrics(store.id)

                if v := self.checker.check_latency(metrics):
                    violations.append(v)
                if v := self.checker.check_disk_space(metrics):
                    violations.append(v)
            except Exception as e:
                # Log but don't crash on metrics fetch failure
                print(f"Failed to get metrics for store {store.id}: {e}")

    # Track stats
    self._invariant_count = 3  # stores_up, latency, disk_space
    self._violation_count = len(violations)

    # Create/update tickets for violations
    if violations:
        batch_key = f"batch-{datetime.now().isoformat()}"
        for v in violations:
            await db.create_or_update_ticket(v, batch_key=batch_key)

    # Auto-resolve cleared violations (per CONTEXT.md)
    current_keys = {make_violation_key(v) for v in violations}
    resolved_count = await db.auto_resolve_cleared(current_keys)
    if resolved_count > 0:
        print(f"Auto-resolved {resolved_count} ticket(s)")
```

2. Implement `_log_heartbeat(self)`:
```python
def _log_heartbeat(self) -> None:
    """Output periodic status message per CONTEXT.md."""
    status = "all passing" if self._violation_count == 0 else f"{self._violation_count} violations"
    print(f"Check complete: {self._invariant_count} invariants, {status}")
```

3. Update `monitor/__init__.py` to export MonitorLoop:
```python
from operator_core.monitor.types import Ticket, TicketStatus, make_violation_key
from operator_core.monitor.loop import MonitorLoop

__all__ = ["Ticket", "TicketStatus", "make_violation_key", "MonitorLoop"]
```

4. Add necessary imports to loop.py:
- `from operator_core.db import TicketDB`
- `from operator_core.monitor.types import make_violation_key`
- `from operator_tikv.invariants import InvariantChecker, InvariantViolation`
- `from operator_tikv.subject import TiKVSubject`
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator && uv run python -c "
import asyncio
from pathlib import Path
from datetime import datetime
from unittest.mock import AsyncMock, MagicMock
from operator_core.monitor import MonitorLoop
from operator_core.types import Store, StoreMetrics
from operator_tikv.invariants import InvariantChecker
import tempfile

async def test():
    with tempfile.TemporaryDirectory() as tmp:
        db_path = Path(tmp) / 'test.db'

        # Mock subject
        subject = MagicMock()
        subject.get_stores = AsyncMock(return_value=[
            Store(id='1', address='tikv-1:20160', state='Up'),
            Store(id='2', address='tikv-2:20160', state='Down'),  # Will trigger violation
        ])
        subject.get_store_metrics = AsyncMock(return_value=StoreMetrics(
            store_id='1',
            qps=100.0,
            latency_p99_ms=50.0,  # Under threshold
            disk_used_bytes=30_000_000_000,
            disk_total_bytes=100_000_000_000,  # 30% - under threshold
            cpu_percent=50.0,
            raft_lag=0,
        ))

        checker = InvariantChecker()
        loop = MonitorLoop(
            subject=subject,
            checker=checker,
            db_path=db_path,
            interval_seconds=1.0,
        )

        # Run single check cycle
        from operator_core.db import TicketDB
        async with TicketDB(db_path) as db:
            await loop._check_cycle(db)

            # Should have 1 violation (store 2 down)
            assert loop._violation_count == 1

            # Should have created ticket
            tickets = await db.list_tickets()
            assert len(tickets) == 1
            assert tickets[0].invariant_name == 'store_down'
            assert tickets[0].store_id == '2'

            print('MonitorLoop check cycle OK')

asyncio.run(test())
"
```
  </verify>
  <done>MonitorLoop runs check cycles, creates tickets for violations, auto-resolves cleared violations, and outputs heartbeat messages.</done>
</task>

</tasks>

<verification>
1. MonitorLoop imports: `from operator_core.monitor import MonitorLoop`
2. Task 1 verification script confirms class structure
3. Task 2 verification script confirms:
   - Check cycle runs and detects violations
   - Tickets are created for violations
   - Heartbeat logs violation count
</verification>

<success_criteria>
- MonitorLoop class implements daemon pattern with signal handling
- Check cycle queries subject for stores and metrics
- InvariantChecker is called for each invariant type
- Tickets are created/updated for violations via TicketDB
- Auto-resolve works when violations clear
- Heartbeat outputs check status after each cycle
- Graceful shutdown on SIGINT/SIGTERM
</success_criteria>

<output>
After completion, create `.planning/phases/04-monitor-loop/04-02-SUMMARY.md`
</output>
