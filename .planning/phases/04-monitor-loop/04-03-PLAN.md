---
phase: 04-monitor-loop
plan: 03
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - packages/operator-core/src/operator_core/cli/tickets.py
  - packages/operator-core/src/operator_core/cli/monitor.py
  - packages/operator-core/src/operator_core/cli/main.py
autonomous: true

must_haves:
  truths:
    - "`operator tickets list` shows all tickets in table format"
    - "`operator tickets list --json` outputs JSON"
    - "`operator tickets resolve <id>` marks ticket resolved"
    - "`operator tickets hold <id>` prevents auto-resolve"
    - "`operator monitor` runs daemon until interrupted"
  artifacts:
    - path: "packages/operator-core/src/operator_core/cli/tickets.py"
      provides: "tickets subcommand group"
      exports: ["tickets_app"]
      contains: "@tickets_app.command"
    - path: "packages/operator-core/src/operator_core/cli/monitor.py"
      provides: "monitor daemon command"
      exports: ["monitor_app"]
      contains: "@monitor_app.command"
  key_links:
    - from: "packages/operator-core/src/operator_core/cli/main.py"
      to: "packages/operator-core/src/operator_core/cli/tickets.py"
      via: "add_typer"
      pattern: "app.add_typer.*tickets_app"
    - from: "packages/operator-core/src/operator_core/cli/main.py"
      to: "packages/operator-core/src/operator_core/cli/monitor.py"
      via: "add_typer"
      pattern: "app.add_typer.*monitor_app"
---

<objective>
Implement CLI commands for ticket management and monitor daemon.

Purpose: Enable users to interact with the monitoring system via command line. The tickets subcommand provides visibility into violations and manual control. The monitor command runs the daemon for continuous checking.

Output: `operator tickets` subcommand (list, resolve, hold) and `operator monitor` daemon command integrated into main CLI.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-monitor-loop/04-RESEARCH.md
@.planning/phases/04-monitor-loop/04-01-SUMMARY.md
@.planning/phases/04-monitor-loop/04-02-SUMMARY.md
@packages/operator-core/src/operator_core/cli/main.py
@packages/operator-core/src/operator_core/cli/deploy.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tickets subcommand group</name>
  <files>
    packages/operator-core/src/operator_core/cli/tickets.py
  </files>
  <action>
Create the tickets CLI subcommand per RESEARCH.md Pattern 4:

```python
"""Ticket management CLI commands."""

import asyncio
import json
from pathlib import Path

import typer
from rich.console import Console
from rich.table import Table

from operator_core.db import TicketDB
from operator_core.monitor import TicketStatus

tickets_app = typer.Typer(help="Manage operator tickets")

# Default database path per RESEARCH.md
DEFAULT_DB_PATH = Path.home() / ".operator" / "tickets.db"


def _get_db_path() -> Path:
    """Get database path, ensuring parent directory exists."""
    db_path = DEFAULT_DB_PATH
    db_path.parent.mkdir(parents=True, exist_ok=True)
    return db_path


@tickets_app.command("list")
def list_tickets(
    status: str = typer.Option(None, "--status", "-s", help="Filter by status (open, acknowledged, diagnosed, resolved)"),
    json_output: bool = typer.Option(False, "--json", "-j", help="Output as JSON"),
):
    """List all tickets."""

    async def _list():
        db_path = _get_db_path()
        status_filter = TicketStatus(status) if status else None

        async with TicketDB(db_path) as db:
            tickets = await db.list_tickets(status=status_filter)

        if json_output:
            data = [t.to_dict() for t in tickets]
            print(json.dumps(data, indent=2, default=str))
            return

        # Rich table output per RESEARCH.md Pattern 5
        console = Console()
        table = Table(title="Tickets")
        table.add_column("ID", justify="right", style="cyan")
        table.add_column("Status", style="green")
        table.add_column("Invariant")
        table.add_column("Store", justify="center")
        table.add_column("Count", justify="right")
        table.add_column("First Seen")
        table.add_column("Held", justify="center")

        for t in tickets:
            held_mark = "[red]HELD[/red]" if t.held else ""
            table.add_row(
                str(t.id),
                t.status.value,
                t.invariant_name,
                t.store_id or "-",
                str(t.occurrence_count),
                t.first_seen_at.strftime("%Y-%m-%d %H:%M:%S"),
                held_mark,
            )

        console.print(table)

    asyncio.run(_list())


@tickets_app.command("resolve")
def resolve_ticket(
    ticket_id: int = typer.Argument(..., help="Ticket ID to resolve"),
):
    """Manually resolve a ticket."""

    async def _resolve():
        db_path = _get_db_path()
        async with TicketDB(db_path) as db:
            ticket = await db.get_ticket(ticket_id)
            if ticket is None:
                print(f"Ticket {ticket_id} not found")
                raise typer.Exit(1)

            if ticket.status == TicketStatus.RESOLVED:
                print(f"Ticket {ticket_id} is already resolved")
                return

            if ticket.held:
                # Per CONTEXT.md: resolve overrides hold for manual resolution
                await db.unhold_ticket(ticket_id)

            await db.resolve_ticket(ticket_id)
            print(f"Resolved ticket {ticket_id}")

    asyncio.run(_resolve())


@tickets_app.command("hold")
def hold_ticket(
    ticket_id: int = typer.Argument(..., help="Ticket ID to hold"),
):
    """Prevent auto-resolve while investigating a ticket."""

    async def _hold():
        db_path = _get_db_path()
        async with TicketDB(db_path) as db:
            ticket = await db.get_ticket(ticket_id)
            if ticket is None:
                print(f"Ticket {ticket_id} not found")
                raise typer.Exit(1)

            if ticket.held:
                print(f"Ticket {ticket_id} is already held")
                return

            await db.hold_ticket(ticket_id)
            print(f"Holding ticket {ticket_id} - will not auto-resolve")

    asyncio.run(_hold())


@tickets_app.command("unhold")
def unhold_ticket(
    ticket_id: int = typer.Argument(..., help="Ticket ID to unhold"),
):
    """Allow auto-resolve for a previously held ticket."""

    async def _unhold():
        db_path = _get_db_path()
        async with TicketDB(db_path) as db:
            ticket = await db.get_ticket(ticket_id)
            if ticket is None:
                print(f"Ticket {ticket_id} not found")
                raise typer.Exit(1)

            if not ticket.held:
                print(f"Ticket {ticket_id} is not held")
                return

            await db.unhold_ticket(ticket_id)
            print(f"Ticket {ticket_id} can now auto-resolve")

    asyncio.run(_unhold())
```

Key implementation details:
- Use typer.Typer() subcommand group
- asyncio.run() to execute async database operations in sync CLI commands
- Rich Table for formatted output, JSON for automation
- Status filter uses TicketStatus enum validation
- Hold/unhold commands per CONTEXT.md
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator && uv run python -c "
from operator_core.cli.tickets import tickets_app
import typer.testing

runner = typer.testing.CliRunner()

# Check help works
result = runner.invoke(tickets_app, ['--help'])
assert result.exit_code == 0
assert 'list' in result.output
assert 'resolve' in result.output
assert 'hold' in result.output

print('tickets CLI structure OK')
"
```
  </verify>
  <done>tickets subcommand group with list, resolve, hold, unhold commands implemented.</done>
</task>

<task type="auto">
  <name>Task 2: Create monitor command and integrate into main CLI</name>
  <files>
    packages/operator-core/src/operator_core/cli/monitor.py
    packages/operator-core/src/operator_core/cli/main.py
  </files>
  <action>
1. Create `cli/monitor.py`:

```python
"""Monitor daemon CLI command."""

import asyncio
import os
from pathlib import Path

import httpx
import typer

from operator_core.monitor import MonitorLoop
from operator_tikv.invariants import InvariantChecker
from operator_tikv.pd_client import PDClient
from operator_tikv.prom_client import PrometheusClient
from operator_tikv.subject import TiKVSubject

monitor_app = typer.Typer(help="Run the operator monitor daemon")

# Default database path
DEFAULT_DB_PATH = Path.home() / ".operator" / "tickets.db"


@monitor_app.command("run")
def run_monitor(
    interval: float = typer.Option(30.0, "--interval", "-i", help="Check interval in seconds"),
    pd_endpoint: str = typer.Option(
        None, "--pd", envvar="PD_ENDPOINT", help="PD endpoint (e.g., http://pd:2379)"
    ),
    prometheus_url: str = typer.Option(
        None, "--prometheus", envvar="PROMETHEUS_URL", help="Prometheus URL (e.g., http://prometheus:9090)"
    ),
    db_path: Path = typer.Option(DEFAULT_DB_PATH, "--db", help="Path to tickets database"),
):
    """
    Run the monitor daemon.

    Continuously checks invariants at the specified interval and creates
    tickets for violations. Runs until interrupted with Ctrl+C.

    Environment variables:
        PD_ENDPOINT: PD API endpoint
        PROMETHEUS_URL: Prometheus API URL
    """
    # Validate endpoints
    if not pd_endpoint:
        pd_endpoint = os.environ.get("PD_ENDPOINT", "http://localhost:2379")
    if not prometheus_url:
        prometheus_url = os.environ.get("PROMETHEUS_URL", "http://localhost:9090")

    # Ensure database directory exists
    db_path.parent.mkdir(parents=True, exist_ok=True)

    print(f"Starting monitor daemon...")
    print(f"  PD endpoint: {pd_endpoint}")
    print(f"  Prometheus: {prometheus_url}")
    print(f"  Interval: {interval}s")
    print(f"  Database: {db_path}")
    print()
    print("Press Ctrl+C to stop")
    print()

    async def _run():
        async with httpx.AsyncClient(base_url=pd_endpoint, timeout=10.0) as pd_http:
            async with httpx.AsyncClient(base_url=prometheus_url, timeout=10.0) as prom_http:
                subject = TiKVSubject(
                    pd=PDClient(http=pd_http),
                    prom=PrometheusClient(http=prom_http),
                )
                checker = InvariantChecker()

                loop = MonitorLoop(
                    subject=subject,
                    checker=checker,
                    db_path=db_path,
                    interval_seconds=interval,
                )

                await loop.run()

    asyncio.run(_run())
```

2. Update `cli/main.py` to add tickets and monitor subcommands:

```python
"""Operator CLI - AI-powered operator for distributed systems."""

import typer

from operator_core.cli.deploy import deploy_app
from operator_core.cli.tickets import tickets_app
from operator_core.cli.monitor import monitor_app

app = typer.Typer(
    name="operator",
    help="AI-powered operator for distributed systems",
    no_args_is_help=True,
)

# Add command groups
app.add_typer(deploy_app, name="deploy")
app.add_typer(tickets_app, name="tickets")
app.add_typer(monitor_app, name="monitor")


def main() -> None:
    """Entry point for the CLI."""
    app()


if __name__ == "__main__":
    main()
```

Key implementation details:
- Use envvar parameter for environment variable fallback
- Print startup configuration for visibility
- Create httpx clients with timeout for HTTP operations
- Wire up TiKVSubject, InvariantChecker, MonitorLoop
- Ensure db_path parent directory exists before running
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator && uv run python -c "
from operator_core.cli.main import app
import typer.testing

runner = typer.testing.CliRunner()

# Check main CLI has all subcommands
result = runner.invoke(app, ['--help'])
assert result.exit_code == 0
assert 'deploy' in result.output
assert 'tickets' in result.output
assert 'monitor' in result.output

# Check monitor subcommand
result = runner.invoke(app, ['monitor', '--help'])
assert result.exit_code == 0
assert 'run' in result.output

# Check tickets subcommand
result = runner.invoke(app, ['tickets', '--help'])
assert result.exit_code == 0
assert 'list' in result.output

print('CLI integration OK')
"
```

And verify the actual commands work:
```bash
cd /Users/jrtipton/x/operator && uv run operator --help
cd /Users/jrtipton/x/operator && uv run operator tickets --help
cd /Users/jrtipton/x/operator && uv run operator monitor --help
```
  </verify>
  <done>CLI commands integrated: `operator tickets list/resolve/hold` and `operator monitor run` work correctly.</done>
</task>

</tasks>

<verification>
1. `uv run operator --help` shows deploy, tickets, monitor subcommands
2. `uv run operator tickets --help` shows list, resolve, hold, unhold commands
3. `uv run operator monitor --help` shows run command with options
4. `uv run operator tickets list` works (empty table is OK for fresh DB)
5. Task verification scripts pass
</verification>

<success_criteria>
- `operator tickets list` displays tickets in Rich table format
- `operator tickets list --json` outputs JSON array
- `operator tickets list --status open` filters by status
- `operator tickets resolve <id>` resolves a ticket
- `operator tickets hold <id>` marks ticket as held
- `operator tickets unhold <id>` removes hold
- `operator monitor run` starts daemon with status output
- `operator monitor run --interval 10` configures check interval
- Environment variables PD_ENDPOINT and PROMETHEUS_URL work for configuration
</success_criteria>

<output>
After completion, create `.planning/phases/04-monitor-loop/04-03-SUMMARY.md`
</output>
