---
phase: 04-monitor-loop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/operator-core/src/operator_core/monitor/__init__.py
  - packages/operator-core/src/operator_core/monitor/types.py
  - packages/operator-core/src/operator_core/db/__init__.py
  - packages/operator-core/src/operator_core/db/schema.py
  - packages/operator-core/src/operator_core/db/tickets.py
  - packages/operator-core/pyproject.toml
autonomous: true

must_haves:
  truths:
    - "Tickets persist in SQLite across process restarts"
    - "Same violation creates/updates single ticket (deduplication works)"
    - "Ticket status transitions are enforced (open -> acknowledged -> diagnosed -> resolved)"
    - "Auto-resolve respects held flag"
  artifacts:
    - path: "packages/operator-core/src/operator_core/monitor/types.py"
      provides: "Ticket dataclass and TicketStatus enum"
      exports: ["Ticket", "TicketStatus", "make_violation_key"]
    - path: "packages/operator-core/src/operator_core/db/schema.py"
      provides: "SQLite schema SQL"
      contains: "CREATE TABLE IF NOT EXISTS tickets"
    - path: "packages/operator-core/src/operator_core/db/tickets.py"
      provides: "TicketDB async context manager"
      exports: ["TicketDB"]
  key_links:
    - from: "packages/operator-core/src/operator_core/db/tickets.py"
      to: "packages/operator-core/src/operator_core/db/schema.py"
      via: "schema import"
      pattern: "from.*schema import"
    - from: "packages/operator-core/src/operator_core/db/tickets.py"
      to: "packages/operator-core/src/operator_core/monitor/types.py"
      via: "Ticket type import"
      pattern: "from.*types import.*Ticket"
---

<objective>
Implement the ticket database foundation for Phase 4 Monitor Loop.

Purpose: Create the persistence layer that stores tickets for invariant violations. Tickets must persist across restarts, support deduplication (same violation updates existing ticket), and track status transitions.

Output: TicketDB class with SQLite persistence, Ticket dataclass, TicketStatus enum, and deduplication logic via violation_key.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-monitor-loop/04-RESEARCH.md
@packages/operator-tikv/src/operator_tikv/invariants.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Ticket types and status enum</name>
  <files>
    packages/operator-core/src/operator_core/monitor/__init__.py
    packages/operator-core/src/operator_core/monitor/types.py
  </files>
  <action>
Create the monitor module directory and types:

1. Create `monitor/__init__.py` with exports: `Ticket`, `TicketStatus`, `make_violation_key`

2. Create `monitor/types.py` with:
   - `TicketStatus(str, Enum)` with values: OPEN, ACKNOWLEDGED, DIAGNOSED, RESOLVED
   - `@dataclass Ticket` with fields per RESEARCH.md schema:
     - id: int | None
     - violation_key: str
     - invariant_name: str
     - message: str
     - severity: str (default "warning")
     - first_seen_at: datetime
     - last_seen_at: datetime
     - status: TicketStatus (default OPEN)
     - store_id: str | None (default None)
     - held: bool (default False)
     - batch_key: str | None (default None)
     - occurrence_count: int (default 1)
     - resolved_at: datetime | None (default None)
     - diagnosis: str | None (default None) — for Phase 5
     - metric_snapshot: dict[str, Any] | None (default None)
     - created_at: datetime | None (default None)
     - updated_at: datetime | None (default None)
   - `to_dict()` method using dataclasses.asdict() with status.value conversion
   - `make_violation_key(violation: InvariantViolation) -> str` function:
     - Per CONTEXT.md: key = invariant_name + store_id
     - Return f"{violation.invariant_name}:{violation.store_id}" if store_id else invariant_name

Use imports from operator_tikv.invariants.InvariantViolation for the violation key function.
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator && uv run python -c "
from operator_core.monitor import Ticket, TicketStatus, make_violation_key
from operator_tikv.invariants import InvariantViolation
from datetime import datetime

# Test enum
assert TicketStatus.OPEN.value == 'open'
assert TicketStatus.RESOLVED.value == 'resolved'

# Test Ticket
t = Ticket(
    id=None,
    violation_key='store_down:1',
    invariant_name='store_down',
    message='Store 1 is down',
    severity='critical',
    first_seen_at=datetime.now(),
    last_seen_at=datetime.now(),
)
d = t.to_dict()
assert d['status'] == 'open'

# Test violation key
v = InvariantViolation(
    invariant_name='store_down',
    message='Store 1 is down',
    first_seen=datetime.now(),
    last_seen=datetime.now(),
    store_id='1',
)
assert make_violation_key(v) == 'store_down:1'
print('Types OK')
"
```
  </verify>
  <done>TicketStatus enum, Ticket dataclass, and make_violation_key function all import and work correctly.</done>
</task>

<task type="auto">
  <name>Task 2: Create SQLite schema and TicketDB class</name>
  <files>
    packages/operator-core/src/operator_core/db/__init__.py
    packages/operator-core/src/operator_core/db/schema.py
    packages/operator-core/src/operator_core/db/tickets.py
    packages/operator-core/pyproject.toml
  </files>
  <action>
Create the database module with SQLite persistence:

1. Add `aiosqlite>=0.20.0` to operator-core dependencies in pyproject.toml

2. Create `db/__init__.py` with export: `TicketDB`

3. Create `db/schema.py` with SCHEMA_SQL constant (per RESEARCH.md):
   - tickets table with all fields from Ticket dataclass
   - Indexes: idx_tickets_open_violation (violation_key WHERE status != 'resolved')
   - Indexes: idx_tickets_violation_time (violation_key, resolved_at)
   - Trigger: tickets_updated_at to auto-update updated_at on modification

4. Create `db/tickets.py` with TicketDB class:
   - `__init__(self, db_path: Path)` — store path, init _conn to None
   - `async __aenter__` — connect with aiosqlite, set row_factory=aiosqlite.Row, ensure schema
   - `async __aexit__` — close connection
   - `async _ensure_schema()` — executescript(SCHEMA_SQL), commit

   Core methods:
   - `async create_or_update_ticket(violation: InvariantViolation, metric_snapshot: dict | None = None, batch_key: str | None = None) -> Ticket`
     - Generate violation_key via make_violation_key
     - Check for existing open ticket (status != 'resolved')
     - If exists: UPDATE occurrence_count, last_seen_at, message; return updated
     - If not: INSERT new ticket; return created

   - `async get_ticket(ticket_id: int) -> Ticket | None` — fetch by ID

   - `async list_tickets(status: TicketStatus | None = None) -> list[Ticket]`
     - If status provided, filter by it
     - Order by created_at DESC

   - `async resolve_ticket(ticket_id: int) -> None`
     - UPDATE status='resolved', resolved_at=now
     - Only if not held (WHERE held = 0)

   - `async hold_ticket(ticket_id: int) -> None`
     - UPDATE held=1

   - `async unhold_ticket(ticket_id: int) -> None`
     - UPDATE held=0

   - `async auto_resolve_cleared(current_violation_keys: set[str]) -> int`
     - Resolve open tickets whose violation_key is NOT in current_violation_keys
     - Respect held flag (WHERE held = 0)
     - Return count of resolved tickets

   Helper method:
   - `_row_to_ticket(row: aiosqlite.Row) -> Ticket` — convert DB row to Ticket dataclass
     - Parse datetime strings to datetime objects
     - Parse status string to TicketStatus enum
     - Parse metric_snapshot JSON string to dict

Per RESEARCH.md Pitfall 4: Use transactions for atomicity in create_or_update.
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator && uv sync && uv run python -c "
import asyncio
from pathlib import Path
from datetime import datetime
from operator_core.db import TicketDB
from operator_core.monitor import TicketStatus
from operator_tikv.invariants import InvariantViolation
import tempfile

async def test():
    with tempfile.TemporaryDirectory() as tmp:
        db_path = Path(tmp) / 'test.db'
        async with TicketDB(db_path) as db:
            # Create ticket
            v = InvariantViolation(
                invariant_name='store_down',
                message='Store 1 is down',
                first_seen=datetime.now(),
                last_seen=datetime.now(),
                store_id='1',
            )
            t1 = await db.create_or_update_ticket(v)
            assert t1.id is not None
            assert t1.occurrence_count == 1

            # Update same violation
            t2 = await db.create_or_update_ticket(v)
            assert t2.id == t1.id
            assert t2.occurrence_count == 2

            # List tickets
            tickets = await db.list_tickets()
            assert len(tickets) == 1

            # Hold ticket
            await db.hold_ticket(t1.id)

            # Try auto-resolve (should not resolve due to hold)
            count = await db.auto_resolve_cleared(set())
            assert count == 0

            # Unhold and resolve
            await db.unhold_ticket(t1.id)
            await db.resolve_ticket(t1.id)

            t3 = await db.get_ticket(t1.id)
            assert t3.status == TicketStatus.RESOLVED

            print('TicketDB OK')

asyncio.run(test())
"
```
  </verify>
  <done>TicketDB class connects to SQLite, creates/updates/resolves tickets with deduplication, and respects held flag on auto-resolve.</done>
</task>

</tasks>

<verification>
1. `uv sync` succeeds with aiosqlite installed
2. Types import: `from operator_core.monitor import Ticket, TicketStatus, make_violation_key`
3. Database imports: `from operator_core.db import TicketDB`
4. Task 1 and Task 2 verification scripts pass
</verification>

<success_criteria>
- Ticket dataclass stores all fields per RESEARCH.md schema
- TicketStatus enum enforces valid status values
- make_violation_key generates consistent deduplication keys
- TicketDB persists tickets to SQLite file
- Deduplication works: same violation updates existing open ticket
- held flag prevents auto-resolution
- All tests pass without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-monitor-loop/04-01-SUMMARY.md`
</output>
