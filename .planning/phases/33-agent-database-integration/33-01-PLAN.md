---
phase: 33-agent-database-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/operator-core/src/operator_core/agent_lab/ticket_ops.py
autonomous: true

must_haves:
  truths:
    - "TicketOpsDB context manager initializes schema on first connection"
    - "poll_for_open_ticket returns None on empty database (no crash)"
    - "Schema initialization is idempotent (safe to call multiple times)"
  artifacts:
    - path: "packages/operator-core/src/operator_core/agent_lab/ticket_ops.py"
      provides: "TicketOpsDB context manager with schema initialization"
      contains: "class TicketOpsDB"
      exports: ["TicketOpsDB"]
  key_links:
    - from: "ticket_ops.py"
      to: "operator_core.db.schema"
      via: "_ensure_schema imports SCHEMA_SQL"
      pattern: "from operator_core.db.schema import"
---

<objective>
Create TicketOpsDB context manager with automatic schema initialization.

Purpose: Fix "no such table: tickets" error when agent subprocess queries a fresh database. The demo script deletes tickets.db for clean state, but the current raw sqlite3.connect() doesn't initialize schema.

Output: Modified ticket_ops.py with TicketOpsDB class following AuditLogDB pattern
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/33-agent-database-integration/33-RESEARCH.md

# Pattern to follow
@packages/operator-core/src/operator_core/db/audit_log.py

# Schema definitions
@packages/operator-core/src/operator_core/db/schema.py

# Current implementation to refactor
@packages/operator-core/src/operator_core/agent_lab/ticket_ops.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TicketOpsDB context manager</name>
  <files>packages/operator-core/src/operator_core/agent_lab/ticket_ops.py</files>
  <action>
Refactor ticket_ops.py to add TicketOpsDB class following AuditLogDB pattern:

1. Add TicketOpsDB class with:
   - __init__(self, db_path: Path) storing db_path and _conn = None
   - __enter__ that connects, sets row_factory, calls _ensure_schema(), returns self
   - __exit__ that closes connection
   - _ensure_schema() that imports and executes SCHEMA_SQL and ACTIONS_SCHEMA_SQL from operator_core.db.schema

2. Add instance methods (move from module-level functions):
   - poll_for_open_ticket(self) -> Ticket | None - uses self._conn
   - update_ticket_resolved(self, ticket_id: int, summary: str) -> None
   - update_ticket_escalated(self, ticket_id: int, reason: str) -> None

3. Keep existing module-level functions but mark them as deprecated (for backward compatibility):
   - Add deprecation warning import: from warnings import warn
   - Each function should warn and delegate to TicketOpsDB internally
   - Pattern: def poll_for_open_ticket(db_path): warn("deprecated"); with TicketOpsDB(db_path) as db: return db.poll_for_open_ticket()

4. Ensure imports are correct:
   - Add: from typing import Any
   - Keep: from operator_core.monitor.types import Ticket, TicketStatus

Key: Follow AuditLogDB pattern exactly - context manager ensures schema exists before any query.
  </action>
  <verify>
Run: cd /Users/jrtipton/x/operator && python -c "from operator_core.agent_lab.ticket_ops import TicketOpsDB; print('Import OK')"
  </verify>
  <done>
- TicketOpsDB class exists with __enter__/__exit__ and _ensure_schema
- Instance methods poll_for_open_ticket, update_ticket_resolved, update_ticket_escalated exist
- Module-level functions still work (backward compatibility with deprecation warnings)
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify schema initialization works</name>
  <files>packages/operator-core/src/operator_core/agent_lab/ticket_ops.py</files>
  <action>
Test that TicketOpsDB initializes schema correctly on empty database:

1. Create a quick test script inline:
```python
import tempfile
from pathlib import Path
from operator_core.agent_lab.ticket_ops import TicketOpsDB

# Test 1: Fresh database - should not error
with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as tmp:
    db_path = Path(tmp.name)
db_path.unlink()  # Ensure truly empty

with TicketOpsDB(db_path) as db:
    ticket = db.poll_for_open_ticket()
    assert ticket is None, "Expected None for empty db"
    print("Test 1 PASSED: Fresh database works")

# Test 2: Idempotent - opening twice should work
with TicketOpsDB(db_path) as db:
    ticket = db.poll_for_open_ticket()
    assert ticket is None
    print("Test 2 PASSED: Idempotent schema init")

db_path.unlink()
print("All tests passed!")
```

2. Run the test script and verify it passes

3. If any test fails, fix the TicketOpsDB implementation
  </action>
  <verify>
Run the inline test script - should print "All tests passed!" without any errors or "no such table" exceptions.
  </verify>
  <done>
- Schema initialization works on empty database
- No "sqlite3.OperationalError: no such table" errors
- Idempotent behavior verified (multiple opens work)
  </done>
</task>

</tasks>

<verification>
1. Import check: `python -c "from operator_core.agent_lab.ticket_ops import TicketOpsDB"`
2. Fresh database test passes (no "no such table" errors)
3. Existing module-level functions still work (backward compatibility)
</verification>

<success_criteria>
- TicketOpsDB context manager exists following AuditLogDB pattern
- Schema initialization happens automatically in __enter__
- poll_for_open_ticket returns None on empty database (not crash)
- Backward compatibility maintained for existing callers
</success_criteria>

<output>
After completion, create `.planning/phases/33-agent-database-integration/33-01-SUMMARY.md`
</output>
