---
phase: 33-agent-database-integration
plan: 02
type: execute
wave: 2
depends_on: ["33-01"]
files_modified:
  - packages/operator-core/src/operator_core/agent_lab/loop.py
autonomous: true

must_haves:
  truths:
    - "Agent loop responds to SIGTERM within 2 seconds"
    - "Current session is marked as escalated on SIGTERM"
    - "Agent loop uses TicketOpsDB for schema-safe database access"
  artifacts:
    - path: "packages/operator-core/src/operator_core/agent_lab/loop.py"
      provides: "Signal handling and TicketOpsDB integration"
      contains: "signal.signal"
      contains: "threading.Event"
  key_links:
    - from: "loop.py"
      to: "ticket_ops.TicketOpsDB"
      via: "context manager usage"
      pattern: "with TicketOpsDB"
    - from: "loop.py"
      to: "signal handlers"
      via: "signal.signal registration"
      pattern: "signal\\.signal\\(signal\\.SIG"
---

<objective>
Add graceful shutdown handling to agent loop with SIGTERM support.

Purpose: Enable clean demo restarts by marking in-progress sessions as escalated when agent receives shutdown signal. Also integrate TicketOpsDB for schema-safe database access.

Output: Modified loop.py with signal handling and TicketOpsDB usage
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/33-agent-database-integration/33-RESEARCH.md

# Pattern reference for signal handling
@packages/operator-core/src/operator_core/monitor/loop.py

# TicketOpsDB from Plan 01 (will exist after Plan 01 completes)
@packages/operator-core/src/operator_core/agent_lab/ticket_ops.py

# Current implementation to modify
@packages/operator-core/src/operator_core/agent_lab/loop.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add signal handling to run_agent_loop</name>
  <files>packages/operator-core/src/operator_core/agent_lab/loop.py</files>
  <action>
Modify loop.py to add graceful shutdown:

1. Add imports at top:
   - import signal
   - import threading

2. Update imports from ticket_ops:
   - Change: from .ticket_ops import poll_for_open_ticket, update_ticket_escalated, update_ticket_resolved
   - To: from .ticket_ops import TicketOpsDB

3. In run_agent_loop function:

   a. Create shutdown coordination:
      ```python
      shutdown = threading.Event()
      current_session: tuple[AuditLogDB, str, int] | None = None  # (audit_db, session_id, ticket_id)
      ```

   b. Add signal handler function INSIDE run_agent_loop (closure captures local vars):
      ```python
      def handle_shutdown(signum, frame):
          sig_name = signal.Signals(signum).name
          print(f"\nReceived {sig_name}, shutting down gracefully...")
          shutdown.set()

          # Mark current session as escalated (DEMO-07)
          if current_session is not None:
              audit_db, session_id, ticket_id = current_session
              try:
                  audit_db.complete_session(session_id, "escalated", f"Interrupted by {sig_name}")
                  with TicketOpsDB(db_path) as ticket_db:
                      ticket_db.update_ticket_escalated(ticket_id, f"Agent shutdown ({sig_name})")
              except Exception as e:
                  print(f"Error during shutdown cleanup: {e}")
      ```

   c. Register signal handlers:
      ```python
      signal.signal(signal.SIGINT, handle_shutdown)
      signal.signal(signal.SIGTERM, handle_shutdown)
      ```

4. Replace `while True:` with `while not shutdown.is_set():`

5. Replace `time.sleep(1)` with interruptible wait:
   ```python
   if shutdown.wait(timeout=1.0):
       break
   ```

6. Update ticket operations to use TicketOpsDB:
   - Replace: ticket = poll_for_open_ticket(db_path)
   - With:
     ```python
     with TicketOpsDB(db_path) as ticket_db:
         ticket = ticket_db.poll_for_open_ticket()
     ```

   - Replace: update_ticket_resolved(db_path, ticket.id, summary)
   - With:
     ```python
     with TicketOpsDB(db_path) as ticket_db:
         ticket_db.update_ticket_resolved(ticket.id, summary)
     ```

   - Same for update_ticket_escalated

7. Track current session:
   - After session_id = audit_db.create_session():
     current_session = (audit_db, session_id, ticket.id)
   - In finally block or after processing:
     current_session = None

8. Keep the try/except KeyboardInterrupt but simplify - signal handler already sets shutdown:
   - Remove the explicit KeyboardInterrupt handling (signal handler covers it)
   - Or keep it as backup that just sets shutdown.set()
  </action>
  <verify>
Run: cd /Users/jrtipton/x/operator && python -c "from operator_core.agent_lab.loop import run_agent_loop; print('Import OK')"
  </verify>
  <done>
- Signal handlers registered for SIGINT and SIGTERM
- shutdown threading.Event used for coordination
- current_session tracking for cleanup on signal
- TicketOpsDB used instead of module-level functions
- time.sleep(1) replaced with shutdown.wait(timeout=1.0)
  </done>
</task>

<task type="auto">
  <name>Task 2: Test signal handling behavior</name>
  <files>packages/operator-core/src/operator_core/agent_lab/loop.py</files>
  <action>
Verify signal handling works correctly with a quick test:

1. Create test that verifies signal handler function behavior:
```python
import signal
import threading
from pathlib import Path
from unittest.mock import MagicMock, patch

# Test that signal handler sets shutdown event and marks session escalated
def test_signal_handler_behavior():
    # Import after potential modifications
    from operator_core.agent_lab import loop

    # Create mock objects
    mock_audit_db = MagicMock()
    mock_ticket_ops_db = MagicMock()

    # Simulate the closure state
    shutdown = threading.Event()
    current_session = (mock_audit_db, "test-session-id", 123)
    db_path = Path("/tmp/test.db")

    # Create handler like in the actual code
    def handle_shutdown(signum, frame):
        sig_name = signal.Signals(signum).name
        shutdown.set()
        if current_session is not None:
            audit_db, session_id, ticket_id = current_session
            audit_db.complete_session(session_id, "escalated", f"Interrupted by {sig_name}")

    # Invoke handler
    handle_shutdown(signal.SIGTERM, None)

    # Verify
    assert shutdown.is_set(), "Shutdown event should be set"
    mock_audit_db.complete_session.assert_called_once()
    call_args = mock_audit_db.complete_session.call_args[0]
    assert call_args[0] == "test-session-id"
    assert call_args[1] == "escalated"
    assert "SIGTERM" in call_args[2]
    print("Signal handler behavior test PASSED")

test_signal_handler_behavior()
print("All signal tests passed!")
```

2. Run the test script to verify signal handler logic is correct

3. Verify import still works after modifications
  </action>
  <verify>
- Import check passes: python -c "from operator_core.agent_lab.loop import run_agent_loop"
- Signal handler test passes
  </verify>
  <done>
- Signal handler correctly sets shutdown event
- Signal handler marks session as escalated
- Loop module imports without errors
  </done>
</task>

</tasks>

<verification>
1. Import check: `python -c "from operator_core.agent_lab.loop import run_agent_loop"`
2. Code inspection shows signal.signal() calls for SIGINT and SIGTERM
3. Code uses threading.Event for shutdown coordination
4. Code uses shutdown.wait(timeout=1.0) instead of time.sleep(1)
</verification>

<success_criteria>
- Agent loop uses TicketOpsDB for schema-safe database access
- SIGINT/SIGTERM handlers registered in run_agent_loop
- Current session marked as escalated on shutdown signal
- Interruptible sleep using threading.Event.wait(timeout)
- All existing functionality preserved
</success_criteria>

<output>
After completion, create `.planning/phases/33-agent-database-integration/33-02-SUMMARY.md`
</output>
