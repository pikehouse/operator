---
phase: 38-chaos-expansion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - subjects/tikv/docker-compose.yaml
  - eval/src/eval/types.py
  - eval/src/eval/subjects/tikv/chaos.py
  - eval/src/eval/subjects/tikv/subject.py
autonomous: true

must_haves:
  truths:
    - "TiKV containers have NET_ADMIN capability for tc/iptables commands"
    - "Latency chaos injects network delay on TiKV container using tc netem"
    - "Disk pressure chaos fills disk space on TiKV container using fallocate"
    - "Network partition chaos isolates TiKV node from cluster using iptables DROP rules"
    - "All chaos types have cleanup functions that revert changes"
    - "TiKVEvalSubject.get_chaos_types() returns all four chaos types"
  artifacts:
    - path: "subjects/tikv/docker-compose.yaml"
      provides: "NET_ADMIN capability for tikv0, tikv1, tikv2 containers"
      contains: "cap_add"
    - path: "eval/src/eval/types.py"
      provides: "ChaosType enum with LATENCY, DISK_PRESSURE, NETWORK_PARTITION"
      contains: "LATENCY"
    - path: "eval/src/eval/subjects/tikv/chaos.py"
      provides: "inject_latency_chaos, inject_disk_pressure, inject_network_partition functions"
      exports: ["inject_latency_chaos", "inject_disk_pressure", "inject_network_partition"]
    - path: "eval/src/eval/subjects/tikv/subject.py"
      provides: "TiKVEvalSubject dispatching all chaos types"
      contains: "latency"
  key_links:
    - from: "eval/src/eval/subjects/tikv/subject.py"
      to: "eval/src/eval/subjects/tikv/chaos.py"
      via: "import and dispatch in inject_chaos()"
      pattern: "inject_latency_chaos|inject_disk_pressure|inject_network_partition"
---

<objective>
Implement three new TiKV chaos types: latency injection (tc netem), disk pressure (fallocate), and network partition (iptables).

Purpose: Enable evaluation of Claude's diagnostic capabilities across a variety of failure modes beyond simple node kills.

Output: Extended chaos.py with three new chaos functions, updated TiKVEvalSubject, and docker-compose.yaml with required capabilities.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-chaos-expansion/38-RESEARCH.md

# Existing implementation patterns
@eval/src/eval/subjects/tikv/chaos.py
@eval/src/eval/subjects/tikv/subject.py
@eval/src/eval/types.py
@subjects/tikv/docker-compose.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add NET_ADMIN capability and update types</name>
  <files>
    subjects/tikv/docker-compose.yaml
    eval/src/eval/types.py
  </files>
  <action>
    1. Update subjects/tikv/docker-compose.yaml:
       - Add `cap_add: [NET_ADMIN]` to tikv0, tikv1, tikv2 services
       - This enables tc and iptables commands inside containers
       - Place cap_add after the volumes section for each tikv service

    2. Update eval/src/eval/types.py:
       - Add new values to ChaosType enum: LATENCY = "latency", DISK_PRESSURE = "disk_pressure", NETWORK_PARTITION = "network_partition"
       - Keep NODE_KILL as first entry
  </action>
  <verify>
    grep -q "cap_add" subjects/tikv/docker-compose.yaml && echo "cap_add found"
    grep -q "LATENCY" eval/src/eval/types.py && echo "LATENCY enum found"
  </verify>
  <done>
    TiKV containers configured with NET_ADMIN capability; ChaosType enum has all four chaos types
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement chaos injection functions</name>
  <files>
    eval/src/eval/subjects/tikv/chaos.py
  </files>
  <action>
    Add three new async functions to chaos.py following the existing kill_random_tikv pattern:

    1. inject_latency_chaos(docker, target_container, min_ms, max_ms) -> dict:
       - Use tc netem: `tc qdisc add dev eth0 root netem delay {avg}ms {variation}ms`
       - avg = (min_ms + max_ms) // 2, variation = (max_ms - min_ms) // 2
       - Return dict with chaos_type, target_container, min_ms, max_ms, interface

    2. cleanup_latency_chaos(docker, target_container) -> None:
       - Run: `tc qdisc del dev eth0 root`
       - Ignore errors if rule doesn't exist (container may have been restarted)

    3. inject_disk_pressure(docker, target_container, fill_percent, target_path="/data") -> dict:
       - Validate fill_percent 0-100
       - Get available space: `df --output=avail {target_path} | tail -n 1`
       - Calculate fill_bytes = avail_kb * (fill_percent / 100) * 1024
       - Create fill file: `fallocate -l {fill_bytes} {target_path}/chaos-fill-{timestamp}.tmp`
       - Return dict with chaos_type, target_container, fill_percent, fill_file, fill_bytes

    4. cleanup_disk_pressure(docker, target_container, fill_file) -> None:
       - Run: `rm -f {fill_file}`

    5. inject_network_partition(docker, isolated_container, target_ips) -> dict:
       - For each target IP: `iptables -I OUTPUT -d {ip} -j DROP` and `iptables -I INPUT -s {ip} -j DROP`
       - Return dict with chaos_type, isolated_container, target_ips

    6. cleanup_network_partition(docker, isolated_container, target_ips) -> None:
       - For each target IP: `iptables -D OUTPUT -d {ip} -j DROP || true` and `iptables -D INPUT -s {ip} -j DROP || true`

    7. get_tikv_peer_ips(docker, exclude_container) -> list[str]:
       - Get IPs of other TiKV containers for network partition
       - Use docker.inspect() to get network settings

    All functions use asyncio.to_thread for docker.execute calls (python-on-whales is sync).
    Use try/except with logging for cleanup functions to handle missing rules gracefully.
  </action>
  <verify>
    python -c "from eval.subjects.tikv.chaos import inject_latency_chaos, inject_disk_pressure, inject_network_partition; print('imports ok')"
  </verify>
  <done>
    All chaos injection and cleanup functions implemented with proper error handling
  </done>
</task>

<task type="auto">
  <name>Task 3: Update TiKVEvalSubject to dispatch new chaos types</name>
  <files>
    eval/src/eval/subjects/tikv/subject.py
  </files>
  <action>
    1. Import new chaos functions at top of file:
       from eval.subjects.tikv.chaos import (
           kill_random_tikv,
           inject_latency_chaos,
           cleanup_latency_chaos,
           inject_disk_pressure,
           cleanup_disk_pressure,
           inject_network_partition,
           cleanup_network_partition,
           get_tikv_peer_ips,
       )

    2. Update get_chaos_types() to return:
       ["node_kill", "latency", "disk_pressure", "network_partition"]

    3. Update inject_chaos(chaos_type, **params) signature to accept optional params dict.
       For new chaos types, params contains type-specific config.

    4. Update inject_chaos() dispatch logic:
       - node_kill: existing kill_random_tikv(self.docker)
       - latency:
         - Get random running TiKV container
         - Call inject_latency_chaos(docker, container, params.get("min_ms", 50), params.get("max_ms", 150))
         - Store cleanup info for later
       - disk_pressure:
         - Get random running TiKV container
         - Call inject_disk_pressure(docker, container, params.get("fill_percent", 80))
       - network_partition:
         - Get random running TiKV container
         - Get peer IPs via get_tikv_peer_ips(docker, container)
         - Call inject_network_partition(docker, container, peer_ips)

    5. Add cleanup_chaos(chaos_metadata) method:
       - Dispatch to appropriate cleanup function based on chaos_metadata["chaos_type"]
       - Called by harness after trial ends
       - Handle container-not-running gracefully (container may have been killed/restarted)

    Note: For latency and disk_pressure, the cleanup functions need the metadata returned by inject.
    The harness will call cleanup_chaos() with the chaos_metadata dict after capturing final state.
  </action>
  <verify>
    python -c "
from eval.subjects.tikv import TiKVEvalSubject
s = TiKVEvalSubject()
types = s.get_chaos_types()
assert 'latency' in types, 'latency missing'
assert 'disk_pressure' in types, 'disk_pressure missing'
assert 'network_partition' in types, 'network_partition missing'
print(f'Chaos types: {types}')
"
  </verify>
  <done>
    TiKVEvalSubject dispatches all four chaos types and has cleanup_chaos method for reverting
  </done>
</task>

</tasks>

<verification>
Run the verification commands to confirm:
1. `grep -c "cap_add" subjects/tikv/docker-compose.yaml` returns 3 (one per TiKV)
2. `grep "LATENCY\|DISK_PRESSURE\|NETWORK_PARTITION" eval/src/eval/types.py` shows all three enum values
3. `python -c "from eval.subjects.tikv import TiKVEvalSubject; print(TiKVEvalSubject().get_chaos_types())"` returns all four types
</verification>

<success_criteria>
- TiKV docker-compose has NET_ADMIN capability on all three TiKV containers
- ChaosType enum includes NODE_KILL, LATENCY, DISK_PRESSURE, NETWORK_PARTITION
- chaos.py exports inject and cleanup functions for all three new chaos types
- TiKVEvalSubject.get_chaos_types() returns ["node_kill", "latency", "disk_pressure", "network_partition"]
- TiKVEvalSubject.inject_chaos() dispatches to correct chaos function based on type
- TiKVEvalSubject.cleanup_chaos() reverts chaos using metadata
- All code follows existing patterns (asyncio.to_thread for docker calls)
</success_criteria>

<output>
After completion, create `.planning/phases/38-chaos-expansion/38-01-SUMMARY.md`
</output>
