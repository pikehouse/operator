---
phase: 38-chaos-expansion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - subjects/tikv/docker-compose.yaml
  - eval/src/eval/types.py
  - eval/src/eval/subjects/tikv/chaos.py
  - eval/src/eval/subjects/tikv/subject.py
autonomous: true

must_haves:
  truths:
    - "TiKV containers have NET_ADMIN capability for tc/iptables commands"
    - "Latency chaos injects network delay on TiKV container using tc netem"
    - "Disk pressure chaos fills disk space on TiKV container using fallocate"
    - "Network partition chaos isolates TiKV node from cluster using iptables DROP rules"
    - "All chaos types have cleanup functions that revert changes"
    - "TiKVEvalSubject.get_chaos_types() returns all four chaos types"
    - "EvalSubject protocol supports chaos_params kwargs and cleanup_chaos method"
  artifacts:
    - path: "subjects/tikv/docker-compose.yaml"
      provides: "NET_ADMIN capability for tikv0, tikv1, tikv2 containers"
      contains: "cap_add"
    - path: "eval/src/eval/types.py"
      provides: "ChaosType enum with LATENCY, DISK_PRESSURE, NETWORK_PARTITION; EvalSubject with kwargs and cleanup_chaos"
      contains: "LATENCY"
    - path: "eval/src/eval/subjects/tikv/chaos.py"
      provides: "inject_latency_chaos, inject_disk_pressure, inject_network_partition functions"
      exports: ["inject_latency_chaos", "inject_disk_pressure", "inject_network_partition"]
    - path: "eval/src/eval/subjects/tikv/subject.py"
      provides: "TiKVEvalSubject dispatching all chaos types"
      contains: "latency"
  key_links:
    - from: "eval/src/eval/subjects/tikv/subject.py"
      to: "eval/src/eval/subjects/tikv/chaos.py"
      via: "import and dispatch in inject_chaos()"
      pattern: "inject_latency_chaos|inject_disk_pressure|inject_network_partition"
---

<objective>
Implement three new TiKV chaos types: latency injection (tc netem), disk pressure (fallocate), and network partition (iptables).

Purpose: Enable evaluation of Claude's diagnostic capabilities across a variety of failure modes beyond simple node kills.

Output: Extended chaos.py with three new chaos functions, updated TiKVEvalSubject, and docker-compose.yaml with required capabilities.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-chaos-expansion/38-RESEARCH.md

# Existing implementation patterns
@eval/src/eval/subjects/tikv/chaos.py
@eval/src/eval/subjects/tikv/subject.py
@eval/src/eval/types.py
@subjects/tikv/docker-compose.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add NET_ADMIN capability and update types (including EvalSubject protocol)</name>
  <files>
    subjects/tikv/docker-compose.yaml
    eval/src/eval/types.py
  </files>
  <action>
    1. Update subjects/tikv/docker-compose.yaml:
       - Add `cap_add: [NET_ADMIN]` to tikv0, tikv1, tikv2 services
       - This enables tc and iptables commands inside containers
       - Place cap_add after the volumes section for each tikv service

    2. Update eval/src/eval/types.py:
       - Add new values to ChaosType enum: LATENCY = "latency", DISK_PRESSURE = "disk_pressure", NETWORK_PARTITION = "network_partition"
       - Keep NODE_KILL as first entry

    3. Update EvalSubject protocol in eval/src/eval/types.py:
       - Change inject_chaos signature to accept kwargs:
         ```python
         async def inject_chaos(self, chaos_type: str, **params: Any) -> dict[str, Any]:
             """Inject specified chaos type.

             Args:
                 chaos_type: One of get_chaos_types() values
                 **params: Type-specific parameters (e.g., min_ms, max_ms for latency)

             Returns:
                 Chaos metadata as JSON-serializable dict.
                 IMPORTANT: Must contain all fields needed by cleanup_chaos() to revert the chaos.

             Raises:
                 ValueError: If chaos_type not supported
             """
             ...
         ```

       - Add cleanup_chaos method to EvalSubject protocol:
         ```python
         async def cleanup_chaos(self, chaos_metadata: dict[str, Any]) -> None:
             """Clean up/revert chaos injection.

             Called after trial ends to restore subject to normal state.

             Args:
                 chaos_metadata: The dict returned by inject_chaos()

             Note:
                 Should handle gracefully if container was restarted/killed.
             """
             ...
         ```
  </action>
  <verify>
    grep -q "cap_add" subjects/tikv/docker-compose.yaml && echo "cap_add found"
    grep -q "LATENCY" eval/src/eval/types.py && echo "LATENCY enum found"
    grep -q "cleanup_chaos" eval/src/eval/types.py && echo "cleanup_chaos protocol found"
    grep -q "\*\*params" eval/src/eval/types.py && echo "inject_chaos accepts kwargs"
  </verify>
  <done>
    TiKV containers configured with NET_ADMIN capability; ChaosType enum has all four chaos types; EvalSubject protocol has inject_chaos with **params and cleanup_chaos method
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement chaos injection functions</name>
  <files>
    eval/src/eval/subjects/tikv/chaos.py
  </files>
  <action>
    Add three new async functions to chaos.py following the existing kill_random_tikv pattern:

    IMPORTANT: Each inject function MUST return a chaos_metadata dict containing ALL fields needed by the corresponding cleanup function to revert the chaos.

    1. inject_latency_chaos(docker, target_container, min_ms, max_ms) -> dict:
       - Use tc netem: `tc qdisc add dev eth0 root netem delay {avg}ms {variation}ms`
       - avg = (min_ms + max_ms) // 2, variation = (max_ms - min_ms) // 2
       - Return dict with:
         - chaos_type: "latency"
         - target_container: container name (REQUIRED for cleanup)
         - min_ms, max_ms: parameters used
         - interface: "eth0" (REQUIRED for cleanup)

    2. cleanup_latency_chaos(docker, target_container) -> None:
       - Run: `tc qdisc del dev eth0 root`
       - Ignore errors if rule doesn't exist (container may have been restarted)

    3. inject_disk_pressure(docker, target_container, fill_percent, target_path="/data") -> dict:
       - Validate fill_percent 0-100
       - Get available space: `df --output=avail {target_path} | tail -n 1`
       - Calculate fill_bytes = avail_kb * (fill_percent / 100) * 1024
       - Create fill file: `fallocate -l {fill_bytes} {target_path}/chaos-fill-{timestamp}.tmp`
       - Return dict with:
         - chaos_type: "disk_pressure"
         - target_container: container name (REQUIRED for cleanup)
         - fill_percent: parameter used
         - fill_file: full path to fill file (REQUIRED for cleanup)
         - fill_bytes: actual bytes written

    4. cleanup_disk_pressure(docker, target_container, fill_file) -> None:
       - Run: `rm -f {fill_file}`

    5. inject_network_partition(docker, isolated_container, target_ips) -> dict:
       - For each target IP: `iptables -I OUTPUT -d {ip} -j DROP` and `iptables -I INPUT -s {ip} -j DROP`
       - Return dict with:
         - chaos_type: "network_partition"
         - isolated_container: container name (REQUIRED for cleanup)
         - target_ips: list of IPs (REQUIRED for cleanup)

    6. cleanup_network_partition(docker, isolated_container, target_ips) -> None:
       - For each target IP: `iptables -D OUTPUT -d {ip} -j DROP || true` and `iptables -D INPUT -s {ip} -j DROP || true`

    7. get_tikv_peer_ips(docker, exclude_container) -> list[str]:
       - Get IPs of other TiKV containers for network partition
       - Use docker.inspect() to get network settings

    All functions use asyncio.to_thread for docker.execute calls (python-on-whales is sync).
    Use try/except with logging for cleanup functions to handle missing rules gracefully.
  </action>
  <verify>
    python -c "from eval.subjects.tikv.chaos import inject_latency_chaos, inject_disk_pressure, inject_network_partition; print('imports ok')"
  </verify>
  <done>
    All chaos injection and cleanup functions implemented; each inject function returns metadata with all fields required by its cleanup function
  </done>
</task>

<task type="auto">
  <name>Task 3: Update TiKVEvalSubject to dispatch new chaos types</name>
  <files>
    eval/src/eval/subjects/tikv/subject.py
  </files>
  <action>
    1. Import new chaos functions at top of file:
       from eval.subjects.tikv.chaos import (
           kill_random_tikv,
           inject_latency_chaos,
           cleanup_latency_chaos,
           inject_disk_pressure,
           cleanup_disk_pressure,
           inject_network_partition,
           cleanup_network_partition,
           get_tikv_peer_ips,
       )

    2. Update get_chaos_types() to return:
       ["node_kill", "latency", "disk_pressure", "network_partition"]

    3. Update inject_chaos signature to match protocol:
       async def inject_chaos(self, chaos_type: str, **params: Any) -> dict[str, Any]:
       For new chaos types, params contains type-specific config.

    4. Update inject_chaos() dispatch logic:
       - node_kill: existing kill_random_tikv(self.docker) (ignores params)
       - latency:
         - Get random running TiKV container
         - Call inject_latency_chaos(docker, container, params.get("min_ms", 50), params.get("max_ms", 150))
       - disk_pressure:
         - Get random running TiKV container
         - Call inject_disk_pressure(docker, container, params.get("fill_percent", 80))
       - network_partition:
         - Get random running TiKV container
         - Get peer IPs via get_tikv_peer_ips(docker, container)
         - Call inject_network_partition(docker, container, peer_ips)

    5. Add cleanup_chaos(chaos_metadata) method matching protocol:
       async def cleanup_chaos(self, chaos_metadata: dict[str, Any]) -> None:
       - Extract chaos_type from chaos_metadata
       - Dispatch to appropriate cleanup function based on chaos_type:
         - "latency": cleanup_latency_chaos(docker, chaos_metadata["target_container"])
         - "disk_pressure": cleanup_disk_pressure(docker, chaos_metadata["target_container"], chaos_metadata["fill_file"])
         - "network_partition": cleanup_network_partition(docker, chaos_metadata["isolated_container"], chaos_metadata["target_ips"])
         - "node_kill": no cleanup needed (container restarts naturally or via reset)
       - Handle container-not-running gracefully (wrap in try/except, log but don't raise)

    Note: The harness will call cleanup_chaos() with the chaos_metadata dict after capturing final state.
  </action>
  <verify>
    python -c "
from eval.subjects.tikv import TiKVEvalSubject
s = TiKVEvalSubject()
types = s.get_chaos_types()
assert 'latency' in types, 'latency missing'
assert 'disk_pressure' in types, 'disk_pressure missing'
assert 'network_partition' in types, 'network_partition missing'
assert hasattr(s, 'cleanup_chaos'), 'cleanup_chaos method missing'
print(f'Chaos types: {types}')
"
  </verify>
  <done>
    TiKVEvalSubject dispatches all four chaos types with **params support and has cleanup_chaos method for reverting
  </done>
</task>

</tasks>

<verification>
Run the verification commands to confirm:
1. `grep -c "cap_add" subjects/tikv/docker-compose.yaml` returns 3 (one per TiKV)
2. `grep "LATENCY\|DISK_PRESSURE\|NETWORK_PARTITION" eval/src/eval/types.py` shows all three enum values
3. `grep "cleanup_chaos" eval/src/eval/types.py` shows protocol method
4. `python -c "from eval.subjects.tikv import TiKVEvalSubject; print(TiKVEvalSubject().get_chaos_types())"` returns all four types
</verification>

<success_criteria>
- TiKV docker-compose has NET_ADMIN capability on all three TiKV containers
- ChaosType enum includes NODE_KILL, LATENCY, DISK_PRESSURE, NETWORK_PARTITION
- EvalSubject protocol has inject_chaos with **params: Any and cleanup_chaos method
- chaos.py exports inject and cleanup functions for all three new chaos types
- Each inject function returns metadata containing all fields needed by its cleanup function
- TiKVEvalSubject.get_chaos_types() returns ["node_kill", "latency", "disk_pressure", "network_partition"]
- TiKVEvalSubject.inject_chaos() accepts **params and dispatches to correct chaos function
- TiKVEvalSubject.cleanup_chaos() reverts chaos using metadata
- All code follows existing patterns (asyncio.to_thread for docker calls)
</success_criteria>

<output>
After completion, create `.planning/phases/38-chaos-expansion/38-01-SUMMARY.md`
</output>
