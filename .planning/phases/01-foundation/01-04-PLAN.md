---
phase: 01-foundation
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - packages/operator-core/src/operator_core/cli/__init__.py
  - packages/operator-core/src/operator_core/cli/main.py
  - packages/operator-core/src/operator_core/cli/deploy.py
  - packages/operator-core/pyproject.toml
  - subjects/tikv/docker-compose.yaml
autonomous: true

must_haves:
  truths:
    - "operator deploy local up starts containers"
    - "operator deploy local down stops containers"
    - "operator deploy local status shows container state"
    - "operator deploy local logs shows container output"
    - "operator --help shows available commands"
  artifacts:
    - path: "packages/operator-core/src/operator_core/cli/main.py"
      provides: "CLI entry point"
      contains: "typer.Typer"
    - path: "packages/operator-core/src/operator_core/cli/deploy.py"
      provides: "Deploy subcommands"
      contains: "def up"
    - path: "subjects/tikv/docker-compose.yaml"
      provides: "TiKV cluster definition stub"
      contains: "services:"
  key_links:
    - from: "packages/operator-core/src/operator_core/cli/deploy.py"
      to: "packages/operator-core/src/operator_core/deploy.py"
      via: "LocalDeployment import"
      pattern: "from operator_core.deploy import"
    - from: "packages/operator-core/pyproject.toml"
      to: "packages/operator-core/src/operator_core/cli/main.py"
      via: "console_scripts entry point"
      pattern: "operator.*=.*cli.main"
---

<objective>
Create the Typer CLI with deploy subcommands and a stub docker-compose.yaml for testing.

Purpose: Complete the deployment infrastructure (DEPLOY-02) by wiring the CLI to LocalDeployment. After this plan, `operator deploy local up` is a working command.

Output: Working CLI with deploy local {up,down,status,logs,restart} commands, plus a minimal TiKV docker-compose.yaml that validates the deployment flow works end-to-end.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CLI module with deploy commands</name>
  <files>
packages/operator-core/src/operator_core/cli/__init__.py
packages/operator-core/src/operator_core/cli/main.py
packages/operator-core/src/operator_core/cli/deploy.py
  </files>
  <action>
Create the CLI structure following CONTEXT.md decisions and RESEARCH.md Typer patterns:

1. Create `cli/__init__.py` (empty, just makes it a package)

2. Create `cli/main.py` - the entry point:

```python
"""Operator CLI - AI-powered operator for distributed systems."""

import typer

from operator_core.cli.deploy import deploy_app

app = typer.Typer(
    name="operator",
    help="AI-powered operator for distributed systems",
    no_args_is_help=True,
)

# Add deploy command group
app.add_typer(deploy_app, name="deploy")

def main() -> None:
    """Entry point for the CLI."""
    app()

if __name__ == "__main__":
    main()
```

3. Create `cli/deploy.py` - deploy subcommands:

```python
"""Deploy commands for managing cluster deployments."""

from pathlib import Path
from typing import Optional

import typer
from rich.console import Console
from rich.table import Table

from operator_core.deploy import LocalDeployment, create_local_deployment

deploy_app = typer.Typer(help="Deployment commands")
local_app = typer.Typer(help="Local Docker Compose deployment")
deploy_app.add_typer(local_app, name="local")

console = Console()


def _get_deployment(subject: str) -> LocalDeployment:
    """Get a LocalDeployment for the given subject."""
    try:
        return create_local_deployment(subject)
    except FileNotFoundError as e:
        console.print(f"[red]Error:[/red] {e}")
        raise typer.Exit(1)


@local_app.command()
def up(
    subject: str = typer.Argument("tikv", help="Subject to deploy (e.g., tikv)"),
    wait: bool = typer.Option(True, "--wait/--no-wait", help="Wait for health checks"),
) -> None:
    """Start local cluster for a subject."""
    console.print(f"[bold]Starting {subject} cluster...[/bold]")
    deployment = _get_deployment(subject)
    deployment.up(wait=wait)


@local_app.command()
def down(
    subject: str = typer.Argument("tikv", help="Subject to stop"),
    volumes: bool = typer.Option(False, "--volumes", "-v", help="Remove volumes too"),
) -> None:
    """Stop local cluster."""
    console.print(f"[bold]Stopping {subject} cluster...[/bold]")
    deployment = _get_deployment(subject)
    deployment.down(remove_volumes=volumes)


@local_app.command()
def status(
    subject: str = typer.Argument("tikv", help="Subject to check"),
) -> None:
    """Show cluster status."""
    deployment = _get_deployment(subject)
    result = deployment.status()

    table = Table(title=f"{subject} Cluster Status")
    table.add_column("Service", style="cyan")
    table.add_column("Running", style="green")
    table.add_column("Health", style="yellow")
    table.add_column("Ports", style="blue")

    for svc in result.services:
        running = "[green]Yes[/green]" if svc.running else "[red]No[/red]"
        health = svc.health
        ports = ", ".join(svc.ports) if svc.ports else "-"
        table.add_row(svc.name, running, health, ports)

    console.print(table)

    if result.all_healthy:
        console.print("\n[green]All services running[/green]")
    else:
        console.print("\n[yellow]Some services not running[/yellow]")


@local_app.command()
def logs(
    subject: str = typer.Argument("tikv", help="Subject to get logs from"),
    service: Optional[str] = typer.Option(None, "--service", "-s", help="Specific service"),
    follow: bool = typer.Option(False, "--follow", "-f", help="Follow log output"),
    tail: int = typer.Option(100, "--tail", "-n", help="Number of lines to show"),
) -> None:
    """View container logs."""
    deployment = _get_deployment(subject)
    deployment.logs(service=service, follow=follow, tail=tail)


@local_app.command()
def restart(
    subject: str = typer.Argument("tikv", help="Subject containing the service"),
    service: str = typer.Argument(..., help="Service to restart"),
) -> None:
    """Restart a specific service."""
    deployment = _get_deployment(subject)
    deployment.restart(service)
```

Key decisions:
- Subject defaults to "tikv" per CONTEXT.md
- Uses Rich for formatted output (tables, colors)
- Error handling with typer.Exit(1) for clean failures
- All commands from CONTEXT.md implemented: up, down, status, logs, restart
  </action>
  <verify>
```bash
uv run python -c "from operator_core.cli.main import app; print('CLI imports OK')"
```
  </verify>
  <done>
- CLI module structure created
- All deploy local commands implemented
- Commands wired to LocalDeployment
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CLI entry point to pyproject.toml</name>
  <files>packages/operator-core/pyproject.toml</files>
  <action>
Update packages/operator-core/pyproject.toml to add the CLI entry point:

Add this section to make `operator` command available:

```toml
[project.scripts]
operator = "operator_core.cli.main:main"
```

This goes after the dependencies section.

After this change, `uv run operator --help` should work.
  </action>
  <verify>
```bash
uv sync && uv run operator --help
```
Should show the help text with "deploy" command listed.
  </verify>
  <done>
- operator command is installed and runnable
- `operator --help` shows available commands
- `operator deploy --help` shows deploy subcommands
  </done>
</task>

<task type="auto">
  <name>Task 3: Create stub TiKV docker-compose.yaml</name>
  <files>subjects/tikv/docker-compose.yaml</files>
  <action>
Create a minimal docker-compose.yaml to validate the deployment flow works.

For Phase 1, use a simple nginx container as a placeholder. The full TiKV cluster will be created in Phase 3 (Local Cluster). This stub proves the CLI->LocalDeployment flow works.

```yaml
# Stub docker-compose for Phase 1 testing
# Real TiKV cluster definition comes in Phase 3

services:
  # Placeholder service to test deployment flow
  placeholder:
    image: nginx:alpine
    ports:
      - "8080:80"
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost/"]
      interval: 5s
      timeout: 3s
      retries: 3
      start_period: 5s
```

This allows testing `operator deploy local up/down/status` without needing the full TiKV stack.

Create the directory structure: `subjects/tikv/`
  </action>
  <verify>
```bash
# Verify file exists
cat subjects/tikv/docker-compose.yaml

# Test the full flow (requires Docker running)
uv run operator deploy local up tikv
uv run operator deploy local status tikv
uv run operator deploy local down tikv
```
  </verify>
  <done>
- subjects/tikv/docker-compose.yaml exists
- Placeholder service has healthcheck
- Full deploy up/down/status cycle works
  </done>
</task>

</tasks>

<verification>
1. CLI is installed and shows help:
   ```bash
   uv run operator --help
   uv run operator deploy --help
   uv run operator deploy local --help
   ```

2. Full deployment cycle works (requires Docker):
   ```bash
   uv run operator deploy local up tikv
   uv run operator deploy local status tikv
   uv run operator deploy local logs tikv --tail 10
   uv run operator deploy local down tikv
   ```

3. Project structure matches expected:
   ```
   operator/
   ├── packages/
   │   └── operator-core/
   │       └── src/
   │           └── operator_core/
   │               ├── cli/
   │               │   ├── __init__.py
   │               │   ├── main.py
   │               │   └── deploy.py
   │               └── ...
   └── subjects/
       └── tikv/
           └── docker-compose.yaml
   ```
</verification>

<success_criteria>
- DEPLOY-02 requirement fully satisfied: `operator deploy local up` works
- CLI matches CONTEXT.md decisions (subcommand pattern, default subject)
- End-to-end deployment flow validated with stub compose file
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
