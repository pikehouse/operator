---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - packages/operator-core/src/operator_core/subject.py
  - packages/operator-core/src/operator_core/types.py
  - packages/operator-core/src/operator_core/config.py
autonomous: true

must_haves:
  truths:
    - "Subject Protocol can be type-checked without runtime errors"
    - "Data types are usable as type hints"
    - "Subject config can declare actions, observations, and SLOs"
  artifacts:
    - path: "packages/operator-core/src/operator_core/subject.py"
      provides: "Subject Protocol definition"
      contains: "class Subject"
    - path: "packages/operator-core/src/operator_core/types.py"
      provides: "Shared data types"
      contains: "class Store"
    - path: "packages/operator-core/src/operator_core/config.py"
      provides: "Subject configuration types"
      contains: "class Action"
  key_links:
    - from: "packages/operator-core/src/operator_core/subject.py"
      to: "packages/operator-core/src/operator_core/types.py"
      via: "type imports"
      pattern: "from.*types import"
---

<objective>
Define the Subject adapter interface (CORE-01) using Python Protocols.

Purpose: This interface enables clean separation between the operator core and subject implementations (TiKV, future Kafka, etc.). A new subject can be added by implementing this interface without modifying core code.

Output: Protocol-based Subject interface with data types for Store, Region, ClusterMetrics, and a declarative config system for registering actions/observations/SLOs.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create data types module</name>
  <files>packages/operator-core/src/operator_core/types.py</files>
  <action>
Create the shared data types used across the operator:

1. Use @dataclass for all types (not Pydantic - these are internal types, not API models)

2. Define these types based on CONTEXT.md API surface:

```python
@dataclass
class Store:
    id: str
    address: str
    state: str  # "Up", "Down", "Tombstone", etc.

@dataclass
class Region:
    id: int
    leader_store_id: str
    peer_store_ids: list[str]

@dataclass
class StoreMetrics:
    store_id: str
    qps: float
    latency_p99_ms: float
    disk_used_bytes: int
    disk_total_bytes: int
    cpu_percent: float
    raft_lag: int

@dataclass
class ClusterMetrics:
    store_count: int
    region_count: int
    leader_count: dict[str, int]  # store_id -> leader count
```

3. Add type alias for common patterns:
   - `StoreId = str`
   - `RegionId = int`

4. Include docstrings explaining each type's purpose in TiKV terms.

Do NOT use Pydantic here - save that for config file parsing and API responses.
  </action>
  <verify>
Run `uv run python -c "from operator_core.types import Store, Region, StoreMetrics, ClusterMetrics; s = Store('1', 'localhost:20160', 'Up'); print(s)"` - should print the Store instance
  </verify>
  <done>
- All data types defined and importable
- Types work as expected with dataclass functionality
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Subject Protocol</name>
  <files>packages/operator-core/src/operator_core/subject.py</files>
  <action>
Create the Subject Protocol interface:

1. Use `typing.Protocol` with `@runtime_checkable` decorator

2. Define observation methods (async) based on CONTEXT.md:
   - `async def get_stores(self) -> list[Store]`
   - `async def get_hot_write_regions(self) -> list[Region]`
   - `async def get_store_metrics(self, store_id: str) -> StoreMetrics`
   - `async def get_cluster_metrics(self) -> ClusterMetrics`

3. Define action methods (async) based on CONTEXT.md:
   - `async def transfer_leader(self, region_id: int, to_store_id: str) -> None`
   - `async def split_region(self, region_id: int) -> None`
   - `async def set_leader_schedule_limit(self, n: int) -> None`
   - `async def set_replica_schedule_limit(self, n: int) -> None`
   - `async def drain_store(self, store_id: str) -> None`

4. Define config methods:
   - `async def set_low_space_threshold(self, percent: float) -> None`
   - `async def set_region_schedule_limit(self, n: int) -> None`

5. Import types from types.py

6. Add comprehensive docstrings explaining the Protocol pattern and how subjects should implement it.

Use async methods throughout - the research notes this is the modern approach with httpx.
  </action>
  <verify>
Run `uv run python -c "from operator_core.subject import Subject; print(Subject)"` - should print the Protocol class
Type check passes: `uv run python -m py_compile packages/operator-core/src/operator_core/subject.py`
  </verify>
  <done>
- Subject Protocol defined with all observations and actions
- Protocol is runtime_checkable
- All methods are async
  </done>
</task>

<task type="auto">
  <name>Task 3: Create subject config module</name>
  <files>packages/operator-core/src/operator_core/config.py</files>
  <action>
Create the declarative subject configuration system from CONTEXT.md:

1. Define dataclasses for config elements:

```python
@dataclass
class Action:
    name: str
    args: list[str]
    description: str = ""

@dataclass
class Observation:
    name: str
    returns: str  # Type hint as string for documentation
    description: str = ""

@dataclass
class SLO:
    name: str
    target: float  # The threshold value
    unit: str = ""  # "ms", "percent", "count", etc.
    grace_period_s: int = 0  # Time before violation triggers alert
    description: str = ""

@dataclass
class SubjectConfig:
    name: str
    actions: list[Action]
    observations: list[Observation]
    slos: list[SLO]
```

2. Add a factory function for easy config creation:
```python
def create_subject_config(
    name: str,
    actions: list[Action],
    observations: list[Observation],
    slos: list[SLO],
) -> SubjectConfig:
    return SubjectConfig(name=name, actions=actions, observations=observations, slos=slos)
```

3. Include docstrings showing example usage matching CONTEXT.md pattern.

This enables subjects to declare their capabilities without modifying core code.
  </action>
  <verify>
Run:
```bash
uv run python -c "
from operator_core.config import Action, Observation, SLO, SubjectConfig
a = Action('transfer_leader', ['region_id', 'to_store_id'])
o = Observation('get_stores', 'list[Store]')
s = SLO('write_latency_p99', target=100, unit='ms', grace_period_s=60)
config = SubjectConfig('tikv', [a], [o], [s])
print(config)
"
```
Should print the config without errors.
  </verify>
  <done>
- Action, Observation, SLO, SubjectConfig types defined
- Example from CONTEXT.md is expressible
- All types importable
  </done>
</task>

</tasks>

<verification>
1. All modules import without errors:
   ```bash
   uv run python -c "from operator_core import types, subject, config"
   ```
2. Subject Protocol can be used as a type hint
3. Config types match CONTEXT.md example structure
4. Type checking passes on all new files
</verification>

<success_criteria>
- CORE-01 requirement satisfied: Subject adapter interface exists
- A new subject can implement the Protocol without inheriting from it
- Subject config enables declarative capability registration
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
