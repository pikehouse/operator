---
phase: 26-script-execution
plan: 02
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - packages/operator-core/src/operator_core/scripts/executor.py
  - packages/operator-core/src/operator_core/scripts/__init__.py
  - packages/operator-core/tests/test_script_executor.py
autonomous: true

must_haves:
  truths:
    - "Python scripts execute in python:3.11-slim container"
    - "Bash scripts execute in bash:5.2-alpine container"
    - "Scripts cannot access network (--network none)"
    - "Scripts limited to 512MB RAM, 1 CPU, 100 PIDs"
    - "Scripts run as non-root user (nobody)"
    - "Script stdout/stderr and exit code captured and returned"
    - "Scripts timeout after 60s with forced cleanup"
    - "Bash syntax validated with bash -n before execution"
  artifacts:
    - path: "packages/operator-core/src/operator_core/scripts/executor.py"
      provides: "ScriptExecutor class with sandbox execution"
      exports: ["ScriptExecutor"]
  key_links:
    - from: "scripts/executor.py"
      to: "scripts/validation.py"
      via: "ScriptValidator import"
      pattern: "from.*validation import ScriptValidator"
    - from: "scripts/executor.py"
      to: "python_on_whales.docker"
      via: "docker.run() call"
      pattern: "docker\\.run"
---

<objective>
Create ScriptExecutor that runs validated scripts in sandboxed Docker containers.

Purpose: Execute agent-generated scripts safely in isolated containers with strict resource limits and network isolation, capturing output for agent iteration.

Output: ScriptExecutor class with execute() method that validates, runs in sandbox, and returns stdout/stderr/exit_code.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-script-execution/26-RESEARCH.md
@.planning/phases/26-script-execution/26-01-SUMMARY.md

# Pattern reference - asyncio.run_in_executor
@packages/operator-core/src/operator_core/docker/actions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ScriptExecutor with sandbox execution</name>
  <files>
    packages/operator-core/src/operator_core/scripts/executor.py
    packages/operator-core/src/operator_core/scripts/__init__.py
  </files>
  <action>
Create `executor.py` with ScriptExecutor class:

```python
"""Script executor with sandboxed Docker execution.

Executes validated Python and Bash scripts in isolated containers
with strict resource limits and network isolation.
"""

import asyncio
from dataclasses import dataclass
from typing import Any

from python_on_whales import docker
from python_on_whales.exceptions import DockerException

from operator_core.scripts.validation import ScriptValidator, ValidationResult


@dataclass
class ExecutionResult:
    """Result of script execution."""
    success: bool
    stdout: str
    stderr: str
    exit_code: int | None
    timeout: bool = False
    validation_failed: bool = False
    error: str | None = None


class ScriptExecutor:
    """Executor for sandboxed script execution.

    Scripts are validated before execution and run in isolated Docker
    containers with strict security constraints per SCRP-02 through SCRP-07.
    """

    # Container images per script type (SCRP-02)
    IMAGES = {
        "python": "python:3.11-slim",
        "bash": "bash:5.2-alpine",
    }

    # Resource limits (SCRP-04)
    MEMORY_LIMIT = "512m"
    CPU_LIMIT = 1.0
    PID_LIMIT = 100

    # Timeout (SCRP-07)
    DEFAULT_TIMEOUT = 60
    MAX_TIMEOUT = 300

    def __init__(self):
        self._validator = ScriptValidator()
        self._docker = docker

    async def execute(
        self,
        script_content: str,
        script_type: str,
        timeout: int | None = None,
    ) -> ExecutionResult:
        """Execute script in sandboxed container.

        Args:
            script_content: Script content to execute (SCRP-01)
            script_type: "python" or "bash"
            timeout: Execution timeout in seconds (default: 60, max: 300)

        Returns:
            ExecutionResult with stdout, stderr, exit_code

        Note:
            Validation failures return immediately without execution (VALD-06).
            Timeout triggers forced container cleanup (SCRP-07).
        """
        # Validate script_type
        if script_type not in self.IMAGES:
            return ExecutionResult(
                success=False,
                stdout="",
                stderr=f"Invalid script_type: {script_type}. Must be 'python' or 'bash'",
                exit_code=None,
                validation_failed=True,
                error=f"Invalid script_type: {script_type}",
            )

        # Clamp timeout
        effective_timeout = timeout if timeout is not None else self.DEFAULT_TIMEOUT
        effective_timeout = min(effective_timeout, self.MAX_TIMEOUT)

        # Phase 1: Validate script
        validation_result = self._validator.validate(script_content, script_type)
        if not validation_result.valid:
            return ExecutionResult(
                success=False,
                stdout="",
                stderr=validation_result.error or "Validation failed",
                exit_code=None,
                validation_failed=True,
                error=validation_result.error,
            )

        # Phase 1b: Bash syntax validation (requires subprocess)
        if script_type == "bash":
            bash_result = await self._validate_bash_syntax(script_content)
            if not bash_result.valid:
                return ExecutionResult(
                    success=False,
                    stdout="",
                    stderr=bash_result.error or "Bash syntax error",
                    exit_code=None,
                    validation_failed=True,
                    error=bash_result.error,
                )

        # Phase 2: Execute in sandbox
        try:
            return await asyncio.wait_for(
                self._execute_in_sandbox(script_content, script_type, effective_timeout),
                timeout=effective_timeout + 5,  # Buffer for container cleanup
            )
        except asyncio.TimeoutError:
            return ExecutionResult(
                success=False,
                stdout="",
                stderr=f"Script execution timed out after {effective_timeout}s",
                exit_code=-1,
                timeout=True,
            )

    async def _validate_bash_syntax(self, content: str) -> ValidationResult:
        """Validate Bash script syntax using bash -n (VALD-02)."""
        proc = await asyncio.create_subprocess_exec(
            "bash", "-n",
            stdin=asyncio.subprocess.PIPE,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        _, stderr = await proc.communicate(content.encode("utf-8"))

        if proc.returncode == 0:
            return ValidationResult(valid=True)
        else:
            return ValidationResult(
                valid=False,
                error=f"Bash syntax error: {stderr.decode('utf-8').strip()}",
                layer="syntax",
            )

    async def _execute_in_sandbox(
        self,
        script_content: str,
        script_type: str,
        timeout: int,
    ) -> ExecutionResult:
        """Execute script in isolated Docker container."""
        loop = asyncio.get_running_loop()

        def _blocking_execute():
            image = self.IMAGES[script_type]

            if script_type == "python":
                command = ["python", "-c", script_content]
            else:
                command = ["bash", "-c", script_content]

            try:
                # Run with all security constraints
                output = self._docker.run(
                    image,
                    command,
                    # Network isolation (SCRP-03)
                    networks=["none"],
                    # Resource limits (SCRP-04)
                    memory=self.MEMORY_LIMIT,
                    cpus=self.CPU_LIMIT,
                    pids_limit=self.PID_LIMIT,
                    # Non-root user (SCRP-05)
                    user="nobody",
                    # Read-only filesystem
                    read_only=True,
                    # Ephemeral container (SCRP-06)
                    remove=True,
                    # Capture output
                    detach=False,
                )

                return ExecutionResult(
                    success=True,
                    stdout=output if output else "",
                    stderr="",
                    exit_code=0,
                )

            except DockerException as e:
                # python-on-whales raises exception on non-zero exit
                error_str = str(e)

                # Try to extract exit code from exception
                exit_code = 1
                if "exit code" in error_str.lower():
                    # Parse exit code from error message if present
                    import re
                    match = re.search(r"exit code[:\s]+(\d+)", error_str, re.IGNORECASE)
                    if match:
                        exit_code = int(match.group(1))

                return ExecutionResult(
                    success=False,
                    stdout="",
                    stderr=error_str,
                    exit_code=exit_code,
                )

            except Exception as e:
                return ExecutionResult(
                    success=False,
                    stdout="",
                    stderr=str(e),
                    exit_code=1,
                    error=str(e),
                )

        return await loop.run_in_executor(None, _blocking_execute)
```

Update `__init__.py` to export ScriptExecutor:
```python
from operator_core.scripts.validation import ScriptValidator, ValidationResult
from operator_core.scripts.executor import ScriptExecutor, ExecutionResult
from operator_core.scripts.patterns import (
    SECRET_PATTERNS,
    PYTHON_DANGEROUS_PATTERNS,
    BASH_DANGEROUS_PATTERNS,
)

__all__ = [
    "ScriptValidator",
    "ValidationResult",
    "ScriptExecutor",
    "ExecutionResult",
    "SECRET_PATTERNS",
    "PYTHON_DANGEROUS_PATTERNS",
    "BASH_DANGEROUS_PATTERNS",
]
```
  </action>
  <verify>
    python -c "from operator_core.scripts import ScriptExecutor, ExecutionResult; e = ScriptExecutor(); print('ScriptExecutor imported successfully')"
  </verify>
  <done>
    - ScriptExecutor.execute() validates then executes in Docker sandbox
    - Python uses python:3.11-slim, Bash uses bash:5.2-alpine
    - Network isolation via networks=["none"]
    - Resource limits: 512m memory, 1 CPU, 100 PIDs
    - Non-root execution via user="nobody"
    - Bash syntax validated with bash -n before execution
    - Timeout enforced with asyncio.wait_for()
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for ScriptExecutor</name>
  <files>
    packages/operator-core/tests/test_script_executor.py
  </files>
  <action>
Create tests for ScriptExecutor. Note: Tests mock Docker to avoid requiring actual Docker daemon during unit tests.

```python
"""Tests for script executor module."""
import pytest
from unittest.mock import patch, MagicMock, AsyncMock
import asyncio

from operator_core.scripts import ScriptExecutor, ExecutionResult
from operator_core.scripts.validation import ValidationResult


class TestScriptExecutor:
    def setup_method(self):
        self.executor = ScriptExecutor()

    # Script type validation
    @pytest.mark.asyncio
    async def test_rejects_invalid_script_type(self):
        result = await self.executor.execute("print('hello')", "javascript")
        assert result.success is False
        assert result.validation_failed is True
        assert "Invalid script_type" in result.error

    # Validation integration tests
    @pytest.mark.asyncio
    async def test_rejects_oversized_script(self):
        large_script = "x = 1\n" * 5000
        result = await self.executor.execute(large_script, "python")
        assert result.success is False
        assert result.validation_failed is True
        assert "10000" in result.stderr

    @pytest.mark.asyncio
    async def test_rejects_script_with_secrets(self):
        result = await self.executor.execute("api_key = 'secret123'", "python")
        assert result.success is False
        assert result.validation_failed is True
        assert "secret" in result.stderr.lower()

    @pytest.mark.asyncio
    async def test_rejects_script_with_dangerous_patterns(self):
        result = await self.executor.execute("eval('malicious')", "python")
        assert result.success is False
        assert result.validation_failed is True
        assert "dangerous" in result.stderr.lower()

    @pytest.mark.asyncio
    async def test_rejects_invalid_python_syntax(self):
        result = await self.executor.execute("def foo(", "python")
        assert result.success is False
        assert result.validation_failed is True
        assert "syntax" in result.stderr.lower()

    # Bash syntax validation
    @pytest.mark.asyncio
    async def test_rejects_invalid_bash_syntax(self):
        result = await self.executor.execute("if [ true", "bash")
        assert result.success is False
        assert result.validation_failed is True
        assert "syntax" in result.stderr.lower()

    # Docker execution tests (mocked)
    @pytest.mark.asyncio
    async def test_executes_valid_python_script(self):
        with patch.object(self.executor, '_docker') as mock_docker:
            mock_docker.run.return_value = "Hello, World!"

            result = await self.executor.execute("print('Hello, World!')", "python")

            assert result.success is True
            assert result.stdout == "Hello, World!"
            assert result.exit_code == 0

            # Verify Docker called with correct security constraints
            mock_docker.run.assert_called_once()
            call_kwargs = mock_docker.run.call_args[1]
            assert call_kwargs["networks"] == ["none"]
            assert call_kwargs["memory"] == "512m"
            assert call_kwargs["cpus"] == 1.0
            assert call_kwargs["pids_limit"] == 100
            assert call_kwargs["user"] == "nobody"
            assert call_kwargs["read_only"] is True
            assert call_kwargs["remove"] is True

    @pytest.mark.asyncio
    async def test_executes_valid_bash_script(self):
        # Mock bash -n validation subprocess
        with patch('asyncio.create_subprocess_exec', new_callable=AsyncMock) as mock_subprocess:
            mock_proc = MagicMock()
            mock_proc.communicate = AsyncMock(return_value=(b"", b""))
            mock_proc.returncode = 0
            mock_subprocess.return_value = mock_proc

            with patch.object(self.executor, '_docker') as mock_docker:
                mock_docker.run.return_value = "bash output"

                result = await self.executor.execute("echo 'hello'", "bash")

                assert result.success is True
                assert result.stdout == "bash output"

                # Verify correct image used
                call_args = mock_docker.run.call_args[0]
                assert call_args[0] == "bash:5.2-alpine"

    @pytest.mark.asyncio
    async def test_captures_docker_error(self):
        from python_on_whales.exceptions import DockerException

        with patch.object(self.executor, '_docker') as mock_docker:
            mock_docker.run.side_effect = DockerException(
                command_launched=["docker", "run"],
                return_code=1,
                stdout="",
                stderr="script failed",
            )

            result = await self.executor.execute("exit 1", "python")

            assert result.success is False
            assert result.exit_code is not None

    # Timeout tests
    @pytest.mark.asyncio
    async def test_timeout_clamped_to_max(self):
        """Verify timeout is clamped to MAX_TIMEOUT (300s)."""
        with patch.object(self.executor, '_docker') as mock_docker:
            mock_docker.run.return_value = ""

            # Request 1000s timeout, should be clamped
            await self.executor.execute("print(1)", "python", timeout=1000)

            # Execution should succeed (timeout not exceeded)
            # Just verifying the call completed without asyncio.TimeoutError
            mock_docker.run.assert_called_once()

    # Image selection tests
    @pytest.mark.asyncio
    async def test_uses_correct_python_image(self):
        with patch.object(self.executor, '_docker') as mock_docker:
            mock_docker.run.return_value = ""

            await self.executor.execute("print(1)", "python")

            call_args = mock_docker.run.call_args[0]
            assert call_args[0] == "python:3.11-slim"

    @pytest.mark.asyncio
    async def test_uses_correct_bash_image(self):
        with patch('asyncio.create_subprocess_exec', new_callable=AsyncMock) as mock_subprocess:
            mock_proc = MagicMock()
            mock_proc.communicate = AsyncMock(return_value=(b"", b""))
            mock_proc.returncode = 0
            mock_subprocess.return_value = mock_proc

            with patch.object(self.executor, '_docker') as mock_docker:
                mock_docker.run.return_value = ""

                await self.executor.execute("echo 1", "bash")

                call_args = mock_docker.run.call_args[0]
                assert call_args[0] == "bash:5.2-alpine"
```

Run with: `pytest packages/operator-core/tests/test_script_executor.py -v`
  </action>
  <verify>
    cd /Users/jrtipton/x/operator && pytest packages/operator-core/tests/test_script_executor.py -v
  </verify>
  <done>
    - Tests verify validation failures block execution
    - Tests verify Docker security constraints (network, memory, cpu, pids, user)
    - Tests verify correct container images used
    - Tests verify timeout handling
    - All tests pass with mocked Docker
  </done>
</task>

</tasks>

<verification>
1. Import executor: `python -c "from operator_core.scripts import ScriptExecutor"`
2. Run tests: `pytest packages/operator-core/tests/test_script_executor.py -v`
3. Integration test (requires Docker):
   ```python
   import asyncio
   from operator_core.scripts import ScriptExecutor

   async def main():
       executor = ScriptExecutor()
       # Valid Python
       result = await executor.execute("print('Hello')", "python")
       print(f"Python: {result}")
       # Valid Bash
       result = await executor.execute("echo 'Hello'", "bash")
       print(f"Bash: {result}")

   asyncio.run(main())
   ```
</verification>

<success_criteria>
- ScriptExecutor validates before execution (VALD-06)
- Python scripts run in python:3.11-slim (SCRP-02)
- Bash scripts run in bash:5.2-alpine (SCRP-02)
- Network isolated with networks=["none"] (SCRP-03)
- Resource limits: 512m, 1 CPU, 100 PIDs (SCRP-04)
- Non-root user with read-only filesystem (SCRP-05)
- Container ephemeral with remove=True (SCRP-06)
- Timeout enforced with asyncio.wait_for (SCRP-07)
- Output captured in ExecutionResult (SCRP-08, SCRP-09)
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/26-script-execution/26-02-SUMMARY.md`
</output>
