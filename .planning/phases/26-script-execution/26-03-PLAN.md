---
phase: 26-script-execution
plan: 03
type: execute
wave: 3
depends_on: ["26-02"]
files_modified:
  - packages/operator-core/src/operator_core/scripts/tools.py
  - packages/operator-core/src/operator_core/scripts/__init__.py
  - packages/operator-core/src/operator_core/actions/tools.py
  - packages/operator-core/tests/test_script_tools.py
autonomous: true

must_haves:
  truths:
    - "execute_script tool available via get_general_tools()"
    - "Agent can discover execute_script with parameters documented"
    - "execute_tool('execute_script', ...) executes script via ScriptExecutor"
    - "execute_script requires approval (risk_level: high)"
  artifacts:
    - path: "packages/operator-core/src/operator_core/scripts/tools.py"
      provides: "get_script_tools() function returning ActionDefinition"
      exports: ["get_script_tools"]
    - path: "packages/operator-core/src/operator_core/actions/tools.py"
      provides: "Updated TOOL_EXECUTORS with execute_script"
      contains: "execute_script"
  key_links:
    - from: "actions/tools.py"
      to: "scripts/tools.py"
      via: "import get_script_tools"
      pattern: "from.*scripts.*import.*get_script_tools"
    - from: "actions/tools.py"
      to: "scripts/executor.py"
      via: "ScriptExecutor in TOOL_EXECUTORS"
      pattern: "_get_script_executor"
---

<objective>
Register execute_script as an agent-discoverable tool integrated into the action framework.

Purpose: Agent needs to be able to call execute_script through the standard tool discovery and execution flow, with proper risk classification and approval requirements.

Output: execute_script tool registered via get_general_tools(), executable via execute_tool(), with HIGH risk level requiring approval.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-script-execution/26-RESEARCH.md
@.planning/phases/26-script-execution/26-01-SUMMARY.md
@.planning/phases/26-script-execution/26-02-SUMMARY.md

# Pattern reference - tool registration
@packages/operator-core/src/operator_core/docker/actions.py
@packages/operator-core/src/operator_core/actions/tools.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create execute_script tool definition</name>
  <files>
    packages/operator-core/src/operator_core/scripts/tools.py
    packages/operator-core/src/operator_core/scripts/__init__.py
  </files>
  <action>
Create `scripts/tools.py` following the pattern from `docker/actions.py`:

```python
"""Script execution tool definitions.

Provides execute_script tool for agent-callable script execution.
Scripts are validated and executed in sandboxed Docker containers.
"""

from operator_core.actions.registry import ActionDefinition, ParamDef
from operator_core.actions.types import ActionType


def get_script_tools() -> list[ActionDefinition]:
    """Get script execution tool definitions.

    Returns list of ActionDefinition for script execution.
    """
    return [
        ActionDefinition(
            name="execute_script",
            description=(
                "Execute a Python or Bash script in a sandboxed Docker container. "
                "Scripts are validated for syntax, secrets (API keys, passwords), "
                "and dangerous patterns (eval, exec) before execution. "
                "Returns stdout, stderr, and exit code for analysis."
            ),
            parameters={
                "script_content": ParamDef(
                    type="str",
                    description=(
                        "The script content to execute. "
                        "Max 10000 characters. "
                        "Must not contain hardcoded secrets or dangerous functions."
                    ),
                    required=True,
                ),
                "script_type": ParamDef(
                    type="str",
                    description="Script language: 'python' or 'bash'",
                    required=True,
                ),
                "timeout": ParamDef(
                    type="int",
                    description=(
                        "Execution timeout in seconds. "
                        "Default: 60, max: 300. "
                        "Scripts exceeding timeout are terminated."
                    ),
                    required=False,
                    default=60,
                ),
            },
            action_type=ActionType.TOOL,
            risk_level="high",  # Arbitrary code execution
            requires_approval=True,  # Always require approval
        ),
    ]
```

Update `scripts/__init__.py` to export get_script_tools:
```python
from operator_core.scripts.validation import ScriptValidator, ValidationResult
from operator_core.scripts.executor import ScriptExecutor, ExecutionResult
from operator_core.scripts.tools import get_script_tools
from operator_core.scripts.patterns import (
    SECRET_PATTERNS,
    PYTHON_DANGEROUS_PATTERNS,
    BASH_DANGEROUS_PATTERNS,
)

__all__ = [
    "ScriptValidator",
    "ValidationResult",
    "ScriptExecutor",
    "ExecutionResult",
    "get_script_tools",
    "SECRET_PATTERNS",
    "PYTHON_DANGEROUS_PATTERNS",
    "BASH_DANGEROUS_PATTERNS",
]
```
  </action>
  <verify>
    python -c "from operator_core.scripts import get_script_tools; tools = get_script_tools(); print(f'Tool: {tools[0].name}, risk: {tools[0].risk_level}')"
  </verify>
  <done>
    - get_script_tools() returns ActionDefinition for execute_script
    - Tool description explains validation and sandboxing
    - Parameters: script_content (required), script_type (required), timeout (optional)
    - Risk level: high, requires_approval: True
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate execute_script into action framework</name>
  <files>
    packages/operator-core/src/operator_core/actions/tools.py
  </files>
  <action>
Update `actions/tools.py` to include script tools:

1. Add import for get_script_tools in get_general_tools():
```python
def get_general_tools() -> list[ActionDefinition]:
    """
    Get list of general-purpose tool definitions including Docker, Host, and Script actions.
    ...
    """
    from operator_core.docker.actions import get_docker_tools
    from operator_core.host.actions import get_host_tools
    from operator_core.scripts.tools import get_script_tools  # ADD THIS

    base_tools = [...]

    docker_tools = get_docker_tools()
    host_tools = get_host_tools()
    script_tools = get_script_tools()  # ADD THIS

    return base_tools + docker_tools + host_tools + script_tools  # UPDATE THIS
```

2. Add lazy initialization for ScriptExecutor (following Docker/Host pattern):
```python
# Lazy initialization of Script executor to avoid circular import issues
_script_executor = None


def _get_script_executor():
    """Get or create the shared Script executor instance."""
    from operator_core.scripts import ScriptExecutor

    global _script_executor
    if _script_executor is None:
        _script_executor = ScriptExecutor()
    return _script_executor
```

3. Add execute_script to TOOL_EXECUTORS:
```python
TOOL_EXECUTORS = {
    "wait": execute_wait,
    "log_message": execute_log_message,
    # Docker tools
    "docker_start_container": lambda **kw: _get_docker_executor().start_container(**kw),
    # ... (existing Docker tools)
    # Host tools
    "host_service_start": lambda **kw: _get_host_executor().start_service(**kw),
    # ... (existing Host tools)
    # Script tools - ADD THIS
    "execute_script": lambda **kw: _get_script_executor().execute(**kw),
}
```
  </action>
  <verify>
    python -c "from operator_core.actions.tools import get_general_tools, TOOL_EXECUTORS; tools = get_general_tools(); names = [t.name for t in tools]; print(f'execute_script in tools: {\"execute_script\" in names}'); print(f'execute_script in executors: {\"execute_script\" in TOOL_EXECUTORS}')"
  </verify>
  <done>
    - execute_script appears in get_general_tools() output
    - execute_script in TOOL_EXECUTORS maps to ScriptExecutor.execute()
    - Lazy initialization pattern used for ScriptExecutor
  </done>
</task>

<task type="auto">
  <name>Task 3: Add integration tests for script tool</name>
  <files>
    packages/operator-core/tests/test_script_tools.py
  </files>
  <action>
Create tests for script tool integration:

```python
"""Tests for script execution tool integration."""
import pytest
from unittest.mock import patch, MagicMock, AsyncMock

from operator_core.actions.tools import get_general_tools, execute_tool, TOOL_EXECUTORS
from operator_core.scripts import ExecutionResult


class TestScriptToolRegistration:
    """Tests for execute_script tool registration."""

    def test_execute_script_in_general_tools(self):
        """execute_script should be discoverable via get_general_tools."""
        tools = get_general_tools()
        tool_names = [t.name for t in tools]
        assert "execute_script" in tool_names

    def test_execute_script_has_correct_parameters(self):
        """execute_script should have script_content, script_type, timeout params."""
        tools = get_general_tools()
        script_tool = next(t for t in tools if t.name == "execute_script")

        assert "script_content" in script_tool.parameters
        assert "script_type" in script_tool.parameters
        assert "timeout" in script_tool.parameters

        # Check required flags
        assert script_tool.parameters["script_content"].required is True
        assert script_tool.parameters["script_type"].required is True
        assert script_tool.parameters["timeout"].required is False

    def test_execute_script_requires_approval(self):
        """execute_script should require approval (risk_level: high)."""
        tools = get_general_tools()
        script_tool = next(t for t in tools if t.name == "execute_script")

        assert script_tool.risk_level == "high"
        assert script_tool.requires_approval is True

    def test_execute_script_in_tool_executors(self):
        """execute_script should be in TOOL_EXECUTORS."""
        assert "execute_script" in TOOL_EXECUTORS


class TestScriptToolExecution:
    """Tests for execute_script execution via execute_tool."""

    @pytest.mark.asyncio
    async def test_execute_tool_calls_script_executor(self):
        """execute_tool('execute_script', ...) should call ScriptExecutor."""
        # Patch the executor to avoid actual Docker calls
        with patch("operator_core.actions.tools._get_script_executor") as mock_get_executor:
            mock_executor = MagicMock()
            mock_executor.execute = AsyncMock(return_value=ExecutionResult(
                success=True,
                stdout="Hello",
                stderr="",
                exit_code=0,
            ))
            mock_get_executor.return_value = mock_executor

            result = await execute_tool(
                "execute_script",
                {
                    "script_content": "print('Hello')",
                    "script_type": "python",
                },
            )

            mock_executor.execute.assert_called_once_with(
                script_content="print('Hello')",
                script_type="python",
            )
            assert result.success is True
            assert result.stdout == "Hello"

    @pytest.mark.asyncio
    async def test_execute_tool_passes_timeout(self):
        """execute_tool should pass timeout parameter."""
        with patch("operator_core.actions.tools._get_script_executor") as mock_get_executor:
            mock_executor = MagicMock()
            mock_executor.execute = AsyncMock(return_value=ExecutionResult(
                success=True,
                stdout="",
                stderr="",
                exit_code=0,
            ))
            mock_get_executor.return_value = mock_executor

            await execute_tool(
                "execute_script",
                {
                    "script_content": "print(1)",
                    "script_type": "python",
                    "timeout": 30,
                },
            )

            mock_executor.execute.assert_called_once_with(
                script_content="print(1)",
                script_type="python",
                timeout=30,
            )

    @pytest.mark.asyncio
    async def test_execute_tool_returns_validation_failure(self):
        """execute_tool should return validation failures correctly."""
        with patch("operator_core.actions.tools._get_script_executor") as mock_get_executor:
            mock_executor = MagicMock()
            mock_executor.execute = AsyncMock(return_value=ExecutionResult(
                success=False,
                stdout="",
                stderr="Dangerous pattern: eval() function",
                exit_code=None,
                validation_failed=True,
                error="Dangerous pattern: eval() function",
            ))
            mock_get_executor.return_value = mock_executor

            result = await execute_tool(
                "execute_script",
                {
                    "script_content": "eval('x')",
                    "script_type": "python",
                },
            )

            assert result.success is False
            assert result.validation_failed is True
            assert "eval" in result.stderr


class TestScriptToolDescription:
    """Tests for execute_script tool metadata."""

    def test_description_mentions_sandbox(self):
        """Description should mention sandboxed execution."""
        tools = get_general_tools()
        script_tool = next(t for t in tools if t.name == "execute_script")
        assert "sandbox" in script_tool.description.lower()

    def test_description_mentions_validation(self):
        """Description should mention validation."""
        tools = get_general_tools()
        script_tool = next(t for t in tools if t.name == "execute_script")
        assert "validat" in script_tool.description.lower()
```

Run with: `pytest packages/operator-core/tests/test_script_tools.py -v`
  </action>
  <verify>
    cd /Users/jrtipton/x/operator && pytest packages/operator-core/tests/test_script_tools.py -v
  </verify>
  <done>
    - Tests verify execute_script discoverable via get_general_tools()
    - Tests verify parameters are correct
    - Tests verify risk_level and requires_approval
    - Tests verify execute_tool calls ScriptExecutor.execute()
    - All tests pass
  </done>
</task>

</tasks>

<verification>
1. Tool discovery:
   ```python
   from operator_core.actions.tools import get_general_tools
   tools = get_general_tools()
   script_tool = next(t for t in tools if t.name == "execute_script")
   print(f"Name: {script_tool.name}")
   print(f"Risk: {script_tool.risk_level}")
   print(f"Approval: {script_tool.requires_approval}")
   ```

2. Tool execution (mocked):
   ```python
   import asyncio
   from operator_core.actions.tools import execute_tool

   async def main():
       result = await execute_tool(
           "execute_script",
           {"script_content": "print('hello')", "script_type": "python"}
       )
       print(result)

   asyncio.run(main())
   ```

3. Run all tests:
   ```bash
   pytest packages/operator-core/tests/test_script_*.py -v
   ```
</verification>

<success_criteria>
- execute_script tool discoverable via get_general_tools() (SCRP-01)
- Tool parameters documented: script_content, script_type, timeout
- Risk level "high" with requires_approval=True
- execute_tool("execute_script", ...) routes to ScriptExecutor.execute()
- All unit tests pass
- Existing Docker and Host tools still work
</success_criteria>

<output>
After completion, create `.planning/phases/26-script-execution/26-03-SUMMARY.md`
</output>
