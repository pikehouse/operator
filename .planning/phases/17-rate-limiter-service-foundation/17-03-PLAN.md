---
phase: 17-rate-limiter-service-foundation
plan: 03
type: execute
wave: 3
depends_on: ["17-02"]
files_modified:
  - packages/ratelimiter-service/src/ratelimiter_service/api/__init__.py
  - packages/ratelimiter-service/src/ratelimiter_service/api/rate_limit.py
  - packages/ratelimiter-service/src/ratelimiter_service/api/management.py
  - packages/ratelimiter-service/src/ratelimiter_service/metrics.py
  - packages/ratelimiter-service/src/ratelimiter_service/main.py
  - packages/ratelimiter-service/src/ratelimiter_service/node_registry.py
autonomous: true

must_haves:
  truths:
    - "POST /check returns rate limit decision with headers"
    - "GET /api/nodes returns list of registered nodes"
    - "GET /api/counters returns current rate limit counters"
    - "GET /api/limits returns configured rate limits"
    - "GET /metrics returns Prometheus metrics"
    - "Node registers itself in Redis on startup"
  artifacts:
    - path: "packages/ratelimiter-service/src/ratelimiter_service/api/rate_limit.py"
      provides: "Rate limit check endpoint"
      contains: "POST"
    - path: "packages/ratelimiter-service/src/ratelimiter_service/api/management.py"
      provides: "Management API endpoints"
      exports: ["management_router"]
    - path: "packages/ratelimiter-service/src/ratelimiter_service/metrics.py"
      provides: "Custom Prometheus metrics"
      contains: "Counter"
    - path: "packages/ratelimiter-service/src/ratelimiter_service/main.py"
      provides: "FastAPI application"
      contains: "FastAPI"
    - path: "packages/ratelimiter-service/src/ratelimiter_service/node_registry.py"
      provides: "Node registration in Redis"
      contains: "register_node"
  key_links:
    - from: "main.py"
      to: "rate_limit.py"
      via: "router inclusion"
      pattern: "include_router"
    - from: "main.py"
      to: "management.py"
      via: "router inclusion"
      pattern: "include_router"
    - from: "main.py"
      to: "metrics.py"
      via: "Instrumentator expose"
      pattern: "Instrumentator.*expose"
    - from: "api endpoints"
      to: "limiter.py"
      via: "dependency injection"
      pattern: "Depends.*get_limiter"
---

<objective>
Create HTTP API endpoints, Prometheus metrics, and FastAPI application with node registration.

Purpose: This plan implements RLSVC-03 (HTTP management API) and RLSVC-04 (Prometheus metrics), and prepares for RLSVC-01 (node registration for multi-node discovery). The result is a fully functional rate limiter service.

Output: Complete FastAPI application with rate limiting, management APIs, and metrics endpoints.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-rate-limiter-service-foundation/17-RESEARCH.md
@.planning/phases/17-rate-limiter-service-foundation/17-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rate limit and management API endpoints</name>
  <files>
    packages/ratelimiter-service/src/ratelimiter_service/api/__init__.py
    packages/ratelimiter-service/src/ratelimiter_service/api/rate_limit.py
    packages/ratelimiter-service/src/ratelimiter_service/api/management.py
  </files>
  <action>
Create the API endpoints for rate limiting and management:

1. Create `api/__init__.py`:
```python
"""API routers for rate limiter service."""
from .rate_limit import rate_limit_router
from .management import management_router

__all__ = ["rate_limit_router", "management_router"]
```

2. Create `api/rate_limit.py`:
```python
"""Rate limit check endpoint."""
from fastapi import APIRouter, Depends, Response
from pydantic import BaseModel
import redis.asyncio as redis

from ..redis_client import get_redis
from ..limiter import RateLimiter, RateLimitResult
from ..config import settings
from ..metrics import record_rate_limit_check

rate_limit_router = APIRouter(tags=["rate-limit"])


class RateLimitRequest(BaseModel):
    """Request body for rate limit check."""
    key: str
    limit: int | None = None
    window_ms: int | None = None


class RateLimitResponse(BaseModel):
    """Response from rate limit check."""
    allowed: bool
    current_count: int
    remaining: int
    retry_after_seconds: int


async def get_limiter(redis_client: redis.Redis = Depends(get_redis)) -> RateLimiter:
    """Dependency to get RateLimiter instance."""
    return RateLimiter(redis_client)


@rate_limit_router.post("/check", response_model=RateLimitResponse)
async def check_rate_limit(
    request: RateLimitRequest,
    response: Response,
    limiter: RateLimiter = Depends(get_limiter),
) -> RateLimitResponse:
    """
    Check if a request is allowed under rate limits.

    Returns rate limit decision with standard headers:
    - X-RateLimit-Limit: Max requests allowed
    - X-RateLimit-Remaining: Requests remaining in window
    - X-RateLimit-Reset: Seconds until limit resets (if blocked)
    """
    result = await limiter.check(
        key=request.key,
        limit=request.limit,
        window_ms=request.window_ms,
    )

    # Record metric
    record_rate_limit_check("allowed" if result.allowed else "blocked")

    # Set rate limit headers
    limit = request.limit if request.limit is not None else settings.default_limit
    response.headers["X-RateLimit-Limit"] = str(limit)
    response.headers["X-RateLimit-Remaining"] = str(result.remaining)
    if not result.allowed:
        response.headers["X-RateLimit-Reset"] = str(result.retry_after_seconds)
        response.status_code = 429

    return RateLimitResponse(
        allowed=result.allowed,
        current_count=result.current_count,
        remaining=result.remaining,
        retry_after_seconds=result.retry_after_seconds,
    )
```

3. Create `api/management.py`:
```python
"""Management API endpoints for observability."""
from datetime import datetime
from fastapi import APIRouter, Depends
from pydantic import BaseModel
import redis.asyncio as redis

from ..redis_client import get_redis
from ..limiter import RateLimiter
from ..config import settings
from ..node_registry import get_all_nodes

management_router = APIRouter(prefix="/api", tags=["management"])


class NodeInfo(BaseModel):
    """Information about a rate limiter node."""
    id: str
    address: str
    state: str  # "Up" or "Down" (based on TTL)
    registered_at: datetime | None = None


class NodesResponse(BaseModel):
    """Response from /api/nodes."""
    nodes: list[NodeInfo]


class CounterInfo(BaseModel):
    """Information about a rate limit counter."""
    key: str
    count: int
    limit: int
    remaining: int


class CountersResponse(BaseModel):
    """Response from /api/counters."""
    counters: list[CounterInfo]


class LimitsResponse(BaseModel):
    """Response from /api/limits."""
    default_limit: int
    default_window_ms: int


class BlockedKeyInfo(BaseModel):
    """Information about a blocked key."""
    key: str
    current_count: int
    limit: int


class BlocksResponse(BaseModel):
    """Response from /api/blocks."""
    blocked: list[BlockedKeyInfo]


async def get_limiter(redis_client: redis.Redis = Depends(get_redis)) -> RateLimiter:
    """Dependency to get RateLimiter instance."""
    return RateLimiter(redis_client)


@management_router.get("/nodes", response_model=NodesResponse)
async def list_nodes(redis_client: redis.Redis = Depends(get_redis)) -> NodesResponse:
    """Return list of registered rate limiter nodes."""
    nodes = await get_all_nodes(redis_client)
    return NodesResponse(nodes=nodes)


@management_router.get("/counters", response_model=CountersResponse)
async def get_counters(
    redis_client: redis.Redis = Depends(get_redis),
    limiter: RateLimiter = Depends(get_limiter),
) -> CountersResponse:
    """Return current rate limit counters from Redis."""
    counters = []

    # Scan for all ratelimit keys (excluding :seq keys)
    async for key in redis_client.scan_iter("ratelimit:*"):
        if key.endswith(":seq"):
            continue

        # Strip prefix for display
        display_key = key.replace("ratelimit:", "", 1)
        count = await limiter.get_counter(display_key)

        counters.append(CounterInfo(
            key=display_key,
            count=count,
            limit=settings.default_limit,
            remaining=max(0, settings.default_limit - count),
        ))

    return CountersResponse(counters=counters)


@management_router.get("/limits", response_model=LimitsResponse)
async def get_limits() -> LimitsResponse:
    """Return configured rate limits."""
    return LimitsResponse(
        default_limit=settings.default_limit,
        default_window_ms=settings.default_window_ms,
    )


@management_router.get("/blocks", response_model=BlocksResponse)
async def get_blocks(
    redis_client: redis.Redis = Depends(get_redis),
    limiter: RateLimiter = Depends(get_limiter),
) -> BlocksResponse:
    """Return keys that are currently at or over their limit."""
    blocked = []

    async for key in redis_client.scan_iter("ratelimit:*"):
        if key.endswith(":seq"):
            continue

        display_key = key.replace("ratelimit:", "", 1)
        count = await limiter.get_counter(display_key)

        if count >= settings.default_limit:
            blocked.append(BlockedKeyInfo(
                key=display_key,
                current_count=count,
                limit=settings.default_limit,
            ))

    return BlocksResponse(blocked=blocked)
```
  </action>
  <verify>
    cd /Users/jrtipton/x/operator && python -c "from ratelimiter_service.api import rate_limit_router, management_router; print('API routers loaded')"
  </verify>
  <done>API endpoints created for /check, /api/nodes, /api/counters, /api/limits, /api/blocks</done>
</task>

<task type="auto">
  <name>Task 2: Create Prometheus metrics and node registry</name>
  <files>
    packages/ratelimiter-service/src/ratelimiter_service/metrics.py
    packages/ratelimiter-service/src/ratelimiter_service/node_registry.py
  </files>
  <action>
Create metrics and node registration:

1. Create `metrics.py`:
```python
"""Prometheus metrics for rate limiter service."""
from prometheus_client import Counter, Histogram, Gauge

# Rate limit check metrics
REQUESTS_CHECKED = Counter(
    "ratelimiter_requests_checked_total",
    "Total rate limit checks performed",
    ["result"],  # "allowed" or "blocked"
)

CHECK_LATENCY = Histogram(
    "ratelimiter_check_duration_seconds",
    "Rate limit check latency in seconds",
    buckets=[0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0],
)

# Node status metrics
NODE_UP = Gauge(
    "ratelimiter_node_up",
    "Whether this node is up (1) or down (0)",
)

ACTIVE_COUNTERS = Gauge(
    "ratelimiter_active_counters",
    "Number of active rate limit counters",
)


def record_rate_limit_check(result: str) -> None:
    """Record a rate limit check result."""
    REQUESTS_CHECKED.labels(result=result).inc()


def set_node_up(up: bool) -> None:
    """Set node up status."""
    NODE_UP.set(1 if up else 0)


def set_active_counters(count: int) -> None:
    """Set number of active counters."""
    ACTIVE_COUNTERS.set(count)
```

2. Create `node_registry.py`:
```python
"""Node registration and discovery via Redis."""
import asyncio
from datetime import datetime
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    import redis.asyncio as redis

from .config import settings


async def register_node(redis_client: "redis.Redis") -> None:
    """Register this node in Redis with TTL for heartbeat."""
    key = f"ratelimiter:nodes:{settings.node_id}"
    await redis_client.hset(key, mapping={
        "address": f"{settings.node_host}:{settings.node_port}",
        "registered_at": datetime.now().isoformat(),
    })
    await redis_client.expire(key, settings.node_ttl_seconds)


async def unregister_node(redis_client: "redis.Redis") -> None:
    """Unregister this node from Redis."""
    key = f"ratelimiter:nodes:{settings.node_id}"
    await redis_client.delete(key)


async def heartbeat_loop(redis_client: "redis.Redis") -> None:
    """Background task to maintain node registration."""
    while True:
        try:
            await register_node(redis_client)
            await asyncio.sleep(settings.node_heartbeat_seconds)
        except asyncio.CancelledError:
            break
        except Exception:
            # Log error but continue heartbeat
            await asyncio.sleep(settings.node_heartbeat_seconds)


async def get_all_nodes(redis_client: "redis.Redis") -> list[dict]:
    """Discover all registered nodes from Redis."""
    from .api.management import NodeInfo

    nodes = []
    async for key in redis_client.scan_iter("ratelimiter:nodes:*"):
        data = await redis_client.hgetall(key)
        if not data:
            continue

        node_id = key.split(":")[-1]
        registered_at = None
        if "registered_at" in data:
            try:
                registered_at = datetime.fromisoformat(data["registered_at"])
            except (ValueError, TypeError):
                pass

        nodes.append(NodeInfo(
            id=node_id,
            address=data.get("address", "unknown"),
            state="Up",  # If key exists with TTL, node is up
            registered_at=registered_at,
        ))

    return nodes
```
  </action>
  <verify>
    cd /Users/jrtipton/x/operator && python -c "from ratelimiter_service.metrics import record_rate_limit_check, REQUESTS_CHECKED; from ratelimiter_service.node_registry import register_node; print('Metrics and registry loaded')"
  </verify>
  <done>Prometheus metrics defined, node registration implemented</done>
</task>

<task type="auto">
  <name>Task 3: Create FastAPI main application</name>
  <files>
    packages/ratelimiter-service/src/ratelimiter_service/main.py
  </files>
  <action>
Create the main FastAPI application:

```python
"""FastAPI application for rate limiter service."""
import asyncio
from contextlib import asynccontextmanager

from fastapi import FastAPI
from prometheus_fastapi_instrumentator import Instrumentator

from .config import settings
from .redis_client import init_redis_pool, close_redis_pool, get_redis
from .api import rate_limit_router, management_router
from .node_registry import register_node, unregister_node, heartbeat_loop
from .metrics import set_node_up


# Background task handle
_heartbeat_task: asyncio.Task | None = None


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan manager for startup/shutdown."""
    global _heartbeat_task

    # Startup
    await init_redis_pool()

    # Register node and start heartbeat
    redis_client = await get_redis()
    await register_node(redis_client)
    _heartbeat_task = asyncio.create_task(heartbeat_loop(redis_client))
    set_node_up(True)

    yield

    # Shutdown
    set_node_up(False)

    # Stop heartbeat
    if _heartbeat_task:
        _heartbeat_task.cancel()
        try:
            await _heartbeat_task
        except asyncio.CancelledError:
            pass

    # Unregister node
    try:
        redis_client = await get_redis()
        await unregister_node(redis_client)
    except Exception:
        pass  # Best effort cleanup

    await close_redis_pool()


app = FastAPI(
    title="Rate Limiter Service",
    description="Distributed rate limiter with Redis backend for operator demo",
    version="0.1.0",
    lifespan=lifespan,
)

# Include routers
app.include_router(rate_limit_router)
app.include_router(management_router)

# Setup Prometheus metrics
Instrumentator().instrument(app).expose(app)


@app.get("/health")
async def health_check():
    """Health check endpoint."""
    return {"status": "healthy", "node_id": settings.node_id}


# Entry point for uvicorn
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "ratelimiter_service.main:app",
        host="0.0.0.0",
        port=settings.node_port,
        reload=True,
    )
```

This creates a complete FastAPI app with:
- Lifespan management for Redis pool and node registration
- Rate limit and management API routers
- Prometheus metrics at /metrics (via instrumentator)
- Health check endpoint at /health
- Configurable via environment variables
  </action>
  <verify>
    cd /Users/jrtipton/x/operator && python -c "from ratelimiter_service.main import app; print(f'App title: {app.title}, routes: {len(app.routes)}')"
  </verify>
  <done>FastAPI application created with all routers, metrics, and lifecycle management</done>
</task>

</tasks>

<verification>
1. All modules import: `python -c "from ratelimiter_service.main import app; from ratelimiter_service.api import rate_limit_router, management_router; from ratelimiter_service.metrics import REQUESTS_CHECKED"`

2. App has expected routes:
```bash
python -c "
from ratelimiter_service.main import app
routes = [r.path for r in app.routes if hasattr(r, 'path')]
print('Routes:', sorted(routes))
assert '/check' in routes
assert '/api/nodes' in routes
assert '/api/counters' in routes
assert '/health' in routes
assert '/metrics' in routes
print('All expected routes present')
"
```

3. Manual test (requires Redis):
```bash
# In terminal 1:
cd packages/ratelimiter-service
RATELIMITER_NODE_ID=test-node uvicorn ratelimiter_service.main:app --port 8000

# In terminal 2:
curl http://localhost:8000/health
curl http://localhost:8000/api/limits
curl -X POST http://localhost:8000/check -H "Content-Type: application/json" -d '{"key": "user:1"}'
curl http://localhost:8000/api/counters
curl http://localhost:8000/metrics
```
</verification>

<success_criteria>
- POST /check endpoint returns rate limit decision with X-RateLimit-* headers
- GET /api/nodes returns registered nodes from Redis
- GET /api/counters returns current rate limit counters
- GET /api/limits returns configured limits
- GET /api/blocks returns keys at or over limit
- GET /metrics returns Prometheus metrics
- GET /health returns node health status
- Node registers itself in Redis on startup
- Node heartbeat maintains registration TTL
- Node unregisters on shutdown
</success_criteria>

<output>
After completion, create `.planning/phases/17-rate-limiter-service-foundation/17-03-SUMMARY.md`
</output>
