---
phase: 17-rate-limiter-service-foundation
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - packages/ratelimiter-service/src/ratelimiter_service/limiter.py
  - packages/ratelimiter-service/tests/__init__.py
  - packages/ratelimiter-service/tests/test_limiter.py
autonomous: true

must_haves:
  truths:
    - "Lua script executes atomically in Redis"
    - "Rate limiter correctly enforces limits under concurrent load"
    - "Sliding window properly expires old entries"
    - "Results include allowed/blocked status, count, and remaining"
  artifacts:
    - path: "packages/ratelimiter-service/src/ratelimiter_service/limiter.py"
      provides: "RateLimiter class with Lua-based sliding window"
      contains: "SLIDING_WINDOW_SCRIPT"
      exports: ["RateLimiter", "RateLimitResult"]
    - path: "packages/ratelimiter-service/tests/test_limiter.py"
      provides: "Tests for rate limiter logic"
      contains: "test_"
  key_links:
    - from: "limiter.py"
      to: "redis"
      via: "Lua script execution"
      pattern: "register_script|evalsha"
---

<objective>
Implement the sliding window rate limiter with atomic Lua script execution.

Purpose: This is the core rate limiting logic that satisfies RLSVC-02 (sliding window counter with atomic Lua scripts). The Lua script ensures no race conditions under concurrent load.

Output: RateLimiter class that can check rate limits atomically using Redis sorted sets.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-rate-limiter-service-foundation/17-RESEARCH.md
@.planning/phases/17-rate-limiter-service-foundation/17-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement sliding window rate limiter with Lua script</name>
  <files>
    packages/ratelimiter-service/src/ratelimiter_service/limiter.py
  </files>
  <action>
Create the rate limiter with atomic Lua script (from RESEARCH.md patterns):

1. Create `limiter.py` with:

```python
"""Sliding window rate limiter using Redis sorted sets and Lua scripts."""
import time
from dataclasses import dataclass
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    import redis.asyncio as redis

# Lua script for atomic sliding window rate limiting
# KEYS[1] = rate limit key (e.g., "ratelimit:user:123")
# ARGV[1] = current timestamp (milliseconds)
# ARGV[2] = window size (milliseconds)
# ARGV[3] = max requests
# Returns: [allowed (0/1), current_count, remaining, retry_after_seconds]
SLIDING_WINDOW_SCRIPT = """
local key = KEYS[1]
local now = tonumber(ARGV[1])
local window = tonumber(ARGV[2])
local max_requests = tonumber(ARGV[3])

-- Clean expired entries (before window start)
redis.call('ZREMRANGEBYSCORE', key, '-inf', now - window)

-- Get current count
local count = redis.call('ZCARD', key)

-- Check if over limit
if count >= max_requests then
    local oldest = redis.call('ZRANGE', key, 0, 0, 'WITHSCORES')
    local retry_after = 0
    if #oldest > 0 then
        retry_after = math.ceil((tonumber(oldest[2]) + window - now) / 1000)
    end
    return {0, count, 0, retry_after}  -- blocked
end

-- Add request with unique member (timestamp:sequence)
local member = now .. ':' .. redis.call('INCR', key .. ':seq')
redis.call('ZADD', key, now, member)
redis.call('EXPIRE', key, math.ceil(window / 1000) + 1)

return {1, count + 1, max_requests - count - 1, 0}  -- allowed
"""


@dataclass
class RateLimitResult:
    """Result of a rate limit check."""
    allowed: bool
    current_count: int
    remaining: int
    retry_after_seconds: int

    @classmethod
    def from_lua_result(cls, result: list) -> "RateLimitResult":
        """Create from Lua script return value."""
        return cls(
            allowed=bool(result[0]),
            current_count=int(result[1]),
            remaining=int(result[2]),
            retry_after_seconds=int(result[3]),
        )


class RateLimiter:
    """Sliding window rate limiter using Redis sorted sets."""

    def __init__(self, redis_client: "redis.Redis"):
        self._redis = redis_client
        self._script = redis_client.register_script(SLIDING_WINDOW_SCRIPT)

    async def check(
        self,
        key: str,
        limit: int | None = None,
        window_ms: int | None = None,
    ) -> RateLimitResult:
        """
        Check if request is allowed under rate limit.

        Args:
            key: Rate limit key (e.g., "user:123")
            limit: Max requests in window (uses config default if None)
            window_ms: Window size in milliseconds (uses config default if None)

        Returns:
            RateLimitResult with allowed status and metadata
        """
        from .config import settings

        limit = limit if limit is not None else settings.default_limit
        window_ms = window_ms if window_ms is not None else settings.default_window_ms

        now_ms = int(time.time() * 1000)
        prefixed_key = f"ratelimit:{key}"

        result = await self._script(
            keys=[prefixed_key],
            args=[now_ms, window_ms, limit],
        )
        return RateLimitResult.from_lua_result(result)

    async def get_counter(self, key: str, window_ms: int | None = None) -> int:
        """Get current count for a key without incrementing."""
        from .config import settings

        window_ms = window_ms if window_ms is not None else settings.default_window_ms
        now_ms = int(time.time() * 1000)
        window_start = now_ms - window_ms
        prefixed_key = f"ratelimit:{key}"

        # Remove expired and count
        await self._redis.zremrangebyscore(prefixed_key, "-inf", window_start)
        count = await self._redis.zcard(prefixed_key)
        return count

    async def reset_counter(self, key: str) -> bool:
        """Reset rate limit counter for a key."""
        prefixed_key = f"ratelimit:{key}"
        seq_key = f"{prefixed_key}:seq"
        deleted = await self._redis.delete(prefixed_key, seq_key)
        return deleted > 0
```

Key implementation notes:
- Lua script runs atomically - no race conditions
- Uses sorted set (ZADD with score = timestamp) for sliding window
- ZREMRANGEBYSCORE cleans up expired entries before checking
- Unique member format (timestamp:sequence) prevents duplicates at same millisecond
- EXPIRE on key prevents memory leaks
- Prefix keys with "ratelimit:" for namespacing
  </action>
  <verify>
    cd /Users/jrtipton/x/operator && python -c "from ratelimiter_service.limiter import RateLimiter, RateLimitResult, SLIDING_WINDOW_SCRIPT; print('Limiter module loaded')"
  </verify>
  <done>RateLimiter class loads without errors, Lua script is defined</done>
</task>

<task type="auto">
  <name>Task 2: Create limiter tests</name>
  <files>
    packages/ratelimiter-service/tests/__init__.py
    packages/ratelimiter-service/tests/test_limiter.py
  </files>
  <action>
Create tests for the rate limiter logic:

1. Create `tests/__init__.py` (empty file)

2. Create `tests/test_limiter.py`:

```python
"""Tests for the sliding window rate limiter."""
import pytest
import asyncio
import redis.asyncio as redis
from ratelimiter_service.limiter import RateLimiter, RateLimitResult


@pytest.fixture
async def redis_client():
    """Create Redis client for tests."""
    client = redis.Redis.from_url("redis://localhost:6379", decode_responses=True)
    yield client
    # Cleanup test keys
    async for key in client.scan_iter("ratelimit:test:*"):
        await client.delete(key)
    await client.aclose()


@pytest.fixture
async def limiter(redis_client):
    """Create RateLimiter instance."""
    return RateLimiter(redis_client)


class TestRateLimiter:
    """Tests for RateLimiter class."""

    @pytest.mark.asyncio
    async def test_allows_under_limit(self, limiter):
        """Requests under limit should be allowed."""
        result = await limiter.check("test:user1", limit=10, window_ms=60000)
        assert result.allowed is True
        assert result.current_count == 1
        assert result.remaining == 9
        assert result.retry_after_seconds == 0

    @pytest.mark.asyncio
    async def test_blocks_at_limit(self, limiter):
        """Requests at limit should be blocked."""
        key = "test:user2"
        limit = 3

        # Use up the limit
        for i in range(limit):
            result = await limiter.check(key, limit=limit, window_ms=60000)
            assert result.allowed is True, f"Request {i+1} should be allowed"

        # Next request should be blocked
        result = await limiter.check(key, limit=limit, window_ms=60000)
        assert result.allowed is False
        assert result.current_count == limit
        assert result.remaining == 0
        assert result.retry_after_seconds > 0

    @pytest.mark.asyncio
    async def test_get_counter(self, limiter):
        """get_counter should return current count without incrementing."""
        key = "test:user3"

        # Initially zero
        count = await limiter.get_counter(key)
        assert count == 0

        # Make some requests
        await limiter.check(key, limit=10, window_ms=60000)
        await limiter.check(key, limit=10, window_ms=60000)

        # Should be 2, not incrementing
        count = await limiter.get_counter(key)
        assert count == 2

        count = await limiter.get_counter(key)
        assert count == 2  # Still 2

    @pytest.mark.asyncio
    async def test_reset_counter(self, limiter):
        """reset_counter should clear rate limit state."""
        key = "test:user4"

        # Make some requests
        await limiter.check(key, limit=10, window_ms=60000)
        await limiter.check(key, limit=10, window_ms=60000)

        count = await limiter.get_counter(key)
        assert count == 2

        # Reset
        result = await limiter.reset_counter(key)
        assert result is True

        count = await limiter.get_counter(key)
        assert count == 0

    @pytest.mark.asyncio
    async def test_concurrent_requests(self, limiter):
        """Rate limiter should be accurate under concurrent load."""
        key = "test:concurrent"
        limit = 10

        # Send 20 concurrent requests with limit of 10
        async def make_request():
            return await limiter.check(key, limit=limit, window_ms=60000)

        results = await asyncio.gather(*[make_request() for _ in range(20)])

        allowed = sum(1 for r in results if r.allowed)
        blocked = sum(1 for r in results if not r.allowed)

        # Exactly 10 should be allowed, 10 blocked
        assert allowed == limit, f"Expected {limit} allowed, got {allowed}"
        assert blocked == 10, f"Expected 10 blocked, got {blocked}"

    @pytest.mark.asyncio
    async def test_different_keys_independent(self, limiter):
        """Different keys should have independent limits."""
        # Fill up user1's limit
        for _ in range(5):
            await limiter.check("test:user5a", limit=5, window_ms=60000)

        result = await limiter.check("test:user5a", limit=5, window_ms=60000)
        assert result.allowed is False

        # user2 should still be allowed
        result = await limiter.check("test:user5b", limit=5, window_ms=60000)
        assert result.allowed is True


class TestRateLimitResult:
    """Tests for RateLimitResult dataclass."""

    def test_from_lua_result(self):
        """Should correctly parse Lua script output."""
        # Allowed result
        result = RateLimitResult.from_lua_result([1, 5, 95, 0])
        assert result.allowed is True
        assert result.current_count == 5
        assert result.remaining == 95
        assert result.retry_after_seconds == 0

        # Blocked result
        result = RateLimitResult.from_lua_result([0, 100, 0, 45])
        assert result.allowed is False
        assert result.current_count == 100
        assert result.remaining == 0
        assert result.retry_after_seconds == 45
```

Note: Tests require a running Redis server. Add pytest and pytest-asyncio to dev dependencies if needed.
  </action>
  <verify>
    cd /Users/jrtipton/x/operator/packages/ratelimiter-service && python -m pytest tests/test_limiter.py -v --tb=short 2>/dev/null || echo "Tests require Redis - will verify in integration"
  </verify>
  <done>Test file created with comprehensive coverage of rate limiter logic. Tests pass when Redis is available.</done>
</task>

</tasks>

<verification>
1. Module loads: `python -c "from ratelimiter_service.limiter import RateLimiter, RateLimitResult"`
2. Lua script defined: `python -c "from ratelimiter_service.limiter import SLIDING_WINDOW_SCRIPT; print(len(SLIDING_WINDOW_SCRIPT), 'chars')"`
3. Tests exist: `ls packages/ratelimiter-service/tests/test_limiter.py`
4. Tests run (requires Redis): `cd packages/ratelimiter-service && pytest tests/ -v`
</verification>

<success_criteria>
- RateLimiter class implements sliding window algorithm with Lua script
- Lua script handles cleanup, counting, and atomic increment
- RateLimitResult provides typed access to check results
- Tests verify correctness under concurrent load
- Tests verify independent limits per key
</success_criteria>

<output>
After completion, create `.planning/phases/17-rate-limiter-service-foundation/17-02-SUMMARY.md`
</output>
