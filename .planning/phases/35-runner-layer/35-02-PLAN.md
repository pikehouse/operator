---
phase: 35-runner-layer
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - eval/subjects/__init__.py
  - eval/subjects/tikv/__init__.py
  - eval/subjects/tikv/subject.py
  - eval/subjects/tikv/chaos.py
autonomous: true

must_haves:
  truths:
    - "TiKVEvalSubject satisfies EvalSubject protocol"
    - "TiKVEvalSubject can reset cluster via Docker Compose"
    - "node_kill chaos injects SIGKILL to random TiKV container"
  artifacts:
    - path: "eval/subjects/tikv/subject.py"
      provides: "TiKVEvalSubject class"
      contains: "class TiKVEvalSubject"
    - path: "eval/subjects/tikv/chaos.py"
      provides: "TiKV chaos injection functions"
      contains: "async def kill_random_tikv"
  key_links:
    - from: "eval/subjects/tikv/subject.py"
      to: "eval/subjects/tikv/chaos.py"
      via: "imports chaos functions"
      pattern: "from eval.subjects.tikv.chaos import"
    - from: "eval/subjects/tikv/subject.py"
      to: "python_on_whales"
      via: "asyncio.to_thread wrapper"
      pattern: "asyncio.to_thread.*docker"
---

<objective>
Implement TiKVEvalSubject that satisfies EvalSubject protocol with Docker Compose lifecycle and node_kill chaos.

Purpose: Create the first concrete eval subject that can reset TiKV clusters, capture state, and inject chaos. This validates the EvalSubject protocol design.

Output: TiKVEvalSubject class in eval/subjects/tikv/ that works with subjects/tikv/docker-compose.yaml.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/35-runner-layer/35-RESEARCH.md

# Reference for existing chaos patterns
@demo/tikv_chaos.py

# Reference for TiKV cluster structure
@subjects/tikv/docker-compose.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create eval subjects directory structure</name>
  <files>
    eval/subjects/__init__.py
    eval/subjects/tikv/__init__.py
  </files>
  <action>
Create the subjects directory structure under eval/:

1. Create `eval/subjects/__init__.py`:
```python
"""Evaluation subjects for chaos engineering trials."""
```

2. Create `eval/subjects/tikv/__init__.py`:
```python
"""TiKV evaluation subject."""

from eval.subjects.tikv.subject import TiKVEvalSubject

__all__ = ["TiKVEvalSubject"]
```

Directory structure:
```
eval/
└── subjects/
    ├── __init__.py
    └── tikv/
        └── __init__.py
```
  </action>
  <verify>
Run: `ls -la eval/subjects/ && ls -la eval/subjects/tikv/`
Confirm directories and __init__.py files exist.
  </verify>
  <done>eval/subjects/tikv/ directory exists with __init__.py files</done>
</task>

<task type="auto">
  <name>Task 2: Implement TiKV chaos injection</name>
  <files>
    eval/subjects/tikv/chaos.py
  </files>
  <action>
Create chaos.py with TiKV-specific chaos functions (SUBJ-03):

```python
"""TiKV chaos injection functions for evaluation harness."""

import asyncio
import random
from pathlib import Path
from typing import Any

from python_on_whales import DockerClient


async def kill_random_tikv(docker: DockerClient) -> dict[str, Any]:
    """Kill a random TiKV container with SIGKILL.

    Simulates sudden node failure (crash, hardware fault).

    Args:
        docker: DockerClient configured with compose file

    Returns:
        Chaos metadata dict with target_container, signal

    Raises:
        RuntimeError: If no running TiKV containers found
    """
    # Get running containers in thread pool (python-on-whales is sync)
    containers = await asyncio.to_thread(docker.compose.ps)

    # Filter to running TiKV containers
    tikv_containers = [
        c for c in containers
        if 'tikv' in c.name.lower() and c.state.running
    ]

    if not tikv_containers:
        raise RuntimeError("No running TiKV containers to kill")

    # Random selection
    target = random.choice(tikv_containers)

    # Kill with SIGKILL in thread pool
    await asyncio.to_thread(docker.kill, target.name)

    return {
        "chaos_type": "node_kill",
        "target_container": target.name,
        "signal": "SIGKILL",
    }
```

IMPORTANT: All python-on-whales calls MUST use `asyncio.to_thread()` per RESEARCH.md pitfall #2.
  </action>
  <verify>
Run: `cat eval/subjects/tikv/chaos.py | grep -c "asyncio.to_thread"`
Should show at least 2 occurrences (for docker.compose.ps and docker.kill).
  </verify>
  <done>chaos.py contains kill_random_tikv function that wraps docker calls with asyncio.to_thread</done>
</task>

<task type="auto">
  <name>Task 3: Implement TiKVEvalSubject</name>
  <files>
    eval/subjects/tikv/subject.py
  </files>
  <action>
Create subject.py implementing EvalSubject protocol (SUBJ-02):

```python
"""TiKV evaluation subject implementing EvalSubject protocol."""

import asyncio
import json
from pathlib import Path
from typing import Any

import httpx
from python_on_whales import DockerClient

from eval.subjects.tikv.chaos import kill_random_tikv


class TiKVEvalSubject:
    """TiKV cluster evaluation subject.

    Implements EvalSubject protocol for TiKV clusters managed via Docker Compose.
    Uses subjects/tikv/docker-compose.yaml by default.
    """

    def __init__(self, compose_file: Path | None = None):
        """Initialize TiKV eval subject.

        Args:
            compose_file: Path to docker-compose.yaml. Defaults to subjects/tikv/docker-compose.yaml.
        """
        if compose_file is None:
            # Default to subjects/tikv/docker-compose.yaml relative to repo root
            compose_file = Path(__file__).parents[4] / "subjects" / "tikv" / "docker-compose.yaml"

        self.compose_file = compose_file
        self.docker = DockerClient(compose_files=[compose_file])
        self.pd_endpoint = "http://localhost:2379"  # PD API endpoint

    async def reset(self) -> None:
        """Reset TiKV cluster via docker-compose down/up with volume wipe."""
        # Down with volume cleanup (removes all data)
        await asyncio.to_thread(
            self.docker.compose.down,
            volumes=True,
            remove_orphans=True,
        )

        # Up and wait for healthchecks
        await asyncio.to_thread(
            self.docker.compose.up,
            detach=True,
            wait=True,
        )

    async def wait_healthy(self, timeout_sec: float = 60.0) -> bool:
        """Wait for all TiKV + PD containers to be healthy.

        Checks both Docker healthcheck status AND PD API for store count.
        """
        start = asyncio.get_running_loop().time()

        while (asyncio.get_running_loop().time() - start) < timeout_sec:
            try:
                # Check container health in thread pool
                containers = await asyncio.to_thread(self.docker.compose.ps)

                # Filter to PD + TiKV containers
                cluster_containers = [
                    c for c in containers
                    if ('pd' in c.name.lower() or 'tikv' in c.name.lower())
                ]

                # All containers must be running with healthy status
                all_healthy = all(
                    c.state.running and c.state.health in ('healthy', None)
                    for c in cluster_containers
                )

                if all_healthy:
                    # Additional verification: PD reports 3 stores
                    if await self._verify_stores_up():
                        return True

            except Exception:
                pass  # Container not ready yet

            await asyncio.sleep(2.0)

        return False

    async def capture_state(self) -> dict[str, Any]:
        """Capture PD cluster state via API.

        Returns store count, region count, and health status.
        """
        try:
            async with httpx.AsyncClient(timeout=5.0) as client:
                # Query stores endpoint
                stores_resp = await client.get(f"{self.pd_endpoint}/pd/api/v1/stores")
                stores_data = stores_resp.json()

                # Query regions endpoint (summary)
                regions_resp = await client.get(f"{self.pd_endpoint}/pd/api/v1/stats/region")
                regions_data = regions_resp.json()

                return {
                    "store_count": stores_data.get("count", 0),
                    "stores": [
                        {
                            "id": s.get("store", {}).get("id"),
                            "address": s.get("store", {}).get("address"),
                            "state_name": s.get("store", {}).get("state_name"),
                        }
                        for s in stores_data.get("stores", [])
                    ],
                    "region_count": regions_data.get("count", 0),
                }
        except Exception as e:
            return {"error": str(e)}

    def get_chaos_types(self) -> list[str]:
        """Return supported chaos types for TiKV."""
        return ["node_kill"]

    async def inject_chaos(self, chaos_type: str) -> dict[str, Any]:
        """Inject specified chaos type.

        Args:
            chaos_type: One of get_chaos_types() values

        Returns:
            Chaos metadata dict

        Raises:
            ValueError: If chaos_type not supported
        """
        if chaos_type == "node_kill":
            return await kill_random_tikv(self.docker)

        raise ValueError(f"Unknown chaos type: {chaos_type}. Supported: {self.get_chaos_types()}")

    async def _verify_stores_up(self) -> bool:
        """Verify PD reports 3 TiKV stores in Up state."""
        try:
            async with httpx.AsyncClient(timeout=5.0) as client:
                resp = await client.get(f"{self.pd_endpoint}/pd/api/v1/stores")
                data = resp.json()

                stores = data.get("stores", [])
                up_stores = [
                    s for s in stores
                    if s.get("store", {}).get("state_name") == "Up"
                ]

                return len(up_stores) >= 3
        except Exception:
            return False
```

Key patterns from RESEARCH.md:
- All python-on-whales calls wrapped with `asyncio.to_thread()`
- Uses httpx.AsyncClient for PD API (already async)
- Verifies cluster formation, not just container health (pitfall #5)
  </action>
  <verify>
Run: `cd eval && uv run python -c "from eval.subjects.tikv import TiKVEvalSubject; from eval import EvalSubject; s = TiKVEvalSubject(); print(isinstance(s, EvalSubject))"`
Should print "True" confirming protocol satisfaction.
  </verify>
  <done>TiKVEvalSubject implements all EvalSubject methods, satisfies @runtime_checkable protocol check</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `ls -la eval/subjects/tikv/` shows __init__.py, subject.py, chaos.py
2. `uv run python -c "from eval.subjects.tikv import TiKVEvalSubject; print(TiKVEvalSubject)"` succeeds
3. `uv run python -c "from eval import EvalSubject; from eval.subjects.tikv import TiKVEvalSubject; print(isinstance(TiKVEvalSubject(), EvalSubject))"` prints True
4. `grep -c "asyncio.to_thread" eval/subjects/tikv/*.py` shows multiple occurrences (no blocking calls)
</verification>

<success_criteria>
- [ ] eval/subjects/tikv/ directory exists with __init__.py, subject.py, chaos.py
- [ ] TiKVEvalSubject class exists with reset(), wait_healthy(), capture_state(), get_chaos_types(), inject_chaos()
- [ ] isinstance(TiKVEvalSubject(), EvalSubject) returns True
- [ ] kill_random_tikv() uses asyncio.to_thread() for docker calls
- [ ] TiKVEvalSubject.reset() uses asyncio.to_thread() for compose down/up
- [ ] TiKVEvalSubject.wait_healthy() verifies stores via PD API, not just container health
</success_criteria>

<output>
After completion, create `.planning/phases/35-runner-layer/35-02-SUMMARY.md`
</output>
