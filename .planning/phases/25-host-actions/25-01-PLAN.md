---
phase: 25-host-actions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/operator-core/src/operator_core/host/__init__.py
  - packages/operator-core/src/operator_core/host/actions.py
  - packages/operator-core/src/operator_core/host/validation.py
  - packages/operator-core/tests/test_host_actions.py
autonomous: true

must_haves:
  truths:
    - "HostActionExecutor can start a systemd service via asyncio.create_subprocess_exec"
    - "HostActionExecutor can stop a systemd service with validation"
    - "HostActionExecutor can restart a systemd service"
    - "Service name whitelist prevents operations on unauthorized services"
    - "Forbidden services (systemd, ssh, dbus) are blocked even if manually whitelisted"
  artifacts:
    - path: "packages/operator-core/src/operator_core/host/actions.py"
      provides: "HostActionExecutor class with start_service, stop_service, restart_service methods"
      exports: ["HostActionExecutor"]
    - path: "packages/operator-core/src/operator_core/host/validation.py"
      provides: "ServiceWhitelist class with is_allowed method"
      exports: ["ServiceWhitelist"]
    - path: "packages/operator-core/tests/test_host_actions.py"
      provides: "Unit tests for service actions and validation"
      min_lines: 100
  key_links:
    - from: "host/actions.py"
      to: "host/validation.py"
      via: "ServiceWhitelist import and usage"
      pattern: "self\\._whitelist\\.is_allowed"
    - from: "host/actions.py"
      to: "asyncio.create_subprocess_exec"
      via: "subprocess execution without shell"
      pattern: "asyncio\\.create_subprocess_exec"
---

<objective>
Create HostActionExecutor with systemd service control methods (start/stop/restart) and ServiceWhitelist validation.

Purpose: Enable agent to control systemd services for host-level remediation scenarios, with security controls preventing unauthorized service operations.

Output: HostActionExecutor class with three async service methods, ServiceWhitelist validator, and comprehensive unit tests.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/25-host-actions/25-RESEARCH.md

# Prior work patterns to follow
@packages/operator-core/src/operator_core/docker/actions.py
@packages/operator-core/src/operator_core/docker/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ServiceWhitelist validation class</name>
  <files>packages/operator-core/src/operator_core/host/__init__.py, packages/operator-core/src/operator_core/host/validation.py</files>
  <action>
Create host/ subpackage with:

1. `__init__.py` - Export ServiceWhitelist, HostActionExecutor (HostActionExecutor will be added in Task 2)

2. `validation.py` - ServiceWhitelist class:
   - DEFAULT_WHITELIST: set[str] containing common services: nginx, redis-server, postgresql, mysql, tikv, pd, ratelimiter, docker
   - FORBIDDEN_SERVICES: set[str] containing critical services that must NEVER be controlled: systemd, dbus, ssh, sshd, networking, network-manager, systemd-resolved, systemd-networkd, init
   - __init__(whitelist: set[str] | None = None) - Accept optional custom whitelist, default to DEFAULT_WHITELIST.copy()
   - is_allowed(service_name: str) -> bool - Return False if in FORBIDDEN_SERVICES, True if in whitelist
   - add_service(service_name: str) -> None - Add service to whitelist, raise ValueError if attempting to add forbidden service
   - validate_service_name(service_name: str) -> None - Raise ValueError if service contains path separators (/, ..) to prevent path traversal

Per HOST-06: Service name whitelist prevents operations on unauthorized services.

Note: Forbidden services take precedence - even if someone manually adds 'systemd' to whitelist, is_allowed() returns False.
  </action>
  <verify>
Run: `cd /Users/jrtipton/x/operator && python -c "from operator_core.host.validation import ServiceWhitelist; w = ServiceWhitelist(); print('nginx allowed:', w.is_allowed('nginx')); print('systemd allowed:', w.is_allowed('systemd')); print('random allowed:', w.is_allowed('random'))"`
Expected: nginx allowed: True, systemd allowed: False, random allowed: False
  </verify>
  <done>ServiceWhitelist validates service names against whitelist and blocks forbidden services</done>
</task>

<task type="auto">
  <name>Task 2: Create HostActionExecutor with service methods</name>
  <files>packages/operator-core/src/operator_core/host/actions.py, packages/operator-core/src/operator_core/host/__init__.py</files>
  <action>
Create HostActionExecutor class following DockerActionExecutor pattern:

1. `actions.py` - HostActionExecutor class:
   - __init__(service_whitelist: set[str] | None = None) - Create ServiceWhitelist instance
   - All methods use asyncio.create_subprocess_exec() with array args (never shell=True) per HOST-07

   async def start_service(self, service_name: str) -> dict[str, Any]:
     - Validate service_name with whitelist (call validate_service_name then is_allowed)
     - Raise ValueError if not allowed
     - Execute: asyncio.create_subprocess_exec('systemctl', 'start', service_name, stdout=PIPE, stderr=PIPE)
     - After start, verify with _check_service_active(service_name)
     - Return: {service_name, command: 'start', returncode, active: bool, success: bool, stdout, stderr}

   async def stop_service(self, service_name: str) -> dict[str, Any]:
     - Same validation pattern
     - Execute: asyncio.create_subprocess_exec('systemctl', 'stop', service_name, ...)
     - Verify service stopped with _check_service_active (should be False)
     - Return: {service_name, command: 'stop', returncode, active: bool, success: bool, stdout, stderr}

   async def restart_service(self, service_name: str) -> dict[str, Any]:
     - Same validation pattern
     - Execute: asyncio.create_subprocess_exec('systemctl', 'restart', service_name, ...)
     - Verify with _check_service_active (should be True after restart)
     - Return: {service_name, command: 'restart', returncode, active: bool, success: bool, stdout, stderr}

   async def _check_service_active(self, service_name: str) -> bool:
     - Execute: asyncio.create_subprocess_exec('systemctl', 'is-active', service_name, ...)
     - Return stdout.strip() == 'active'

2. Update `__init__.py` to export HostActionExecutor

Per HOST-01, HOST-02, HOST-03: Service control methods
Per HOST-07: All subprocess calls use create_subprocess_exec with array args

Note: These will work on Linux with systemd. On macOS (development), commands will fail gracefully with appropriate error messages - this is expected. Tests will mock subprocess calls.
  </action>
  <verify>
Run: `cd /Users/jrtipton/x/operator && python -c "from operator_core.host.actions import HostActionExecutor; import asyncio; e = HostActionExecutor(); print('HostActionExecutor created with methods:', [m for m in dir(e) if not m.startswith('_')])"`
Expected: Shows start_service, stop_service, restart_service methods
  </verify>
  <done>HostActionExecutor has async service control methods using asyncio.create_subprocess_exec</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for service actions</name>
  <files>packages/operator-core/tests/test_host_actions.py</files>
  <action>
Create comprehensive unit tests for host actions:

1. TestServiceWhitelist class:
   - test_default_whitelist_allows_common_services() - nginx, redis-server, postgresql in whitelist
   - test_forbidden_services_always_blocked() - systemd, ssh, dbus blocked even if in whitelist
   - test_custom_whitelist() - Pass custom whitelist, verify only those services allowed
   - test_add_service_to_whitelist() - Runtime addition works
   - test_add_forbidden_service_raises() - Cannot add systemd, ssh etc.
   - test_path_traversal_blocked() - '../etc/passwd', 'nginx/../../ssh' raise ValueError

2. TestHostActionExecutor class (use unittest.mock.patch for subprocess):
   - test_start_service_success() - Mock successful systemctl start + is-active returning 'active'
   - test_start_service_not_in_whitelist() - Service not whitelisted raises ValueError
   - test_start_service_forbidden() - Forbidden service (systemd) raises ValueError
   - test_stop_service_success() - Mock successful stop
   - test_restart_service_success() - Mock successful restart
   - test_uses_create_subprocess_exec() - Verify asyncio.create_subprocess_exec called (not subprocess.run with shell=True)
   - test_command_injection_prevented() - Service name "nginx; rm -rf /" goes through as literal (no shell parsing)

Use @pytest.mark.asyncio for async tests.
Mock asyncio.create_subprocess_exec to return mock process objects with appropriate stdout/stderr.

Follow existing test patterns in packages/operator-core/tests/test_docker_actions.py.
  </action>
  <verify>
Run: `cd /Users/jrtipton/x/operator/packages/operator-core && python -m pytest tests/test_host_actions.py -v`
Expected: All tests pass
  </verify>
  <done>Unit tests verify service whitelist validation and executor methods use correct patterns</done>
</task>

</tasks>

<verification>
1. ServiceWhitelist correctly allows whitelisted services and blocks forbidden services
2. HostActionExecutor methods use asyncio.create_subprocess_exec (never shell=True)
3. Path traversal attempts are blocked
4. All unit tests pass
5. Imports work: `from operator_core.host import HostActionExecutor, ServiceWhitelist`
</verification>

<success_criteria>
- HOST-01: start_service method implemented with subprocess exec
- HOST-02: stop_service method implemented with subprocess exec
- HOST-03: restart_service method implemented with subprocess exec
- HOST-06 (partial): Service name whitelist validation working
- HOST-07: All methods use asyncio.create_subprocess_exec (verified by tests)
</success_criteria>

<output>
After completion, create `.planning/phases/25-host-actions/25-01-SUMMARY.md`
</output>
