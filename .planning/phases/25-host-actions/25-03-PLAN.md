---
phase: 25-host-actions
plan: 03
type: execute
wave: 2
depends_on: ["25-01", "25-02"]
files_modified:
  - packages/operator-core/src/operator_core/host/actions.py
  - packages/operator-core/src/operator_core/host/__init__.py
  - packages/operator-core/src/operator_core/actions/tools.py
  - packages/operator-core/tests/test_host_actions.py
autonomous: true

must_haves:
  truths:
    - "Host actions discoverable via get_general_tools()"
    - "All 4 host actions have ActionType.TOOL"
    - "Host actions callable via TOOL_EXECUTORS map"
    - "Risk levels correctly assigned (MEDIUM for service ops, HIGH for kill_process)"
    - "All host actions require approval"
  artifacts:
    - path: "packages/operator-core/src/operator_core/host/actions.py"
      provides: "get_host_tools() returning 4 ActionDefinitions"
      exports: ["get_host_tools", "HostActionExecutor"]
    - path: "packages/operator-core/src/operator_core/actions/tools.py"
      provides: "Host tools integrated into get_general_tools() and TOOL_EXECUTORS"
      contains: "host_service_start"
    - path: "packages/operator-core/tests/test_host_actions.py"
      provides: "Integration tests for tool registration"
      min_lines: 200
  key_links:
    - from: "actions/tools.py"
      to: "host/actions.py"
      via: "lazy import get_host_tools"
      pattern: "from operator_core\\.host\\.actions import get_host_tools"
    - from: "actions/tools.py"
      to: "HostActionExecutor"
      via: "lazy executor initialization"
      pattern: "_get_host_executor"
---

<objective>
Register host actions as ActionType.TOOL in the action framework for agent discovery and execution.

Purpose: Make host actions available to the agent through the standard tool interface, following the Phase 24 Docker action pattern.

Output: get_host_tools() function, integration in get_general_tools(), TOOL_EXECUTORS mapping, and integration tests.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/25-host-actions/25-RESEARCH.md

# Prior plan summaries
@.planning/phases/25-host-actions/25-01-SUMMARY.md
@.planning/phases/25-host-actions/25-02-SUMMARY.md

# Phase 24 pattern to follow exactly
@.planning/phases/24-docker-actions/24-03-SUMMARY.md
@packages/operator-core/src/operator_core/docker/actions.py
@packages/operator-core/src/operator_core/actions/tools.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create get_host_tools() function</name>
  <files>packages/operator-core/src/operator_core/host/actions.py, packages/operator-core/src/operator_core/host/__init__.py</files>
  <action>
Add get_host_tools() function to actions.py, following get_docker_tools() pattern exactly:

def get_host_tools() -> list[ActionDefinition]:
    """
    Get host action tool definitions.

    Returns list of ActionDefinition for systemd and process operations.
    All host actions register as ActionType.TOOL for agent discovery.
    """
    from operator_core.actions.registry import ActionDefinition, ParamDef
    from operator_core.actions.types import ActionType

    return [
        ActionDefinition(
            name="host_service_start",
            description="Start a systemd service (requires whitelist authorization)",
            parameters={
                "service_name": ParamDef(
                    type="str",
                    description="Service name (e.g., 'nginx', 'redis-server'). Must be in whitelist.",
                    required=True,
                ),
            },
            action_type=ActionType.TOOL,
            risk_level="medium",  # State change but recoverable
            requires_approval=True,
        ),
        ActionDefinition(
            name="host_service_stop",
            description="Stop a systemd service gracefully",
            parameters={
                "service_name": ParamDef(
                    type="str",
                    description="Service name to stop. Must be in whitelist.",
                    required=True,
                ),
            },
            action_type=ActionType.TOOL,
            risk_level="high",  # Availability impact
            requires_approval=True,
        ),
        ActionDefinition(
            name="host_service_restart",
            description="Restart a systemd service (stop then start)",
            parameters={
                "service_name": ParamDef(
                    type="str",
                    description="Service name to restart. Must be in whitelist.",
                    required=True,
                ),
            },
            action_type=ActionType.TOOL,
            risk_level="medium",  # Temporary disruption but recoverable
            requires_approval=True,
        ),
        ActionDefinition(
            name="host_kill_process",
            description="Send signal to process (SIGTERM for graceful, escalates to SIGKILL after 5s if needed)",
            parameters={
                "pid": ParamDef(
                    type="int",
                    description="Process ID to signal (must be >= 300, not kernel thread)",
                    required=True,
                ),
                "signal": ParamDef(
                    type="str",
                    description="Signal type: 'SIGTERM' (default, graceful) or 'SIGKILL' (force)",
                    required=False,
                ),
                "graceful_timeout": ParamDef(
                    type="int",
                    description="Seconds to wait before SIGKILL escalation (default: 5)",
                    required=False,
                ),
            },
            action_type=ActionType.TOOL,
            risk_level="high",  # Process termination impacts availability
            requires_approval=True,
        ),
    ]

Update __init__.py to export get_host_tools.

Risk level assignments per research:
- MEDIUM: service start/restart (state changes, recoverable)
- HIGH: service stop, kill_process (availability impact)
  </action>
  <verify>
Run: `cd /Users/jrtipton/x/operator && python -c "from operator_core.host.actions import get_host_tools; tools = get_host_tools(); print('Host tools:', [t.name for t in tools]); print('All ActionType.TOOL:', all(str(t.action_type) == 'ActionType.TOOL' for t in tools))"`
Expected: Shows 4 host tools, all ActionType.TOOL
  </verify>
  <done>get_host_tools() returns 4 ActionDefinitions with correct risk levels and ActionType.TOOL</done>
</task>

<task type="auto">
  <name>Task 2: Integrate host tools into tools.py</name>
  <files>packages/operator-core/src/operator_core/actions/tools.py</files>
  <action>
Update tools.py to include host actions, following Docker pattern:

1. Update get_general_tools() to include host tools:

def get_general_tools() -> list[ActionDefinition]:
    """
    Get list of general-purpose tool definitions including Docker and Host actions.
    """
    from operator_core.docker.actions import get_docker_tools
    from operator_core.host.actions import get_host_tools

    base_tools = [
        # existing wait, log_message...
    ]

    docker_tools = get_docker_tools()
    host_tools = get_host_tools()

    return base_tools + docker_tools + host_tools

2. Add lazy host executor initialization (after existing _docker_executor):

_host_executor = None

def _get_host_executor():
    """Get or create the shared Host executor instance."""
    from operator_core.host.actions import HostActionExecutor

    global _host_executor
    if _host_executor is None:
        _host_executor = HostActionExecutor()
    return _host_executor

3. Add host tools to TOOL_EXECUTORS map:

TOOL_EXECUTORS = {
    # Existing tools
    "wait": execute_wait,
    "log_message": execute_log_message,
    # Docker tools (existing)
    "docker_start_container": lambda **kw: _get_docker_executor().start_container(**kw),
    # ... other docker tools ...
    # Host tools (new)
    "host_service_start": lambda **kw: _get_host_executor().start_service(**kw),
    "host_service_stop": lambda **kw: _get_host_executor().stop_service(**kw),
    "host_service_restart": lambda **kw: _get_host_executor().restart_service(**kw),
    "host_kill_process": lambda **kw: _get_host_executor().kill_process(**kw),
}

Note: Lambda wrappers enable lazy initialization and map tool names to executor method names (e.g., host_service_start -> start_service).
  </action>
  <verify>
Run: `cd /Users/jrtipton/x/operator && python -c "from operator_core.actions.tools import get_general_tools, TOOL_EXECUTORS; tools = get_general_tools(); print('Total tools:', len(tools)); print('Host tools in EXECUTORS:', [k for k in TOOL_EXECUTORS.keys() if k.startswith('host_')])"`
Expected: Total tools: 14 (2 base + 8 docker + 4 host), Host tools: host_service_start, host_service_stop, host_service_restart, host_kill_process
  </verify>
  <done>Host tools integrated into get_general_tools() and TOOL_EXECUTORS with lazy executor initialization</done>
</task>

<task type="auto">
  <name>Task 3: Add integration tests for tool registration</name>
  <files>packages/operator-core/tests/test_host_actions.py</files>
  <action>
Add integration tests following Phase 24 pattern (TestDockerActionIntegration):

class TestHostActionIntegration:
    """Integration tests for host action tool registration."""

    def test_host_tools_in_general_tools(self):
        """Host tools included in get_general_tools()."""
        from operator_core.actions.tools import get_general_tools
        tools = get_general_tools()
        tool_names = [t.name for t in tools]

        assert "host_service_start" in tool_names
        assert "host_service_stop" in tool_names
        assert "host_service_restart" in tool_names
        assert "host_kill_process" in tool_names

    def test_host_tools_have_action_type_tool(self):
        """All host tools have ActionType.TOOL."""
        from operator_core.host.actions import get_host_tools
        from operator_core.actions.types import ActionType

        for tool in get_host_tools():
            assert tool.action_type == ActionType.TOOL

    def test_host_tools_in_executors(self):
        """All host tools have executors registered."""
        from operator_core.actions.tools import TOOL_EXECUTORS

        assert "host_service_start" in TOOL_EXECUTORS
        assert "host_service_stop" in TOOL_EXECUTORS
        assert "host_service_restart" in TOOL_EXECUTORS
        assert "host_kill_process" in TOOL_EXECUTORS

    def test_host_tool_risk_levels(self):
        """Host tools have correct risk levels."""
        from operator_core.host.actions import get_host_tools

        tools = {t.name: t for t in get_host_tools()}

        # Service ops: start and restart are medium (recoverable)
        assert tools["host_service_start"].risk_level == "medium"
        assert tools["host_service_restart"].risk_level == "medium"

        # High risk: stop service and kill process (availability impact)
        assert tools["host_service_stop"].risk_level == "high"
        assert tools["host_kill_process"].risk_level == "high"

    def test_host_tools_require_approval(self):
        """All host tools require approval."""
        from operator_core.host.actions import get_host_tools

        for tool in get_host_tools():
            assert tool.requires_approval is True

    def test_execute_tool_dispatches_to_host_executor(self):
        """execute_tool routes host actions to HostActionExecutor."""
        from operator_core.actions.tools import execute_tool
        import pytest

        # Calling with invalid service should raise ValueError (from whitelist)
        with pytest.raises(ValueError, match="not in whitelist"):
            import asyncio
            asyncio.get_event_loop().run_until_complete(
                execute_tool("host_service_start", {"service_name": "nonexistent_service"})
            )

    def test_lazy_host_executor_initialization(self):
        """Host executor is lazily initialized to avoid circular imports."""
        from operator_core.actions.tools import _get_host_executor

        executor = _get_host_executor()
        assert executor is not None

        # Second call returns same instance
        executor2 = _get_host_executor()
        assert executor is executor2

Run all tests to verify full integration.
  </action>
  <verify>
Run: `cd /Users/jrtipton/x/operator/packages/operator-core && python -m pytest tests/test_host_actions.py -v`
Expected: All tests pass including integration tests
  </verify>
  <done>Integration tests verify host actions registered correctly as ActionType.TOOL with proper risk levels</done>
</task>

</tasks>

<verification>
1. get_host_tools() returns 4 ActionDefinitions with ActionType.TOOL
2. get_general_tools() includes all 4 host tools (14 total tools now)
3. TOOL_EXECUTORS maps all 4 host actions to executor methods
4. Risk levels: medium for start/restart, high for stop/kill_process
5. All host actions require approval
6. All tests pass
</verification>

<success_criteria>
- All 4 host actions registered as ActionType.TOOL
- Host tools discoverable via get_general_tools()
- Host tools executable via execute_tool()
- Integration tests verify framework integration
- Phase 25 complete with all HOST-* requirements covered
</success_criteria>

<output>
After completion, create `.planning/phases/25-host-actions/25-03-SUMMARY.md`
</output>
