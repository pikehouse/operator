---
phase: 25-host-actions
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/operator-core/src/operator_core/host/actions.py
  - packages/operator-core/src/operator_core/host/validation.py
  - packages/operator-core/tests/test_host_actions.py
autonomous: true

must_haves:
  truths:
    - "kill_process method sends SIGTERM to valid PIDs"
    - "Graceful shutdown waits 5s after SIGTERM before escalating to SIGKILL"
    - "PID 1 (init) cannot be signaled"
    - "Kernel threads (PID < 300) cannot be signaled"
    - "Process existence verified with signal 0 before sending actual signal"
  artifacts:
    - path: "packages/operator-core/src/operator_core/host/actions.py"
      provides: "kill_process method with graceful escalation"
      contains: "os.kill"
    - path: "packages/operator-core/src/operator_core/host/validation.py"
      provides: "validate_pid function"
      exports: ["validate_pid"]
    - path: "packages/operator-core/tests/test_host_actions.py"
      provides: "Process kill tests including escalation"
      min_lines: 150
  key_links:
    - from: "host/actions.py"
      to: "os.kill"
      via: "signal sending"
      pattern: "os\\.kill\\(pid"
    - from: "host/actions.py"
      to: "signal module"
      via: "signal constants"
      pattern: "signal\\.SIGTERM|signal\\.SIGKILL"
---

<objective>
Add process kill capability to HostActionExecutor with graceful SIGTERM -> SIGKILL escalation pattern and PID validation.

Purpose: Enable agent to terminate runaway or stuck processes safely, with protection against signaling init process or kernel threads.

Output: kill_process method with 5-second graceful timeout, validate_pid function, and comprehensive unit tests.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/25-host-actions/25-RESEARCH.md

# If Plan 01 SUMMARY exists when this runs
@.planning/phases/25-host-actions/25-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add validate_pid function to validation module</name>
  <files>packages/operator-core/src/operator_core/host/validation.py, packages/operator-core/src/operator_core/host/__init__.py</files>
  <action>
Add PID validation to validation.py:

def validate_pid(pid: int) -> None:
    """
    Validate PID for signaling operations.

    Args:
        pid: Process ID to validate

    Raises:
        ValueError: If PID invalid (<=1, kernel thread)
        ProcessLookupError: If process doesn't exist
        PermissionError: If insufficient privileges to signal

    Note:
        Per HOST-06: PID > 1 check prevents signaling init.
        Additional kernel thread check (PID < 300) prevents system instability.
    """
    if not isinstance(pid, int):
        raise ValueError(f"PID must be integer, got {type(pid).__name__}")

    # Prevent signaling init (PID 1) or invalid PIDs
    if pid <= 1:
        raise ValueError(
            f"Cannot signal PID {pid}: PID 1 is init process, PID 0/negative invalid"
        )

    # Prevent signaling kernel threads (conservative threshold)
    # Kernel threads typically have low PIDs (< 300 on most systems)
    if pid < 300:
        raise ValueError(
            f"Cannot signal PID {pid}: likely kernel thread. "
            "Only user processes (PID >= 300) can be signaled."
        )

    # Validate PID exists and we have permission (signal 0 = null signal)
    import os
    os.kill(pid, 0)  # Raises ProcessLookupError or PermissionError

Update __init__.py to export validate_pid.

Per HOST-06: PID validation prevents operations on PID 1 and kernel threads.
  </action>
  <verify>
Run: `cd /Users/jrtipton/x/operator && python -c "from operator_core.host.validation import validate_pid; validate_pid(1)" 2>&1 | grep -q "init process" && echo "PID 1 blocked correctly"`
Expected: "PID 1 blocked correctly"
  </verify>
  <done>validate_pid blocks PID 1, kernel threads (< 300), and validates process existence</done>
</task>

<task type="auto">
  <name>Task 2: Add kill_process method to HostActionExecutor</name>
  <files>packages/operator-core/src/operator_core/host/actions.py</files>
  <action>
Add kill_process method to HostActionExecutor class:

async def kill_process(
    self,
    pid: int,
    signal_type: str = 'SIGTERM',
    graceful_timeout: int = 5,
) -> dict[str, Any]:
    """
    Send signal to process with graceful escalation.

    Args:
        pid: Process ID to signal (must be > 1, not kernel thread)
        signal_type: 'SIGTERM' (graceful) or 'SIGKILL' (force). Default: SIGTERM
        graceful_timeout: Seconds to wait before SIGKILL escalation (default: 5)

    Returns:
        Dict with pid, signal, escalated, still_running, success

    Raises:
        ValueError: If PID invalid (<=1, kernel thread)
        ProcessLookupError: If process doesn't exist
        PermissionError: If insufficient privileges

    Note:
        Per HOST-05: SIGTERM -> wait graceful_timeout -> SIGKILL if still running.
        Per HOST-06: Validates PID > 1 and not kernel thread.
    """
    from operator_core.host.validation import validate_pid
    import os
    import signal

    # Validate PID (HOST-06)
    validate_pid(pid)

    # Map signal string to constant
    sig = signal.SIGTERM if signal_type == 'SIGTERM' else signal.SIGKILL
    escalated = False

    # Send initial signal
    os.kill(pid, sig)

    # Graceful escalation pattern (HOST-05)
    if signal_type == 'SIGTERM' and graceful_timeout > 0:
        # Wait for process to exit gracefully, checking every 100ms
        for _ in range(graceful_timeout * 10):
            await asyncio.sleep(0.1)

            try:
                os.kill(pid, 0)  # Check if still exists
            except ProcessLookupError:
                # Process exited gracefully
                break
        else:
            # Timeout expired, process still running, escalate to SIGKILL
            try:
                os.kill(pid, signal.SIGKILL)
                escalated = True
                await asyncio.sleep(0.5)  # Brief wait for SIGKILL to take effect
            except ProcessLookupError:
                pass  # Exited just before escalation

    # Check final state
    try:
        os.kill(pid, 0)
        still_running = True
    except ProcessLookupError:
        still_running = False

    return {
        "pid": pid,
        "signal": signal_type,
        "escalated": escalated,
        "still_running": still_running,
        "success": not still_running,
    }

Note: This method uses os.kill() which is synchronous but fast (just sends signal). The waiting is done with asyncio.sleep() to avoid blocking.

Per HOST-04: kill_process sends SIGTERM or SIGKILL
Per HOST-05: Graceful pattern with 5s default timeout
  </action>
  <verify>
Run: `cd /Users/jrtipton/x/operator && python -c "from operator_core.host.actions import HostActionExecutor; import asyncio; e = HostActionExecutor(); print('kill_process method exists:', hasattr(e, 'kill_process'))"`
Expected: kill_process method exists: True
  </verify>
  <done>kill_process method implements graceful SIGTERM -> SIGKILL escalation with PID validation</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for process kill functionality</name>
  <files>packages/operator-core/tests/test_host_actions.py</files>
  <action>
Add tests for process kill to existing test file:

1. TestPidValidation class:
   - test_pid_1_rejected() - PID 1 raises ValueError with "init process"
   - test_pid_0_rejected() - PID 0 raises ValueError
   - test_negative_pid_rejected() - Negative PIDs raise ValueError
   - test_kernel_thread_pid_rejected() - PIDs < 300 raise ValueError with "kernel thread"
   - test_valid_pid_accepted() - Mock os.kill(pid, 0) success for PID >= 300
   - test_nonexistent_pid_raises() - ProcessLookupError when pid doesn't exist
   - test_permission_denied_raises() - PermissionError when no permission

2. TestHostKillProcess class (use unittest.mock.patch for os.kill):
   - test_kill_sends_sigterm_by_default() - os.kill called with signal.SIGTERM
   - test_kill_sends_sigkill_when_specified() - signal_type='SIGKILL' works
   - test_graceful_escalation() - If process doesn't die after SIGTERM, SIGKILL sent after timeout
     - Mock os.kill(pid, 0) to succeed (still running) for first 5 seconds
     - Then mock ProcessLookupError (exited after SIGKILL)
     - Verify escalated=True in result
   - test_graceful_exit_no_escalation() - Process dies before timeout
     - Mock os.kill(pid, 0) to raise ProcessLookupError after first check
     - Verify escalated=False in result
   - test_pid_validation_integrated() - PID 1 raises ValueError (integration with validate_pid)
   - test_return_structure() - Result has all expected fields (pid, signal, escalated, still_running, success)
   - test_custom_graceful_timeout() - graceful_timeout parameter respected

Use @pytest.mark.asyncio for async tests.
Use asyncio.sleep patching to speed up timeout tests (mock to return immediately).

Key: Mock asyncio.sleep as well as os.kill to make tests fast (don't wait real 5 seconds).
  </action>
  <verify>
Run: `cd /Users/jrtipton/x/operator/packages/operator-core && python -m pytest tests/test_host_actions.py -v -k "kill or pid"`
Expected: All process kill and PID validation tests pass
  </verify>
  <done>Comprehensive tests verify PID validation and graceful escalation pattern</done>
</task>

</tasks>

<verification>
1. validate_pid blocks PID 1 and kernel threads (< 300)
2. kill_process sends SIGTERM by default, SIGKILL on request
3. Graceful escalation waits 5s (configurable) before SIGKILL
4. Process existence checked with signal 0 before and after
5. All unit tests pass with mocked os.kill calls
</verification>

<success_criteria>
- HOST-04: host_kill_process sends SIGTERM or SIGKILL to processes
- HOST-05: Graceful pattern SIGTERM -> 5s wait -> SIGKILL implemented
- HOST-06 (complete): PID > 1 validation + kernel thread protection
</success_criteria>

<output>
After completion, create `.planning/phases/25-host-actions/25-02-SUMMARY.md`
</output>
