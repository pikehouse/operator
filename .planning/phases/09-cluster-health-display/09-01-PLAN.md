---
phase: 09-cluster-health-display
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/operator-core/src/operator_core/tui/health.py
  - packages/operator-core/src/operator_core/tui/__init__.py
autonomous: true

must_haves:
  truths:
    - "ClusterHealthPoller can fetch TiKV store health from PD API"
    - "ClusterHealthPoller can fetch PD member health from PD API"
    - "Health data formatted with color-coded Rich markup"
  artifacts:
    - path: "packages/operator-core/src/operator_core/tui/health.py"
      provides: "ClusterHealthPoller, NodeHealth, NodeStatus, ClusterHealth, formatting functions"
      min_lines: 150
      exports: ["ClusterHealthPoller", "NodeHealth", "NodeStatus", "ClusterHealth", "format_cluster_panel", "parse_monitor_output_for_detection"]
  key_links:
    - from: "packages/operator-core/src/operator_core/tui/health.py"
      to: "httpx.AsyncClient"
      via: "PD API calls in fetch_cluster_health"
      pattern: "client\\.get.*pd/api"
---

<objective>
Create the ClusterHealthPoller class and health data types for fetching and formatting cluster node status.

Purpose: Enable the TUI to display live health status of all 6 cluster nodes (3 TiKV stores, 3 PD members) with color-coded indicators.

Output: health.py module with ClusterHealthPoller, data types, and Rich formatting functions.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-cluster-health-display/09-RESEARCH.md

# Reference existing TUI patterns
@packages/operator-core/src/operator_core/tui/subprocess.py
@packages/operator-core/src/operator_core/tui/buffer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create health data types and formatting functions</name>
  <files>packages/operator-core/src/operator_core/tui/health.py</files>
  <action>
Create health.py with the following components:

1. **NodeHealth enum:**
   - UP = "up"
   - DOWN = "down"
   - OFFLINE = "offline"
   - UNKNOWN = "unknown"

2. **NodeStatus dataclass:**
   - node_id: str
   - name: str (display name like "tikv-1", "pd-1")
   - node_type: str ("tikv" or "pd")
   - health: NodeHealth
   - address: str

3. **ClusterHealth dataclass:**
   - nodes: list[NodeStatus]
   - has_issues: bool (computed: any node not UP)
   - last_updated: datetime

4. **format_node_status(node: NodeStatus) -> str:**
   - Returns Rich markup string with color-coded indicator
   - Green bullet (\u25cf) + "Up" for UP
   - Red cross (\u2717) + "Down" for DOWN
   - Yellow cross + "Offline" for OFFLINE
   - Dim "?" + "Unknown" for UNKNOWN
   - Format: "{indicator} {name}: {status}"

5. **format_cluster_panel(health: ClusterHealth) -> str:**
   - Returns full panel content with sections for TiKV and PD
   - Groups nodes by type
   - Uses format_node_status() for each node
   - Header: "[bold]Cluster Status[/bold]"

6. **_parse_tikv_state(state: str) -> NodeHealth:**
   - Helper to map TiKV state_name to NodeHealth
   - "Up" -> UP, "Down" -> DOWN, "Offline" -> OFFLINE, "Tombstone" -> OFFLINE, else UNKNOWN

7. **parse_monitor_output_for_detection(line: str) -> bool | None:**
   - Parse monitor heartbeat output for detection state
   - "all passing" in line -> return False
   - "violations" in line -> return True
   - Otherwise -> return None

Per RESEARCH.md Pattern 3 for Rich markup, Pattern 6 for monitor output parsing.
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator && python -c "
from operator_core.tui.health import (
    NodeHealth, NodeStatus, ClusterHealth,
    format_node_status, format_cluster_panel,
    parse_monitor_output_for_detection
)
from datetime import datetime

# Test data types
node = NodeStatus('1', 'tikv-1', 'tikv', NodeHealth.UP, 'tikv-1:20160')
health = ClusterHealth([node], has_issues=False, last_updated=datetime.now())
print('Data types OK')

# Test formatting
line = format_node_status(node)
assert '\u25cf' in line or 'green' in line.lower(), f'Missing green indicator: {line}'
print(f'Format OK: {line}')

# Test detection parsing
assert parse_monitor_output_for_detection('Check complete: 3 invariants, all passing') == False
assert parse_monitor_output_for_detection('Check complete: 3 invariants, 1 violations') == True
assert parse_monitor_output_for_detection('Some other line') is None
print('Detection parsing OK')

print('All checks passed!')
"
```
  </verify>
  <done>Data types created, formatting produces Rich markup with green/red indicators, detection parsing works</done>
</task>

<task type="auto">
  <name>Task 2: Create ClusterHealthPoller class</name>
  <files>packages/operator-core/src/operator_core/tui/health.py</files>
  <action>
Add ClusterHealthPoller class to health.py:

**ClusterHealthPoller class:**

```python
class ClusterHealthPoller:
    """
    Polls PD API for cluster health status.

    Runs as async task, fetches health at configurable interval,
    stores latest snapshot for TUI rendering.

    Per RESEARCH.md Pattern 5: Async Health Polling with Event Coordination.
    """

    def __init__(
        self,
        pd_endpoint: str = "http://localhost:2379",
        poll_interval: float = 2.0,
    ) -> None:
        self._pd_endpoint = pd_endpoint
        self._poll_interval = poll_interval
        self._shutdown = asyncio.Event()
        self._health: ClusterHealth | None = None
        self._detection_active = False

    async def run(self) -> None:
        """Poll loop that runs until shutdown."""
        # Per RESEARCH.md: Use httpx.AsyncClient with timeout
        async with httpx.AsyncClient(
            base_url=self._pd_endpoint,
            timeout=5.0,
        ) as client:
            while not self._shutdown.is_set():
                try:
                    self._health = await self._fetch_health(client)
                except Exception:
                    # On failure, mark all nodes unknown
                    # Per RESEARCH.md Pitfall 2: Don't crash on API failure
                    pass

                try:
                    await asyncio.wait_for(
                        self._shutdown.wait(),
                        timeout=self._poll_interval,
                    )
                except asyncio.TimeoutError:
                    continue

    async def _fetch_health(self, client: httpx.AsyncClient) -> ClusterHealth:
        """Fetch health from PD API endpoints."""
        nodes: list[NodeStatus] = []

        # 1. Get TiKV store health: /pd/api/v1/stores
        stores_resp = await client.get("/pd/api/v1/stores")
        stores_resp.raise_for_status()
        stores_data = stores_resp.json()

        for item in stores_data.get("stores", []):
            store = item.get("store", {})
            state = store.get("state_name", "Unknown")
            store_id = store.get("id", 0)
            nodes.append(NodeStatus(
                node_id=str(store_id),
                name=f"tikv-{store_id}",
                node_type="tikv",
                health=_parse_tikv_state(state),
                address=store.get("address", ""),
            ))

        # 2. Get PD member health: /pd/api/v1/health
        health_resp = await client.get("/pd/api/v1/health")
        health_resp.raise_for_status()
        health_data = health_resp.json()

        for member in health_data:
            nodes.append(NodeStatus(
                node_id=str(member.get("member_id", "")),
                name=member.get("name", "pd-?"),
                node_type="pd",
                health=NodeHealth.UP if member.get("health") else NodeHealth.DOWN,
                address=",".join(member.get("client_urls", [])),
            ))

        return ClusterHealth(
            nodes=nodes,
            has_issues=any(n.health != NodeHealth.UP for n in nodes),
            last_updated=datetime.now(),
        )

    def get_health(self) -> ClusterHealth | None:
        """Get latest health snapshot (thread-safe read)."""
        return self._health

    def set_detection_active(self, active: bool) -> None:
        """Set detection highlighting state."""
        self._detection_active = active

    def is_detection_active(self) -> bool:
        return self._detection_active

    def stop(self) -> None:
        self._shutdown.set()
```

Add necessary imports at top of file: asyncio, httpx, datetime.
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator && python -c "
from operator_core.tui.health import ClusterHealthPoller

# Test instantiation
poller = ClusterHealthPoller(pd_endpoint='http://localhost:2379', poll_interval=2.0)
print('ClusterHealthPoller instantiated')

# Test state methods
assert poller.get_health() is None, 'Initial health should be None'
poller.set_detection_active(True)
assert poller.is_detection_active() == True, 'Detection should be True'
poller.set_detection_active(False)
assert poller.is_detection_active() == False, 'Detection should be False'
print('State methods OK')

# Test stop
poller.stop()
print('Stop method OK')

print('All ClusterHealthPoller checks passed!')
"
```
  </verify>
  <done>ClusterHealthPoller created with async run(), health fetching, and state management</done>
</task>

<task type="auto">
  <name>Task 3: Export health module components</name>
  <files>packages/operator-core/src/operator_core/tui/__init__.py</files>
  <action>
Update the TUI __init__.py to export health module components:

Add imports:
```python
from operator_core.tui.health import (
    ClusterHealthPoller,
    NodeHealth,
    NodeStatus,
    ClusterHealth,
    format_cluster_panel,
    parse_monitor_output_for_detection,
)
```

Add to __all__ (if exists) or ensure public exports.

This allows:
```python
from operator_core.tui import ClusterHealthPoller, format_cluster_panel
```
  </action>
  <verify>
```bash
cd /Users/jrtipton/x/operator && python -c "
from operator_core.tui import (
    ClusterHealthPoller,
    NodeHealth,
    NodeStatus,
    ClusterHealth,
    format_cluster_panel,
    parse_monitor_output_for_detection,
)
print('All health components exported from operator_core.tui')
"
```
  </verify>
  <done>Health module components exported from operator_core.tui package</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Import test:**
```bash
cd /Users/jrtipton/x/operator && python -c "
from operator_core.tui import ClusterHealthPoller, format_cluster_panel
print('Import OK')
"
```

2. **Type check (if mypy available):**
```bash
cd /Users/jrtipton/x/operator && python -m mypy packages/operator-core/src/operator_core/tui/health.py --ignore-missing-imports 2>/dev/null || echo 'mypy not configured, skipping'
```

3. **Documentation strings present:**
```bash
cd /Users/jrtipton/x/operator && python -c "
from operator_core.tui.health import ClusterHealthPoller
assert ClusterHealthPoller.__doc__, 'Missing docstring'
print('Docstrings present')
"
```
</verification>

<success_criteria>
- health.py exists with all data types and ClusterHealthPoller
- NodeHealth enum has UP, DOWN, OFFLINE, UNKNOWN values
- format_node_status returns Rich markup with color codes
- ClusterHealthPoller has run(), get_health(), set_detection_active(), stop() methods
- All components exported from operator_core.tui
- Code follows existing codebase patterns (docstrings, type hints)
</success_criteria>

<output>
After completion, create `.planning/phases/09-cluster-health-display/09-01-SUMMARY.md`
</output>
