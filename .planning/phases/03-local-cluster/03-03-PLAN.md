---
phase: 03-local-cluster
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - subjects/tikv/Dockerfile.ycsb
  - subjects/tikv/docker-compose.yaml
  - subjects/tikv/workloads/workloada.properties
autonomous: true

must_haves:
  truths:
    - "go-ycsb container builds successfully"
    - "Load generator can connect to TiKV cluster via PD endpoints"
    - "Load generator produces measurable traffic (ops/sec visible)"
  artifacts:
    - path: "subjects/tikv/Dockerfile.ycsb"
      provides: "Custom go-ycsb Docker image build"
      contains: "go-ycsb"
    - path: "subjects/tikv/workloads/workloada.properties"
      provides: "YCSB workload configuration"
      contains: "recordcount"
  key_links:
    - from: "ycsb service"
      to: "pd0:2379,pd1:2379,pd2:2379"
      via: "tikv.pd parameter"
      pattern: "tikv.pd.*pd"
---

<objective>
Add a go-ycsb load generator to produce traffic against the TiKV cluster.

Purpose: ENV-03 requires containerized load generation for testing the operator under realistic workload conditions.

Output: A custom go-ycsb Docker image and service that generates configurable traffic patterns.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-local-cluster/03-RESEARCH.md

# Prior plan output (cluster definition)
@subjects/tikv/docker-compose.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create go-ycsb Dockerfile and workload config</name>
  <files>
subjects/tikv/Dockerfile.ycsb
subjects/tikv/workloads/workloada.properties
  </files>
  <action>
Create the go-ycsb Dockerfile following the pattern from RESEARCH.md:

**subjects/tikv/Dockerfile.ycsb:**
```dockerfile
# Build stage
FROM golang:1.21-alpine AS builder

RUN apk add --no-cache git make

WORKDIR /build
RUN git clone https://github.com/pingcap/go-ycsb.git .
RUN make

# Runtime stage
FROM alpine:latest

COPY --from=builder /build/bin/go-ycsb /usr/local/bin/
COPY --from=builder /build/workloads /workloads

ENTRYPOINT ["go-ycsb"]
```

**subjects/tikv/workloads/workloada.properties:**
```properties
# Workload A: 50% reads, 50% updates
recordcount=10000
operationcount=100000
workload=core

readallfields=true
readproportion=0.5
updateproportion=0.5
scanproportion=0
insertproportion=0

requestdistribution=zipfian
```

This creates a smaller workload suitable for local testing (10k records, 100k operations).
  </action>
  <verify>
ls -la subjects/tikv/Dockerfile.ycsb subjects/tikv/workloads/workloada.properties
# Both files should exist
  </verify>
  <done>Dockerfile.ycsb and workload config file created</done>
</task>

<task type="auto">
  <name>Task 2: Add ycsb service to docker-compose and build image</name>
  <files>subjects/tikv/docker-compose.yaml</files>
  <action>
Add the ycsb service to docker-compose.yaml:

**ycsb service:**
- Build context: `.` with dockerfile: `Dockerfile.ycsb`
- Container name: ycsb
- Volumes:
  - `./workloads:/custom-workloads:ro`
- depends_on: tikv0, tikv1, tikv2 with condition: service_healthy
- No auto-start (profiles: ["load"]) - run on demand
- Command: Default entrypoint, user runs specific load/run commands

The service uses Docker Compose profiles so it doesn't start with `docker compose up` but can be started with `docker compose --profile load up ycsb` or `docker compose run ycsb`.

Build the image to verify it compiles:
```bash
docker compose -f subjects/tikv/docker-compose.yaml build ycsb
```
  </action>
  <verify>
docker compose -f subjects/tikv/docker-compose.yaml config --quiet
docker images | grep -E "tikv.*ycsb|ycsb"
# Image should exist after build
  </verify>
  <done>ycsb service added to docker-compose.yaml and image builds successfully</done>
</task>

<task type="auto">
  <name>Task 3: Verify load generator produces traffic</name>
  <files></files>
  <action>
Start the cluster and run a short load test:

1. Start the cluster: `docker compose -f subjects/tikv/docker-compose.yaml up -d`
2. Wait for TiKV cluster to be healthy (all stores Up)
3. Run the load phase (insert initial data):
```bash
docker compose -f subjects/tikv/docker-compose.yaml run --rm ycsb load tikv \
  -P /workloads/workloada \
  -p tikv.pd="pd0:2379,pd1:2379,pd2:2379" \
  -p tikv.type="raw" \
  -p recordcount=1000 \
  -p threadcount=4
```
4. Run a brief workload (verify operations work):
```bash
docker compose -f subjects/tikv/docker-compose.yaml run --rm ycsb run tikv \
  -P /workloads/workloada \
  -p tikv.pd="pd0:2379,pd1:2379,pd2:2379" \
  -p tikv.type="raw" \
  -p operationcount=1000 \
  -p threadcount=4
```
5. Verify output shows operations/second metrics

After verification, stop the cluster: `docker compose -f subjects/tikv/docker-compose.yaml down`
  </action>
  <verify>
# The run command should output OPS/sec metrics like:
# [READ: Count=500, Max=..., Avg=...]
# If we see ops counted, load generator is working
  </verify>
  <done>Load generator successfully inserts records and runs operations against TiKV cluster</done>
</task>

</tasks>

<verification>
1. Dockerfile.ycsb builds without errors
2. go-ycsb binary executes in container
3. Load phase inserts records to TiKV
4. Run phase executes read/update operations
5. Output shows throughput metrics (ops/sec)
</verification>

<success_criteria>
- Custom go-ycsb Docker image builds from source
- Workload config file defines a testable workload
- Load generator connects to TiKV via PD endpoints
- Measurable traffic produced (ops counted in output)
</success_criteria>

<output>
After completion, create `.planning/phases/03-local-cluster/03-03-SUMMARY.md`
</output>
