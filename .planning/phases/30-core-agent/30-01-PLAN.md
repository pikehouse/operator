---
phase: 30-core-agent
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docker/agent/Dockerfile
  - packages/operator-core/src/operator_core/agent_lab/__init__.py
  - packages/operator-core/src/operator_core/agent_lab/tools.py
  - packages/operator-core/src/operator_core/agent_lab/audit.py
autonomous: true

must_haves:
  truths:
    - "Agent container builds successfully with Docker"
    - "shell() executes commands and returns structured dict with stdout, stderr, exit_code, timed_out"
    - "shell() times out after 120 seconds by default"
    - "SessionAuditor logs tool calls with timestamps and reasoning to JSON"
    - "Audit log files are named with timestamp and UUID component"
  artifacts:
    - path: "docker/agent/Dockerfile"
      provides: "Agent container with Python 3.12, Docker CLI, SRE tools"
      contains: "python:3.12-slim"
    - path: "packages/operator-core/src/operator_core/agent_lab/tools.py"
      provides: "shell() tool implementation"
      exports: ["shell"]
    - path: "packages/operator-core/src/operator_core/agent_lab/audit.py"
      provides: "Session-based audit logging"
      exports: ["SessionAuditor"]
  key_links:
    - from: "agent_lab/tools.py"
      to: "asyncio.create_subprocess_shell"
      via: "async subprocess execution"
      pattern: "asyncio\\.create_subprocess_shell"
    - from: "agent_lab/audit.py"
      to: "JSON file output"
      via: "session save"
      pattern: "json\\.dumps"
---

<objective>
Implement the core agent container with shell tool and session audit logging.

Purpose: Foundation for v3.0 "Operator Laboratory" - giving Claude full shell access with container isolation as the safety boundary, replacing v2.x action abstractions.

Output:
- Agent Dockerfile with SRE tooling (curl, jq, docker CLI, etc.)
- `shell(command, reasoning)` async tool returning structured dict
- `SessionAuditor` class for conversation-level JSON audit logs
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-core-agent/30-CONTEXT.md
@.planning/phases/30-core-agent/30-RESEARCH.md

# Existing patterns to follow
@packages/ratelimiter-service/Dockerfile
@packages/operator-core/src/operator_core/host/actions.py
@packages/operator-core/src/operator_core/actions/audit.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create agent container Dockerfile</name>
  <files>docker/agent/Dockerfile</files>
  <action>
Create `docker/agent/Dockerfile` with:

1. Base image: `python:3.12-slim`

2. Install CLI tools via apt-get (single RUN layer, clean apt cache):
   - HTTP: curl, wget
   - JSON: jq
   - Editing: vim
   - Version control: git
   - Networking: netcat-openbsd, dnsutils (dig), iputils-ping
   - Monitoring: htop
   - Advanced networking: tcpdump, traceroute, nmap
   - Docker CLI: docker.io

3. Install Python packages via pip (single RUN layer, --no-cache-dir):
   - anthropic, httpx (Claude SDK + async HTTP)
   - redis (subject observation)
   - pyyaml (YAML parsing)
   - pandas, numpy (data analysis)
   - prometheus-client (metrics)

4. Set WORKDIR to /app

5. Create /app/audit_logs directory for audit output

Follow the pattern from ratelimiter-service Dockerfile (apt-get with --no-install-recommends, rm apt cache, slim image).

Do NOT add COPY or CMD - those come in Phase 31 when entrypoint is created.
  </action>
  <verify>
Run: `docker build -f docker/agent/Dockerfile -t operator-agent:test docker/agent`
Expect: Build completes successfully with no errors.
  </verify>
  <done>Dockerfile builds successfully, all tools installed.</done>
</task>

<task type="auto">
  <name>Task 2: Implement shell() tool</name>
  <files>
packages/operator-core/src/operator_core/agent_lab/__init__.py
packages/operator-core/src/operator_core/agent_lab/tools.py
  </files>
  <action>
Create `packages/operator-core/src/operator_core/agent_lab/` directory with:

**__init__.py:**
```python
"""Agent Lab: v3.0 autonomous agent with shell access."""
from .tools import shell
from .audit import SessionAuditor

__all__ = ["shell", "SessionAuditor"]
```

**tools.py:**
Implement async `shell(command: str, reasoning: str, timeout: float = 120.0) -> dict` function:

1. Use `asyncio.create_subprocess_shell()` for command execution
2. Capture stdout and stderr with `asyncio.subprocess.PIPE`
3. Use `asyncio.wait_for(proc.communicate(), timeout=timeout)` for timeout handling
4. On timeout: call `proc.kill()` then `await proc.wait()` to prevent zombies
5. Return structured dict per CONTEXT.md:
   ```python
   {
       "stdout": str,      # decoded utf-8, empty string if none
       "stderr": str,      # decoded utf-8, error message if timeout
       "exit_code": int,   # returncode from process, -1 if timeout
       "timed_out": bool,  # True if command exceeded timeout
   }
   ```

Key requirements:
- Do NOT escape or sanitize command - pass directly to create_subprocess_shell
- Do NOT validate command content - "let Claude cook"
- Reasoning parameter is not validated but required for signature
- Handle decode errors gracefully (use errors='replace')

Add docstring explaining the function's purpose and return format.
  </action>
  <verify>
Create a test script and run:
```python
import asyncio
from operator_core.agent_lab import shell

async def test():
    # Test basic command
    r1 = await shell("echo hello", "testing basic echo")
    assert r1["stdout"].strip() == "hello"
    assert r1["exit_code"] == 0
    assert r1["timed_out"] is False

    # Test error command
    r2 = await shell("exit 1", "testing exit code")
    assert r2["exit_code"] == 1

    # Test timeout (use short timeout)
    r3 = await shell("sleep 5", "testing timeout", timeout=1.0)
    assert r3["timed_out"] is True
    assert r3["exit_code"] == -1

    print("All tests passed!")

asyncio.run(test())
```
  </verify>
  <done>shell() function executes commands, handles timeouts, returns structured dict.</done>
</task>

<task type="auto">
  <name>Task 3: Implement SessionAuditor</name>
  <files>packages/operator-core/src/operator_core/agent_lab/audit.py</files>
  <action>
Create `packages/operator-core/src/operator_core/agent_lab/audit.py` with SessionAuditor class:

**SessionAuditor class:**
1. Constructor takes `audit_dir: Path` parameter
2. Generate session ID on init: `{timestamp}-{uuid4[:8]}` format
   - Timestamp: `datetime.now().strftime("%Y-%m-%dT%H-%M-%S")`
   - UUID component: `str(uuid.uuid4())[:8]`
3. Maintain `messages: list` for conversation history

**Methods:**

`log_message(role: str, content: Any) -> None`:
- Append to messages list with timestamp, role, content

`log_tool_call(tool_name: str, parameters: dict, result: dict) -> None`:
- Append to messages list with:
  - timestamp (ISO format)
  - type: "tool_call"
  - tool: tool_name
  - parameters: parameters (includes reasoning)
  - result: result (the structured dict from shell())

`save_session() -> Path`:
- Write JSON file to `{audit_dir}/{session_id}.json`
- Include: session_id, started_at (first message timestamp), ended_at (now), message_count, messages array
- Use `json.dumps(indent=2)` for readability
- Return the file path

**Session JSON structure:**
```json
{
  "session_id": "2026-01-28T10-30-45-abc12345",
  "started_at": "2026-01-28T10:30:45.123456",
  "ended_at": "2026-01-28T10:35:12.654321",
  "message_count": 8,
  "messages": [...]
}
```

Ensure audit_dir is created if it doesn't exist (use `audit_dir.mkdir(parents=True, exist_ok=True)`).
  </action>
  <verify>
Create a test script and run:
```python
import asyncio
from pathlib import Path
from operator_core.agent_lab import SessionAuditor, shell

async def test():
    # Create auditor with temp directory
    audit_dir = Path("/tmp/test_audit")
    auditor = SessionAuditor(audit_dir)

    # Log a message
    auditor.log_message("user", "Check system health")

    # Execute and log a tool call
    result = await shell("uptime", "checking system uptime")
    auditor.log_tool_call("shell", {"command": "uptime", "reasoning": "checking system uptime"}, result)

    # Log response
    auditor.log_message("assistant", "System is healthy")

    # Save and verify
    filepath = auditor.save_session()
    assert filepath.exists()
    print(f"Audit log saved to: {filepath}")

    # Check JSON content
    import json
    data = json.loads(filepath.read_text())
    assert data["message_count"] == 3
    assert data["session_id"] == auditor.session_id
    print(f"Session ID: {data['session_id']}")
    print("All tests passed!")

asyncio.run(test())
```
  </verify>
  <done>SessionAuditor logs messages and tool calls, saves to timestamped JSON files.</done>
</task>

</tasks>

<verification>
1. `docker build -f docker/agent/Dockerfile -t operator-agent:test docker/agent` completes successfully
2. `python -c "from operator_core.agent_lab import shell, SessionAuditor"` imports without error
3. shell() returns correct structured dict for echo command
4. shell() handles timeouts (sleep command with short timeout returns timed_out=True)
5. SessionAuditor creates JSON file with correct structure
6. Audit log filename includes timestamp and UUID component
</verification>

<success_criteria>
- Agent Dockerfile builds with all SRE tools installed
- shell() executes arbitrary commands with 120s default timeout
- shell() returns {stdout, stderr, exit_code, timed_out} dict
- SessionAuditor saves conversation history to timestamped JSON files
- All code follows existing codebase patterns (async, type hints, docstrings)
</success_criteria>

<output>
After completion, create `.planning/phases/30-core-agent/30-01-SUMMARY.md` using the summary template.
</output>
