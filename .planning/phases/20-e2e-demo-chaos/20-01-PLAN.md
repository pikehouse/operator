---
phase: 20-e2e-demo-chaos
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - demo/__init__.py
  - demo/types.py
  - demo/runner.py
autonomous: true

must_haves:
  truths:
    - "Demo runner accepts generic chapters and health pollers"
    - "Chapter dataclass supports on_enter callbacks and auto-advance"
    - "Chaos types are defined as an enum for type safety"
  artifacts:
    - path: "demo/__init__.py"
      provides: "Package initialization"
      min_lines: 1
    - path: "demo/types.py"
      provides: "Chapter, ChaosType, ChaosConfig dataclasses"
      min_lines: 40
    - path: "demo/runner.py"
      provides: "Generic DemoRunner class"
      min_lines: 60
  key_links:
    - from: "demo/runner.py"
      to: "demo/types.py"
      via: "Chapter import"
      pattern: "from demo.types import Chapter"
---

<objective>
Create shared demo infrastructure that works with any subject.

Purpose: Enable the same TUI demo framework to run for both TiKV and rate limiter subjects by abstracting chapter definitions, chaos configs, and health polling.

Output: `demo/` directory with Chapter/ChaosConfig types and a generic DemoRunner that accepts subject-specific chapters and health pollers as parameters.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-e2e-demo-chaos/20-RESEARCH.md
@.planning/phases/20-e2e-demo-chaos/20-CONTEXT.md

# Reference existing TUI infrastructure
@packages/operator-core/src/operator_core/tui/chapters.py
@packages/operator-core/src/operator_core/tui/controller.py
@packages/operator-core/src/operator_core/tui/layout.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create demo package with Chapter and Chaos types</name>
  <files>demo/__init__.py, demo/types.py</files>
  <action>
Create top-level `demo/` directory (NOT in packages/).

In `demo/__init__.py`:
- Empty file or minimal docstring

In `demo/types.py`:
- Import dataclass, Enum from typing
- Create `Chapter` dataclass (COPY structure from operator_core/tui/chapters.py):
  - title: str
  - narration: str
  - key_hint: str = "[dim]SPACE/ENTER: next | Q: quit[/dim]"
  - on_enter: Callable[[], Awaitable[None]] | None = None
  - auto_advance: bool = False
  - blocks_advance: bool = False
- Create `DemoState` class with same interface as existing (current, advance, get_current, is_complete, get_progress)
- Create `ChaosType` enum with values:
  - CONTAINER_KILL = "container_kill" (for TiKV)
  - REDIS_PAUSE = "redis_pause" (for counter drift)
  - BURST_TRAFFIC = "burst_traffic" (for ghost allowing)
- Create `ChaosConfig` dataclass:
  - name: str
  - chaos_type: ChaosType
  - description: str
  - duration_sec: float = 5.0
  - burst_multiplier: int = 2
- Create `HealthPollerProtocol` (Protocol class):
  - async def run(self) -> None
  - def get_health(self) -> dict[str, Any] | None
  - def stop(self) -> None

WHY: These are the shared abstractions that both TiKV and rate limiter demos will use. The Chapter dataclass is intentionally duplicated (not imported) to keep demo/ self-contained.
  </action>
  <verify>python -c "from demo.types import Chapter, DemoState, ChaosType, ChaosConfig, HealthPollerProtocol; print('Types OK')"</verify>
  <done>Chapter, DemoState, ChaosType, ChaosConfig, and HealthPollerProtocol are importable from demo.types</done>
</task>

<task type="auto">
  <name>Task 2: Create generic DemoRunner class</name>
  <files>demo/runner.py</files>
  <action>
Create `demo/runner.py` with a `DemoRunner` class that:

1. Constructor accepts:
   - subject_name: str (for display title)
   - chapters: list[Chapter]
   - health_poller: HealthPollerProtocol (subject-specific)
   - on_narration_update: Callable[[str], None] | None = None

2. Provides `run()` async method that:
   - Creates DemoState from chapters
   - Sets up signal handlers (SIGINT, SIGTERM)
   - Runs health poller as background task
   - Manages chapter progression with keyboard input
   - Calls on_enter callbacks when entering chapters
   - Handles auto-advance for chapters with auto_advance=True

3. Key implementation:
   - Use Rich Console for output
   - Use asyncio.Event for shutdown coordination
   - Handle keyboard input (space/enter to advance, Q to quit)

NOTE: This is a SIMPLIFIED runner compared to TUIController. It does NOT:
- Spawn subprocess monitors/agents
- Use the full 5-panel layout
- Poll workload metrics

The full TUI integration comes in Plan 02 (TiKV) and Plan 03 (rate limiter).

This runner is for testing the chapter/chaos abstraction works before integrating with TUI.

Pattern follows existing FaultWorkflow for countdown/callback patterns.
  </action>
  <verify>python -c "from demo.runner import DemoRunner; print('Runner OK')"</verify>
  <done>DemoRunner class is importable and accepts chapters + health_poller parameters</done>
</task>

</tasks>

<verification>
1. All files created in demo/ directory
2. Types importable: `from demo.types import Chapter, ChaosType, ChaosConfig`
3. Runner importable: `from demo.runner import DemoRunner`
4. No import errors from Rich or asyncio
</verification>

<success_criteria>
- demo/ directory exists at project root
- Chapter and ChaosConfig match patterns from RESEARCH.md
- DemoRunner accepts generic chapters list (not hardcoded TiKV)
- HealthPollerProtocol enables subject-specific health implementations
</success_criteria>

<output>
After completion, create `.planning/phases/20-e2e-demo-chaos/20-01-SUMMARY.md`
</output>
