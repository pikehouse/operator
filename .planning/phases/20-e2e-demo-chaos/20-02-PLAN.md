---
phase: 20-e2e-demo-chaos
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - demo/tikv.py
  - demo/tikv_health.py
  - demo/tikv_chaos.py
autonomous: true

must_haves:
  truths:
    - "TiKV demo runs with same chapter flow as existing TUI"
    - "TiKV health poller implements HealthPollerProtocol"
    - "TiKV chaos (node kill) uses existing patterns"
  artifacts:
    - path: "demo/tikv.py"
      provides: "TiKV demo entry point with chapters"
      min_lines: 80
    - path: "demo/tikv_health.py"
      provides: "TiKV health poller implementation"
      min_lines: 50
    - path: "demo/tikv_chaos.py"
      provides: "TiKV chaos injection (node kill)"
      min_lines: 40
  key_links:
    - from: "demo/tikv.py"
      to: "demo/types.py"
      via: "Chapter import"
      pattern: "from demo.types import Chapter"
    - from: "demo/tikv_health.py"
      to: "demo/types.py"
      via: "HealthPollerProtocol import"
      pattern: "from demo.types import HealthPollerProtocol"
---

<objective>
Create TiKV demo entry point with subject-specific chapters, health poller, and chaos.

Purpose: Extract TiKV-specific demo logic from existing TUI into the new demo/ framework, proving the abstraction works for the existing subject before adding rate limiter.

Output: TiKV demo that can be run via `python -m demo.tikv` using the shared demo infrastructure.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/20-e2e-demo-chaos/20-01-SUMMARY.md

# Reference existing TiKV TUI and chaos logic
@packages/operator-core/src/operator_core/tui/chapters.py
@packages/operator-core/src/operator_core/tui/health.py
@packages/operator-core/src/operator_core/tui/fault.py
@packages/operator-core/src/operator_core/demo/chaos.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TiKV health poller implementing HealthPollerProtocol</name>
  <files>demo/tikv_health.py</files>
  <action>
Create `demo/tikv_health.py` with `TiKVHealthPoller` class:

1. Implement HealthPollerProtocol:
   - async def run(self) -> None
   - def get_health(self) -> dict[str, Any] | None
   - def stop(self) -> None

2. Implementation (adapt from operator_core/tui/health.py):
   - Poll PD API at /pd/api/v1/stores and /pd/api/v1/health
   - Store latest health as dict with keys:
     - "nodes": list of {id, name, type, health, address}
     - "has_issues": bool
     - "last_updated": datetime
   - Use httpx.AsyncClient with base_url="http://localhost:2379"
   - Handle API failures gracefully (don't crash)

3. Constructor:
   - pd_endpoint: str = "http://localhost:2379"
   - poll_interval: float = 2.0

NOTE: This is a SIMPLIFIED version of ClusterHealthPoller that returns generic dict instead of ClusterHealth dataclass. This allows the demo framework to work with any subject's health data.

Pattern: Same async poll loop with asyncio.Event shutdown coordination.
  </action>
  <verify>python -c "from demo.tikv_health import TiKVHealthPoller; print('Health OK')"</verify>
  <done>TiKVHealthPoller implements HealthPollerProtocol and polls PD API</done>
</task>

<task type="auto">
  <name>Task 2: Create TiKV chaos injection module</name>
  <files>demo/tikv_chaos.py</files>
  <action>
Create `demo/tikv_chaos.py` with TiKV-specific chaos functions:

1. `async def kill_random_tikv(compose_file: Path) -> str | None`:
   - Use python-on-whales DockerClient
   - Get running TiKV containers (filter by "tikv" in name, state.running)
   - Randomly select one and kill with SIGKILL
   - Return container name or None if no targets
   - Pattern from operator_core/tui/fault.py

2. `async def restart_container(compose_file: Path, container_name: str) -> bool`:
   - Start the stopped container
   - Return True on success
   - Pattern from operator_core/tui/fault.py

3. `TIKV_CHAOS_CONFIG`:
   - ChaosConfig instance for node_kill scenario
   - chaos_type=ChaosType.CONTAINER_KILL
   - description="Kill random TiKV store with SIGKILL"

NOTE: Keep these as functions, not a class. The demo entry point will wire them into chapter callbacks.
  </action>
  <verify>python -c "from demo.tikv_chaos import kill_random_tikv, restart_container, TIKV_CHAOS_CONFIG; print('Chaos OK')"</verify>
  <done>TiKV chaos functions available for node kill and restart</done>
</task>

<task type="auto">
  <name>Task 3: Create TiKV demo entry point with chapters</name>
  <files>demo/tikv.py</files>
  <action>
Create `demo/tikv.py` with:

1. TIKV_CHAPTERS list of Chapter instances matching existing demo flow:
   - Chapter 1: "Welcome" - intro narration
   - Chapter 2: "Cluster Health" - check TiKV cluster via PD
   - Chapter 3: "Load Generation" - YCSB starting (auto_advance after brief pause)
   - Chapter 4: "Fault Injection" - countdown + kill node (blocks_advance=True, on_enter callback)
   - Chapter 5: "Detection" - waiting for monitor detection
   - Chapter 6: "AI Diagnosis" - Claude analyzing
   - Chapter 7: "Recovery" - restart node (auto_advance after recovery)
   - Chapter 8: "Complete" - demo finished

2. `create_fault_chapter(compose_file: Path) -> Chapter`:
   - Returns Chapter with on_enter that runs countdown then kills TiKV
   - Use asyncio.sleep for countdown
   - Pattern from create_fault_chapter in chapters.py

3. `create_recovery_chapter(compose_file: Path) -> Chapter`:
   - Returns Chapter with on_enter that restarts killed container
   - auto_advance=True after recovery

4. `async def main()`:
   - Create TiKVHealthPoller
   - Create chapters list (inserting fault/recovery chapters)
   - Instantiate DemoRunner with subject_name="TiKV"
   - Run demo

5. `if __name__ == "__main__":` block:
   - asyncio.run(main())

NOTE: This entry point demonstrates the pattern that demo/ratelimiter.py will follow.
  </action>
  <verify>python -c "from demo.tikv import TIKV_CHAPTERS, main; print(f'{len(TIKV_CHAPTERS)} chapters OK')"</verify>
  <done>TiKV demo entry point with chapters can be invoked via `python -m demo.tikv`</done>
</task>

</tasks>

<verification>
1. All files created in demo/ directory
2. TiKVHealthPoller passes type check for HealthPollerProtocol
3. Chaos functions work with docker-compose path
4. Demo can start: `python -m demo.tikv` (may fail on cluster access, but should import correctly)
</verification>

<success_criteria>
- TiKV demo uses shared Chapter type from demo.types
- Health poller implements protocol, returns generic dict
- Chaos uses existing python-on-whales patterns
- Demo structure matches existing TUI flow (8 chapters)
</success_criteria>

<output>
After completion, create `.planning/phases/20-e2e-demo-chaos/20-02-SUMMARY.md`
</output>
