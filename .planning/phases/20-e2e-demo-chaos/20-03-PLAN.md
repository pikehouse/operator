---
phase: 20-e2e-demo-chaos
plan: 03
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - demo/ratelimiter.py
  - demo/ratelimiter_health.py
  - demo/ratelimiter_chaos.py
autonomous: true

must_haves:
  truths:
    - "Rate limiter demo runs with chapter flow for counter drift and ghost allowing"
    - "Rate limiter health poller implements HealthPollerProtocol"
    - "Redis PAUSE causes counter drift anomaly"
    - "Burst traffic causes ghost allowing anomaly"
  artifacts:
    - path: "demo/ratelimiter.py"
      provides: "Rate limiter demo entry point with chapters"
      min_lines: 100
    - path: "demo/ratelimiter_health.py"
      provides: "Rate limiter health poller implementation"
      min_lines: 50
    - path: "demo/ratelimiter_chaos.py"
      provides: "Rate limiter chaos injection (Redis pause, burst)"
      min_lines: 60
  key_links:
    - from: "demo/ratelimiter.py"
      to: "demo/types.py"
      via: "Chapter import"
      pattern: "from demo.types import Chapter"
    - from: "demo/ratelimiter_chaos.py"
      to: "redis"
      via: "CLIENT PAUSE command"
      pattern: "CLIENT.*PAUSE"
---

<objective>
Create rate limiter demo entry point with counter drift and ghost allowing chaos scenarios.

Purpose: Demonstrate that the shared demo framework works for a second subject (rate limiter) with different chaos injection techniques (Redis PAUSE, burst traffic).

Output: Rate limiter demo that can be run via `python -m demo.ratelimiter` demonstrating both anomaly types.
</objective>

<execution_context>
@/Users/jrtipton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jrtipton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/20-e2e-demo-chaos/20-01-SUMMARY.md
@.planning/phases/20-e2e-demo-chaos/20-RESEARCH.md

# Reference rate limiter infrastructure
@packages/operator-ratelimiter/src/operator_ratelimiter/subject.py
@packages/operator-ratelimiter/src/operator_ratelimiter/invariants.py
@docker/docker-compose.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rate limiter health poller</name>
  <files>demo/ratelimiter_health.py</files>
  <action>
Create `demo/ratelimiter_health.py` with `RateLimiterHealthPoller` class:

1. Implement HealthPollerProtocol:
   - async def run(self) -> None
   - def get_health(self) -> dict[str, Any] | None
   - def stop(self) -> None

2. Implementation:
   - Poll rate limiter management API at /nodes endpoint
   - Check Redis connectivity via /health endpoint
   - Store latest health as dict with keys:
     - "nodes": list of {id, address, state} from /nodes
     - "redis_connected": bool from /health
     - "has_issues": bool (any node not "Up" OR redis disconnected)
     - "last_updated": datetime

3. Constructor:
   - endpoints: list[str] = ["http://localhost:8001", "http://localhost:8002", "http://localhost:8003"]
   - poll_interval: float = 2.0
   - Poll first reachable endpoint for node list

4. Use httpx.AsyncClient with timeout=5.0
   - Handle API failures gracefully (set has_issues=True on failure)

Pattern: Same async poll loop as TiKV health poller.
  </action>
  <verify>python -c "from demo.ratelimiter_health import RateLimiterHealthPoller; print('Health OK')"</verify>
  <done>RateLimiterHealthPoller implements HealthPollerProtocol and polls rate limiter API</done>
</task>

<task type="auto">
  <name>Task 2: Create rate limiter chaos injection module</name>
  <files>demo/ratelimiter_chaos.py</files>
  <action>
Create `demo/ratelimiter_chaos.py` with rate limiter-specific chaos functions:

1. `async def inject_redis_pause(duration_sec: float = 5.0) -> None`:
   - Use redis.asyncio to connect to Redis at localhost:6379
   - Execute CLIENT PAUSE {duration_ms} WRITE command
   - Per RESEARCH.md: WRITE mode blocks writes, allows reads
   - This causes counter drift as nodes can't update counters
   - Pattern from RESEARCH.md code examples

2. `async def inject_burst_traffic(target_urls: list[str], key: str, limit: int, multiplier: int = 2) -> dict[str, int]`:
   - Use httpx.AsyncClient to send burst_count = limit * multiplier requests
   - All requests sent concurrently via asyncio.gather
   - Each request: POST /check with {"key": key}
   - Return {"allowed": N, "denied": M} counts
   - This triggers ghost allowing when more than limit requests get through
   - Pattern from RESEARCH.md code examples

3. Constants:
   - COUNTER_DRIFT_CONFIG: ChaosConfig with chaos_type=ChaosType.REDIS_PAUSE, duration_sec=10.0
   - GHOST_ALLOWING_CONFIG: ChaosConfig with chaos_type=ChaosType.BURST_TRAFFIC, burst_multiplier=2

4. Helper: `async def setup_rate_limit(target_url: str, key: str, limit: int, window_sec: int = 60) -> None`:
   - POST /limit to set up a key with known limit before burst test
  </action>
  <verify>python -c "from demo.ratelimiter_chaos import inject_redis_pause, inject_burst_traffic, COUNTER_DRIFT_CONFIG, GHOST_ALLOWING_CONFIG; print('Chaos OK')"</verify>
  <done>Rate limiter chaos functions available for Redis PAUSE and burst traffic</done>
</task>

<task type="auto">
  <name>Task 3: Create rate limiter demo entry point with chapters</name>
  <files>demo/ratelimiter.py</files>
  <action>
Create `demo/ratelimiter.py` with:

1. RATELIMITER_CHAPTERS list demonstrating BOTH anomalies:
   - Chapter 1: "Welcome" - intro to rate limiter chaos demo
   - Chapter 2: "Cluster Health" - check 3 nodes + Redis
   - Chapter 3: "Setup" - create test key with limit (auto_advance)
   - Chapter 4: "Counter Drift Chaos" - countdown + Redis PAUSE (blocks_advance, on_enter)
   - Chapter 5: "Counter Drift Detection" - wait for invariant violation
   - Chapter 6: "Counter Drift Diagnosis" - AI analyzes counter drift
   - Chapter 7: "Recovery" - wait for Redis PAUSE to expire (auto_advance)
   - Chapter 8: "Ghost Allowing Chaos" - countdown + burst traffic (blocks_advance, on_enter)
   - Chapter 9: "Ghost Allowing Detection" - wait for ghost allowing violation
   - Chapter 10: "Ghost Allowing Diagnosis" - AI analyzes ghost allowing
   - Chapter 11: "Demo Complete"

2. Helper functions for chapter callbacks:
   - `create_counter_drift_chapter() -> Chapter`: on_enter runs countdown + inject_redis_pause
   - `create_ghost_allowing_chapter(key: str, limit: int) -> Chapter`: on_enter runs countdown + inject_burst_traffic
   - `create_setup_chapter(key: str, limit: int) -> Chapter`: on_enter sets up rate limit, auto_advance

3. `async def main()`:
   - Create RateLimiterHealthPoller
   - Define demo key ("demo-chaos-key") and limit (10)
   - Create chapters list
   - Instantiate DemoRunner with subject_name="Rate Limiter"
   - Run demo

4. `if __name__ == "__main__":` block

WHY: This demonstrates two distinct anomaly types in one demo, proving the AI can reason about rate limiter issues without system-specific prompts.
  </action>
  <verify>python -c "from demo.ratelimiter import RATELIMITER_CHAPTERS, main; print(f'{len(RATELIMITER_CHAPTERS)} chapters OK')"</verify>
  <done>Rate limiter demo entry point with 11 chapters demonstrating both anomaly types</done>
</task>

</tasks>

<verification>
1. All files created in demo/ directory
2. RateLimiterHealthPoller passes type check for HealthPollerProtocol
3. Chaos functions importable without Redis connection (only connect when called)
4. Demo can start: `python -m demo.ratelimiter` (may fail on service access, but should import correctly)
</verification>

<success_criteria>
- Rate limiter demo uses shared Chapter type from demo.types
- Redis PAUSE chaos uses CLIENT PAUSE WRITE command
- Burst traffic sends multiplier * limit concurrent requests
- Demo demonstrates both counter drift and ghost allowing scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/20-e2e-demo-chaos/20-03-SUMMARY.md`
</output>
